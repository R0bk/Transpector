"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_codemirror_legacy-modes_mode_haskell_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/haskell.js":
/*!***************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/haskell.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"haskell\": function() { return /* binding */ haskell; }\n/* harmony export */ });\nfunction switchState(source, setState, f) {\n  setState(f);\n  return f(source, setState);\n}\n\n// These should all be Unicode extended, as per the Haskell 2010 report\nvar smallRE = /[a-z_]/;\nvar largeRE = /[A-Z]/;\nvar digitRE = /\\d/;\nvar hexitRE = /[0-9A-Fa-f]/;\nvar octitRE = /[0-7]/;\nvar idRE = /[a-z_A-Z0-9'\\xa1-\\uffff]/;\nvar symbolRE = /[-!#$%&*+.\\/<=>?@\\\\^|~:]/;\nvar specialRE = /[(),;[\\]`{}]/;\nvar whiteCharRE = /[ \\t\\v\\f]/; // newlines are handled in tokenizer\n\nfunction normal(source, setState) {\n  if (source.eatWhile(whiteCharRE)) {\n    return null;\n  }\n\n  var ch = source.next();\n  if (specialRE.test(ch)) {\n    if (ch == '{' && source.eat('-')) {\n      var t = \"comment\";\n      if (source.eat('#')) {\n        t = \"meta\";\n      }\n      return switchState(source, setState, ncomment(t, 1));\n    }\n    return null;\n  }\n\n  if (ch == '\\'') {\n    if (source.eat('\\\\')) {\n      source.next();  // should handle other escapes here\n    }\n    else {\n      source.next();\n    }\n    if (source.eat('\\'')) {\n      return \"string\";\n    }\n    return \"error\";\n  }\n\n  if (ch == '\"') {\n    return switchState(source, setState, stringLiteral);\n  }\n\n  if (largeRE.test(ch)) {\n    source.eatWhile(idRE);\n    if (source.eat('.')) {\n      return \"qualifier\";\n    }\n    return \"type\";\n  }\n\n  if (smallRE.test(ch)) {\n    source.eatWhile(idRE);\n    return \"variable\";\n  }\n\n  if (digitRE.test(ch)) {\n    if (ch == '0') {\n      if (source.eat(/[xX]/)) {\n        source.eatWhile(hexitRE); // should require at least 1\n        return \"integer\";\n      }\n      if (source.eat(/[oO]/)) {\n        source.eatWhile(octitRE); // should require at least 1\n        return \"number\";\n      }\n    }\n    source.eatWhile(digitRE);\n    var t = \"number\";\n    if (source.match(/^\\.\\d+/)) {\n      t = \"number\";\n    }\n    if (source.eat(/[eE]/)) {\n      t = \"number\";\n      source.eat(/[-+]/);\n      source.eatWhile(digitRE); // should require at least 1\n    }\n    return t;\n  }\n\n  if (ch == \".\" && source.eat(\".\"))\n    return \"keyword\";\n\n  if (symbolRE.test(ch)) {\n    if (ch == '-' && source.eat(/-/)) {\n      source.eatWhile(/-/);\n      if (!source.eat(symbolRE)) {\n        source.skipToEnd();\n        return \"comment\";\n      }\n    }\n    source.eatWhile(symbolRE);\n    return \"variable\"\n  }\n\n  return \"error\";\n}\n\nfunction ncomment(type, nest) {\n  if (nest == 0) {\n    return normal;\n  }\n  return function(source, setState) {\n    var currNest = nest;\n    while (!source.eol()) {\n      var ch = source.next();\n      if (ch == '{' && source.eat('-')) {\n        ++currNest;\n      }\n      else if (ch == '-' && source.eat('}')) {\n        --currNest;\n        if (currNest == 0) {\n          setState(normal);\n          return type;\n        }\n      }\n    }\n    setState(ncomment(type, currNest));\n    return type;\n  };\n}\n\nfunction stringLiteral(source, setState) {\n  while (!source.eol()) {\n    var ch = source.next();\n    if (ch == '\"') {\n      setState(normal);\n      return \"string\";\n    }\n    if (ch == '\\\\') {\n      if (source.eol() || source.eat(whiteCharRE)) {\n        setState(stringGap);\n        return \"string\";\n      }\n      if (source.eat('&')) {\n      }\n      else {\n        source.next(); // should handle other escapes here\n      }\n    }\n  }\n  setState(normal);\n  return \"error\";\n}\n\nfunction stringGap(source, setState) {\n  if (source.eat('\\\\')) {\n    return switchState(source, setState, stringLiteral);\n  }\n  source.next();\n  setState(normal);\n  return \"error\";\n}\n\n\nvar wellKnownWords = (function() {\n  var wkw = {};\n  function setType(t) {\n    return function () {\n      for (var i = 0; i < arguments.length; i++)\n        wkw[arguments[i]] = t;\n    };\n  }\n\n  setType(\"keyword\")(\n    \"case\", \"class\", \"data\", \"default\", \"deriving\", \"do\", \"else\", \"foreign\",\n    \"if\", \"import\", \"in\", \"infix\", \"infixl\", \"infixr\", \"instance\", \"let\",\n    \"module\", \"newtype\", \"of\", \"then\", \"type\", \"where\", \"_\");\n\n  setType(\"keyword\")(\n    \"\\.\\.\", \":\", \"::\", \"=\", \"\\\\\", \"<-\", \"->\", \"@\", \"~\", \"=>\");\n\n  setType(\"builtin\")(\n    \"!!\", \"$!\", \"$\", \"&&\", \"+\", \"++\", \"-\", \".\", \"/\", \"/=\", \"<\", \"<*\", \"<=\",\n    \"<$>\", \"<*>\", \"=<<\", \"==\", \">\", \">=\", \">>\", \">>=\", \"^\", \"^^\", \"||\", \"*\",\n    \"*>\", \"**\");\n\n  setType(\"builtin\")(\n    \"Applicative\", \"Bool\", \"Bounded\", \"Char\", \"Double\", \"EQ\", \"Either\", \"Enum\",\n    \"Eq\", \"False\", \"FilePath\", \"Float\", \"Floating\", \"Fractional\", \"Functor\",\n    \"GT\", \"IO\", \"IOError\", \"Int\", \"Integer\", \"Integral\", \"Just\", \"LT\", \"Left\",\n    \"Maybe\", \"Monad\", \"Nothing\", \"Num\", \"Ord\", \"Ordering\", \"Rational\", \"Read\",\n    \"ReadS\", \"Real\", \"RealFloat\", \"RealFrac\", \"Right\", \"Show\", \"ShowS\",\n    \"String\", \"True\");\n\n  setType(\"builtin\")(\n    \"abs\", \"acos\", \"acosh\", \"all\", \"and\", \"any\", \"appendFile\", \"asTypeOf\",\n    \"asin\", \"asinh\", \"atan\", \"atan2\", \"atanh\", \"break\", \"catch\", \"ceiling\",\n    \"compare\", \"concat\", \"concatMap\", \"const\", \"cos\", \"cosh\", \"curry\",\n    \"cycle\", \"decodeFloat\", \"div\", \"divMod\", \"drop\", \"dropWhile\", \"either\",\n    \"elem\", \"encodeFloat\", \"enumFrom\", \"enumFromThen\", \"enumFromThenTo\",\n    \"enumFromTo\", \"error\", \"even\", \"exp\", \"exponent\", \"fail\", \"filter\",\n    \"flip\", \"floatDigits\", \"floatRadix\", \"floatRange\", \"floor\", \"fmap\",\n    \"foldl\", \"foldl1\", \"foldr\", \"foldr1\", \"fromEnum\", \"fromInteger\",\n    \"fromIntegral\", \"fromRational\", \"fst\", \"gcd\", \"getChar\", \"getContents\",\n    \"getLine\", \"head\", \"id\", \"init\", \"interact\", \"ioError\", \"isDenormalized\",\n    \"isIEEE\", \"isInfinite\", \"isNaN\", \"isNegativeZero\", \"iterate\", \"last\",\n    \"lcm\", \"length\", \"lex\", \"lines\", \"log\", \"logBase\", \"lookup\", \"map\",\n    \"mapM\", \"mapM_\", \"max\", \"maxBound\", \"maximum\", \"maybe\", \"min\", \"minBound\",\n    \"minimum\", \"mod\", \"negate\", \"not\", \"notElem\", \"null\", \"odd\", \"or\",\n    \"otherwise\", \"pi\", \"pred\", \"print\", \"product\", \"properFraction\", \"pure\",\n    \"putChar\", \"putStr\", \"putStrLn\", \"quot\", \"quotRem\", \"read\", \"readFile\",\n    \"readIO\", \"readList\", \"readLn\", \"readParen\", \"reads\", \"readsPrec\",\n    \"realToFrac\", \"recip\", \"rem\", \"repeat\", \"replicate\", \"return\", \"reverse\",\n    \"round\", \"scaleFloat\", \"scanl\", \"scanl1\", \"scanr\", \"scanr1\", \"seq\",\n    \"sequence\", \"sequence_\", \"show\", \"showChar\", \"showList\", \"showParen\",\n    \"showString\", \"shows\", \"showsPrec\", \"significand\", \"signum\", \"sin\",\n    \"sinh\", \"snd\", \"span\", \"splitAt\", \"sqrt\", \"subtract\", \"succ\", \"sum\",\n    \"tail\", \"take\", \"takeWhile\", \"tan\", \"tanh\", \"toEnum\", \"toInteger\",\n    \"toRational\", \"truncate\", \"uncurry\", \"undefined\", \"unlines\", \"until\",\n    \"unwords\", \"unzip\", \"unzip3\", \"userError\", \"words\", \"writeFile\", \"zip\",\n    \"zip3\", \"zipWith\", \"zipWith3\");\n\n  return wkw;\n})();\n\nconst haskell = {\n  name: \"haskell\",\n  startState: function ()  { return { f: normal }; },\n  copyState:  function (s) { return { f: s.f }; },\n\n  token: function(stream, state) {\n    var t = state.f(stream, function(s) { state.f = s; });\n    var w = stream.current();\n    return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;\n  },\n\n  languageData: {\n    commentTokens: {line: \"--\", block: {open: \"{-\", close: \"-}\"}}\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvaGFza2VsbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBLDZCQUE2QixTQUFTLGNBQWM7QUFDcEQsNkJBQTZCLFNBQVMsV0FBVzs7QUFFakQ7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLG9CQUFvQixvQkFBb0IsUUFBUSxjQUFjO0FBQzlEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL2hhc2tlbGwuanM/MTcwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBzd2l0Y2hTdGF0ZShzb3VyY2UsIHNldFN0YXRlLCBmKSB7XG4gIHNldFN0YXRlKGYpO1xuICByZXR1cm4gZihzb3VyY2UsIHNldFN0YXRlKTtcbn1cblxuLy8gVGhlc2Ugc2hvdWxkIGFsbCBiZSBVbmljb2RlIGV4dGVuZGVkLCBhcyBwZXIgdGhlIEhhc2tlbGwgMjAxMCByZXBvcnRcbnZhciBzbWFsbFJFID0gL1thLXpfXS87XG52YXIgbGFyZ2VSRSA9IC9bQS1aXS87XG52YXIgZGlnaXRSRSA9IC9cXGQvO1xudmFyIGhleGl0UkUgPSAvWzAtOUEtRmEtZl0vO1xudmFyIG9jdGl0UkUgPSAvWzAtN10vO1xudmFyIGlkUkUgPSAvW2Etel9BLVowLTknXFx4YTEtXFx1ZmZmZl0vO1xudmFyIHN5bWJvbFJFID0gL1stISMkJSYqKy5cXC88PT4/QFxcXFxefH46XS87XG52YXIgc3BlY2lhbFJFID0gL1soKSw7W1xcXWB7fV0vO1xudmFyIHdoaXRlQ2hhclJFID0gL1sgXFx0XFx2XFxmXS87IC8vIG5ld2xpbmVzIGFyZSBoYW5kbGVkIGluIHRva2VuaXplclxuXG5mdW5jdGlvbiBub3JtYWwoc291cmNlLCBzZXRTdGF0ZSkge1xuICBpZiAoc291cmNlLmVhdFdoaWxlKHdoaXRlQ2hhclJFKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGNoID0gc291cmNlLm5leHQoKTtcbiAgaWYgKHNwZWNpYWxSRS50ZXN0KGNoKSkge1xuICAgIGlmIChjaCA9PSAneycgJiYgc291cmNlLmVhdCgnLScpKSB7XG4gICAgICB2YXIgdCA9IFwiY29tbWVudFwiO1xuICAgICAgaWYgKHNvdXJjZS5lYXQoJyMnKSkge1xuICAgICAgICB0ID0gXCJtZXRhXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3dpdGNoU3RhdGUoc291cmNlLCBzZXRTdGF0ZSwgbmNvbW1lbnQodCwgMSkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjaCA9PSAnXFwnJykge1xuICAgIGlmIChzb3VyY2UuZWF0KCdcXFxcJykpIHtcbiAgICAgIHNvdXJjZS5uZXh0KCk7ICAvLyBzaG91bGQgaGFuZGxlIG90aGVyIGVzY2FwZXMgaGVyZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHNvdXJjZS5uZXh0KCk7XG4gICAgfVxuICAgIGlmIChzb3VyY2UuZWF0KCdcXCcnKSkge1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuICAgIHJldHVybiBcImVycm9yXCI7XG4gIH1cblxuICBpZiAoY2ggPT0gJ1wiJykge1xuICAgIHJldHVybiBzd2l0Y2hTdGF0ZShzb3VyY2UsIHNldFN0YXRlLCBzdHJpbmdMaXRlcmFsKTtcbiAgfVxuXG4gIGlmIChsYXJnZVJFLnRlc3QoY2gpKSB7XG4gICAgc291cmNlLmVhdFdoaWxlKGlkUkUpO1xuICAgIGlmIChzb3VyY2UuZWF0KCcuJykpIHtcbiAgICAgIHJldHVybiBcInF1YWxpZmllclwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJ0eXBlXCI7XG4gIH1cblxuICBpZiAoc21hbGxSRS50ZXN0KGNoKSkge1xuICAgIHNvdXJjZS5lYXRXaGlsZShpZFJFKTtcbiAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICB9XG5cbiAgaWYgKGRpZ2l0UkUudGVzdChjaCkpIHtcbiAgICBpZiAoY2ggPT0gJzAnKSB7XG4gICAgICBpZiAoc291cmNlLmVhdCgvW3hYXS8pKSB7XG4gICAgICAgIHNvdXJjZS5lYXRXaGlsZShoZXhpdFJFKTsgLy8gc2hvdWxkIHJlcXVpcmUgYXQgbGVhc3QgMVxuICAgICAgICByZXR1cm4gXCJpbnRlZ2VyXCI7XG4gICAgICB9XG4gICAgICBpZiAoc291cmNlLmVhdCgvW29PXS8pKSB7XG4gICAgICAgIHNvdXJjZS5lYXRXaGlsZShvY3RpdFJFKTsgLy8gc2hvdWxkIHJlcXVpcmUgYXQgbGVhc3QgMVxuICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlLmVhdFdoaWxlKGRpZ2l0UkUpO1xuICAgIHZhciB0ID0gXCJudW1iZXJcIjtcbiAgICBpZiAoc291cmNlLm1hdGNoKC9eXFwuXFxkKy8pKSB7XG4gICAgICB0ID0gXCJudW1iZXJcIjtcbiAgICB9XG4gICAgaWYgKHNvdXJjZS5lYXQoL1tlRV0vKSkge1xuICAgICAgdCA9IFwibnVtYmVyXCI7XG4gICAgICBzb3VyY2UuZWF0KC9bLStdLyk7XG4gICAgICBzb3VyY2UuZWF0V2hpbGUoZGlnaXRSRSk7IC8vIHNob3VsZCByZXF1aXJlIGF0IGxlYXN0IDFcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cblxuICBpZiAoY2ggPT0gXCIuXCIgJiYgc291cmNlLmVhdChcIi5cIikpXG4gICAgcmV0dXJuIFwia2V5d29yZFwiO1xuXG4gIGlmIChzeW1ib2xSRS50ZXN0KGNoKSkge1xuICAgIGlmIChjaCA9PSAnLScgJiYgc291cmNlLmVhdCgvLS8pKSB7XG4gICAgICBzb3VyY2UuZWF0V2hpbGUoLy0vKTtcbiAgICAgIGlmICghc291cmNlLmVhdChzeW1ib2xSRSkpIHtcbiAgICAgICAgc291cmNlLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZS5lYXRXaGlsZShzeW1ib2xSRSk7XG4gICAgcmV0dXJuIFwidmFyaWFibGVcIlxuICB9XG5cbiAgcmV0dXJuIFwiZXJyb3JcIjtcbn1cblxuZnVuY3Rpb24gbmNvbW1lbnQodHlwZSwgbmVzdCkge1xuICBpZiAobmVzdCA9PSAwKSB7XG4gICAgcmV0dXJuIG5vcm1hbDtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oc291cmNlLCBzZXRTdGF0ZSkge1xuICAgIHZhciBjdXJyTmVzdCA9IG5lc3Q7XG4gICAgd2hpbGUgKCFzb3VyY2UuZW9sKCkpIHtcbiAgICAgIHZhciBjaCA9IHNvdXJjZS5uZXh0KCk7XG4gICAgICBpZiAoY2ggPT0gJ3snICYmIHNvdXJjZS5lYXQoJy0nKSkge1xuICAgICAgICArK2N1cnJOZXN0O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY2ggPT0gJy0nICYmIHNvdXJjZS5lYXQoJ30nKSkge1xuICAgICAgICAtLWN1cnJOZXN0O1xuICAgICAgICBpZiAoY3Vyck5lc3QgPT0gMCkge1xuICAgICAgICAgIHNldFN0YXRlKG5vcm1hbCk7XG4gICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc2V0U3RhdGUobmNvbW1lbnQodHlwZSwgY3Vyck5lc3QpKTtcbiAgICByZXR1cm4gdHlwZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nTGl0ZXJhbChzb3VyY2UsIHNldFN0YXRlKSB7XG4gIHdoaWxlICghc291cmNlLmVvbCgpKSB7XG4gICAgdmFyIGNoID0gc291cmNlLm5leHQoKTtcbiAgICBpZiAoY2ggPT0gJ1wiJykge1xuICAgICAgc2V0U3RhdGUobm9ybWFsKTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbiAgICBpZiAoY2ggPT0gJ1xcXFwnKSB7XG4gICAgICBpZiAoc291cmNlLmVvbCgpIHx8IHNvdXJjZS5lYXQod2hpdGVDaGFyUkUpKSB7XG4gICAgICAgIHNldFN0YXRlKHN0cmluZ0dhcCk7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfVxuICAgICAgaWYgKHNvdXJjZS5lYXQoJyYnKSkge1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNvdXJjZS5uZXh0KCk7IC8vIHNob3VsZCBoYW5kbGUgb3RoZXIgZXNjYXBlcyBoZXJlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNldFN0YXRlKG5vcm1hbCk7XG4gIHJldHVybiBcImVycm9yXCI7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ0dhcChzb3VyY2UsIHNldFN0YXRlKSB7XG4gIGlmIChzb3VyY2UuZWF0KCdcXFxcJykpIHtcbiAgICByZXR1cm4gc3dpdGNoU3RhdGUoc291cmNlLCBzZXRTdGF0ZSwgc3RyaW5nTGl0ZXJhbCk7XG4gIH1cbiAgc291cmNlLm5leHQoKTtcbiAgc2V0U3RhdGUobm9ybWFsKTtcbiAgcmV0dXJuIFwiZXJyb3JcIjtcbn1cblxuXG52YXIgd2VsbEtub3duV29yZHMgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB3a3cgPSB7fTtcbiAgZnVuY3Rpb24gc2V0VHlwZSh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICB3a3dbYXJndW1lbnRzW2ldXSA9IHQ7XG4gICAgfTtcbiAgfVxuXG4gIHNldFR5cGUoXCJrZXl3b3JkXCIpKFxuICAgIFwiY2FzZVwiLCBcImNsYXNzXCIsIFwiZGF0YVwiLCBcImRlZmF1bHRcIiwgXCJkZXJpdmluZ1wiLCBcImRvXCIsIFwiZWxzZVwiLCBcImZvcmVpZ25cIixcbiAgICBcImlmXCIsIFwiaW1wb3J0XCIsIFwiaW5cIiwgXCJpbmZpeFwiLCBcImluZml4bFwiLCBcImluZml4clwiLCBcImluc3RhbmNlXCIsIFwibGV0XCIsXG4gICAgXCJtb2R1bGVcIiwgXCJuZXd0eXBlXCIsIFwib2ZcIiwgXCJ0aGVuXCIsIFwidHlwZVwiLCBcIndoZXJlXCIsIFwiX1wiKTtcblxuICBzZXRUeXBlKFwia2V5d29yZFwiKShcbiAgICBcIlxcLlxcLlwiLCBcIjpcIiwgXCI6OlwiLCBcIj1cIiwgXCJcXFxcXCIsIFwiPC1cIiwgXCItPlwiLCBcIkBcIiwgXCJ+XCIsIFwiPT5cIik7XG5cbiAgc2V0VHlwZShcImJ1aWx0aW5cIikoXG4gICAgXCIhIVwiLCBcIiQhXCIsIFwiJFwiLCBcIiYmXCIsIFwiK1wiLCBcIisrXCIsIFwiLVwiLCBcIi5cIiwgXCIvXCIsIFwiLz1cIiwgXCI8XCIsIFwiPCpcIiwgXCI8PVwiLFxuICAgIFwiPCQ+XCIsIFwiPCo+XCIsIFwiPTw8XCIsIFwiPT1cIiwgXCI+XCIsIFwiPj1cIiwgXCI+PlwiLCBcIj4+PVwiLCBcIl5cIiwgXCJeXlwiLCBcInx8XCIsIFwiKlwiLFxuICAgIFwiKj5cIiwgXCIqKlwiKTtcblxuICBzZXRUeXBlKFwiYnVpbHRpblwiKShcbiAgICBcIkFwcGxpY2F0aXZlXCIsIFwiQm9vbFwiLCBcIkJvdW5kZWRcIiwgXCJDaGFyXCIsIFwiRG91YmxlXCIsIFwiRVFcIiwgXCJFaXRoZXJcIiwgXCJFbnVtXCIsXG4gICAgXCJFcVwiLCBcIkZhbHNlXCIsIFwiRmlsZVBhdGhcIiwgXCJGbG9hdFwiLCBcIkZsb2F0aW5nXCIsIFwiRnJhY3Rpb25hbFwiLCBcIkZ1bmN0b3JcIixcbiAgICBcIkdUXCIsIFwiSU9cIiwgXCJJT0Vycm9yXCIsIFwiSW50XCIsIFwiSW50ZWdlclwiLCBcIkludGVncmFsXCIsIFwiSnVzdFwiLCBcIkxUXCIsIFwiTGVmdFwiLFxuICAgIFwiTWF5YmVcIiwgXCJNb25hZFwiLCBcIk5vdGhpbmdcIiwgXCJOdW1cIiwgXCJPcmRcIiwgXCJPcmRlcmluZ1wiLCBcIlJhdGlvbmFsXCIsIFwiUmVhZFwiLFxuICAgIFwiUmVhZFNcIiwgXCJSZWFsXCIsIFwiUmVhbEZsb2F0XCIsIFwiUmVhbEZyYWNcIiwgXCJSaWdodFwiLCBcIlNob3dcIiwgXCJTaG93U1wiLFxuICAgIFwiU3RyaW5nXCIsIFwiVHJ1ZVwiKTtcblxuICBzZXRUeXBlKFwiYnVpbHRpblwiKShcbiAgICBcImFic1wiLCBcImFjb3NcIiwgXCJhY29zaFwiLCBcImFsbFwiLCBcImFuZFwiLCBcImFueVwiLCBcImFwcGVuZEZpbGVcIiwgXCJhc1R5cGVPZlwiLFxuICAgIFwiYXNpblwiLCBcImFzaW5oXCIsIFwiYXRhblwiLCBcImF0YW4yXCIsIFwiYXRhbmhcIiwgXCJicmVha1wiLCBcImNhdGNoXCIsIFwiY2VpbGluZ1wiLFxuICAgIFwiY29tcGFyZVwiLCBcImNvbmNhdFwiLCBcImNvbmNhdE1hcFwiLCBcImNvbnN0XCIsIFwiY29zXCIsIFwiY29zaFwiLCBcImN1cnJ5XCIsXG4gICAgXCJjeWNsZVwiLCBcImRlY29kZUZsb2F0XCIsIFwiZGl2XCIsIFwiZGl2TW9kXCIsIFwiZHJvcFwiLCBcImRyb3BXaGlsZVwiLCBcImVpdGhlclwiLFxuICAgIFwiZWxlbVwiLCBcImVuY29kZUZsb2F0XCIsIFwiZW51bUZyb21cIiwgXCJlbnVtRnJvbVRoZW5cIiwgXCJlbnVtRnJvbVRoZW5Ub1wiLFxuICAgIFwiZW51bUZyb21Ub1wiLCBcImVycm9yXCIsIFwiZXZlblwiLCBcImV4cFwiLCBcImV4cG9uZW50XCIsIFwiZmFpbFwiLCBcImZpbHRlclwiLFxuICAgIFwiZmxpcFwiLCBcImZsb2F0RGlnaXRzXCIsIFwiZmxvYXRSYWRpeFwiLCBcImZsb2F0UmFuZ2VcIiwgXCJmbG9vclwiLCBcImZtYXBcIixcbiAgICBcImZvbGRsXCIsIFwiZm9sZGwxXCIsIFwiZm9sZHJcIiwgXCJmb2xkcjFcIiwgXCJmcm9tRW51bVwiLCBcImZyb21JbnRlZ2VyXCIsXG4gICAgXCJmcm9tSW50ZWdyYWxcIiwgXCJmcm9tUmF0aW9uYWxcIiwgXCJmc3RcIiwgXCJnY2RcIiwgXCJnZXRDaGFyXCIsIFwiZ2V0Q29udGVudHNcIixcbiAgICBcImdldExpbmVcIiwgXCJoZWFkXCIsIFwiaWRcIiwgXCJpbml0XCIsIFwiaW50ZXJhY3RcIiwgXCJpb0Vycm9yXCIsIFwiaXNEZW5vcm1hbGl6ZWRcIixcbiAgICBcImlzSUVFRVwiLCBcImlzSW5maW5pdGVcIiwgXCJpc05hTlwiLCBcImlzTmVnYXRpdmVaZXJvXCIsIFwiaXRlcmF0ZVwiLCBcImxhc3RcIixcbiAgICBcImxjbVwiLCBcImxlbmd0aFwiLCBcImxleFwiLCBcImxpbmVzXCIsIFwibG9nXCIsIFwibG9nQmFzZVwiLCBcImxvb2t1cFwiLCBcIm1hcFwiLFxuICAgIFwibWFwTVwiLCBcIm1hcE1fXCIsIFwibWF4XCIsIFwibWF4Qm91bmRcIiwgXCJtYXhpbXVtXCIsIFwibWF5YmVcIiwgXCJtaW5cIiwgXCJtaW5Cb3VuZFwiLFxuICAgIFwibWluaW11bVwiLCBcIm1vZFwiLCBcIm5lZ2F0ZVwiLCBcIm5vdFwiLCBcIm5vdEVsZW1cIiwgXCJudWxsXCIsIFwib2RkXCIsIFwib3JcIixcbiAgICBcIm90aGVyd2lzZVwiLCBcInBpXCIsIFwicHJlZFwiLCBcInByaW50XCIsIFwicHJvZHVjdFwiLCBcInByb3BlckZyYWN0aW9uXCIsIFwicHVyZVwiLFxuICAgIFwicHV0Q2hhclwiLCBcInB1dFN0clwiLCBcInB1dFN0ckxuXCIsIFwicXVvdFwiLCBcInF1b3RSZW1cIiwgXCJyZWFkXCIsIFwicmVhZEZpbGVcIixcbiAgICBcInJlYWRJT1wiLCBcInJlYWRMaXN0XCIsIFwicmVhZExuXCIsIFwicmVhZFBhcmVuXCIsIFwicmVhZHNcIiwgXCJyZWFkc1ByZWNcIixcbiAgICBcInJlYWxUb0ZyYWNcIiwgXCJyZWNpcFwiLCBcInJlbVwiLCBcInJlcGVhdFwiLCBcInJlcGxpY2F0ZVwiLCBcInJldHVyblwiLCBcInJldmVyc2VcIixcbiAgICBcInJvdW5kXCIsIFwic2NhbGVGbG9hdFwiLCBcInNjYW5sXCIsIFwic2NhbmwxXCIsIFwic2NhbnJcIiwgXCJzY2FucjFcIiwgXCJzZXFcIixcbiAgICBcInNlcXVlbmNlXCIsIFwic2VxdWVuY2VfXCIsIFwic2hvd1wiLCBcInNob3dDaGFyXCIsIFwic2hvd0xpc3RcIiwgXCJzaG93UGFyZW5cIixcbiAgICBcInNob3dTdHJpbmdcIiwgXCJzaG93c1wiLCBcInNob3dzUHJlY1wiLCBcInNpZ25pZmljYW5kXCIsIFwic2lnbnVtXCIsIFwic2luXCIsXG4gICAgXCJzaW5oXCIsIFwic25kXCIsIFwic3BhblwiLCBcInNwbGl0QXRcIiwgXCJzcXJ0XCIsIFwic3VidHJhY3RcIiwgXCJzdWNjXCIsIFwic3VtXCIsXG4gICAgXCJ0YWlsXCIsIFwidGFrZVwiLCBcInRha2VXaGlsZVwiLCBcInRhblwiLCBcInRhbmhcIiwgXCJ0b0VudW1cIiwgXCJ0b0ludGVnZXJcIixcbiAgICBcInRvUmF0aW9uYWxcIiwgXCJ0cnVuY2F0ZVwiLCBcInVuY3VycnlcIiwgXCJ1bmRlZmluZWRcIiwgXCJ1bmxpbmVzXCIsIFwidW50aWxcIixcbiAgICBcInVud29yZHNcIiwgXCJ1bnppcFwiLCBcInVuemlwM1wiLCBcInVzZXJFcnJvclwiLCBcIndvcmRzXCIsIFwid3JpdGVGaWxlXCIsIFwiemlwXCIsXG4gICAgXCJ6aXAzXCIsIFwiemlwV2l0aFwiLCBcInppcFdpdGgzXCIpO1xuXG4gIHJldHVybiB3a3c7XG59KSgpO1xuXG5leHBvcnQgY29uc3QgaGFza2VsbCA9IHtcbiAgbmFtZTogXCJoYXNrZWxsXCIsXG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpICB7IHJldHVybiB7IGY6IG5vcm1hbCB9OyB9LFxuICBjb3B5U3RhdGU6ICBmdW5jdGlvbiAocykgeyByZXR1cm4geyBmOiBzLmYgfTsgfSxcblxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciB0ID0gc3RhdGUuZihzdHJlYW0sIGZ1bmN0aW9uKHMpIHsgc3RhdGUuZiA9IHM7IH0pO1xuICAgIHZhciB3ID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICByZXR1cm4gd2VsbEtub3duV29yZHMuaGFzT3duUHJvcGVydHkodykgPyB3ZWxsS25vd25Xb3Jkc1t3XSA6IHQ7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiLS1cIiwgYmxvY2s6IHtvcGVuOiBcInstXCIsIGNsb3NlOiBcIi19XCJ9fVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/legacy-modes/mode/haskell.js\n"));

/***/ })

}]);