"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_codemirror_legacy-modes_mode_tcl_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/tcl.js":
/*!***********************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/tcl.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"tcl\": function() { return /* binding */ tcl; }\n/* harmony export */ });\nfunction parseWords(str) {\n  var obj = {}, words = str.split(\" \");\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n  return obj;\n}\nvar keywords = parseWords(\"Tcl safe after append array auto_execok auto_import auto_load \" +\n                          \"auto_mkindex auto_mkindex_old auto_qualify auto_reset bgerror \" +\n                          \"binary break catch cd close concat continue dde eof encoding error \" +\n                          \"eval exec exit expr fblocked fconfigure fcopy file fileevent filename \" +\n                          \"filename flush for foreach format gets glob global history http if \" +\n                          \"incr info interp join lappend lindex linsert list llength load lrange \" +\n                          \"lreplace lsearch lset lsort memory msgcat namespace open package parray \" +\n                          \"pid pkg::create pkg_mkIndex proc puts pwd re_syntax read regex regexp \" +\n                          \"registry regsub rename resource return scan seek set socket source split \" +\n                          \"string subst switch tcl_endOfWord tcl_findLibrary tcl_startOfNextWord \" +\n                          \"tcl_wordBreakAfter tcl_startOfPreviousWord tcl_wordBreakBefore tcltest \" +\n                          \"tclvars tell time trace unknown unset update uplevel upvar variable \" +\n                          \"vwait\");\nvar functions = parseWords(\"if elseif else and not or eq ne in ni for foreach while switch\");\nvar isOperatorChar = /[+\\-*&%=<>!?^\\/\\|]/;\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\nfunction tokenBase(stream, state) {\n  var beforeParams = state.beforeParams;\n  state.beforeParams = false;\n  var ch = stream.next();\n  if ((ch == '\"' || ch == \"'\") && state.inParams) {\n    return chain(stream, state, tokenString(ch));\n  } else if (/[\\[\\]{}\\(\\),;\\.]/.test(ch)) {\n    if (ch == \"(\" && beforeParams) state.inParams = true;\n    else if (ch == \")\") state.inParams = false;\n    return null;\n  } else if (/\\d/.test(ch)) {\n    stream.eatWhile(/[\\w\\.]/);\n    return \"number\";\n  } else if (ch == \"#\") {\n    if (stream.eat(\"*\"))\n      return chain(stream, state, tokenComment);\n    if (ch == \"#\" && stream.match(/ *\\[ *\\[/))\n      return chain(stream, state, tokenUnparsed);\n    stream.skipToEnd();\n    return \"comment\";\n  } else if (ch == '\"') {\n    stream.skipTo(/\"/);\n    return \"comment\";\n  } else if (ch == \"$\") {\n    stream.eatWhile(/[$_a-z0-9A-Z\\.{:]/);\n    stream.eatWhile(/}/);\n    state.beforeParams = true;\n    return \"builtin\";\n  } else if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return \"comment\";\n  } else {\n    stream.eatWhile(/[\\w\\$_{}\\xa1-\\uffff]/);\n    var word = stream.current().toLowerCase();\n    if (keywords && keywords.propertyIsEnumerable(word))\n      return \"keyword\";\n    if (functions && functions.propertyIsEnumerable(word)) {\n      state.beforeParams = true;\n      return \"keyword\";\n    }\n    return null;\n  }\n}\nfunction tokenString(quote) {\n  return function(stream, state) {\n    var escaped = false, next, end = false;\n    while ((next = stream.next()) != null) {\n      if (next == quote && !escaped) {\n        end = true;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    if (end) state.tokenize = tokenBase;\n    return \"string\";\n  };\n}\nfunction tokenComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \"#\" && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return \"comment\";\n}\nfunction tokenUnparsed(stream, state) {\n  var maybeEnd = 0, ch;\n  while (ch = stream.next()) {\n    if (ch == \"#\" && maybeEnd == 2) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    if (ch == \"]\")\n      maybeEnd++;\n    else if (ch != \" \")\n      maybeEnd = 0;\n  }\n  return \"meta\";\n}\nconst tcl = {\n  name: \"tcl\",\n  startState: function() {\n    return {\n      tokenize: tokenBase,\n      beforeParams: false,\n      inParams: false\n    };\n  },\n  token: function(stream, state) {\n    if (stream.eatSpace()) return null;\n    return state.tokenize(stream, state);\n  },\n  languageData: {\n    commentTokens: {line: \"#\"}\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvdGNsLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUJBQWlCLE1BQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0osb0NBQW9DO0FBQ3BDLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvdGNsLmpzP2FmN2UiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gcGFyc2VXb3JkcyhzdHIpIHtcbiAgdmFyIG9iaiA9IHt9LCB3b3JkcyA9IHN0ci5zcGxpdChcIiBcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIG9ialt3b3Jkc1tpXV0gPSB0cnVlO1xuICByZXR1cm4gb2JqO1xufVxudmFyIGtleXdvcmRzID0gcGFyc2VXb3JkcyhcIlRjbCBzYWZlIGFmdGVyIGFwcGVuZCBhcnJheSBhdXRvX2V4ZWNvayBhdXRvX2ltcG9ydCBhdXRvX2xvYWQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImF1dG9fbWtpbmRleCBhdXRvX21raW5kZXhfb2xkIGF1dG9fcXVhbGlmeSBhdXRvX3Jlc2V0IGJnZXJyb3IgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImJpbmFyeSBicmVhayBjYXRjaCBjZCBjbG9zZSBjb25jYXQgY29udGludWUgZGRlIGVvZiBlbmNvZGluZyBlcnJvciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXZhbCBleGVjIGV4aXQgZXhwciBmYmxvY2tlZCBmY29uZmlndXJlIGZjb3B5IGZpbGUgZmlsZWV2ZW50IGZpbGVuYW1lIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmaWxlbmFtZSBmbHVzaCBmb3IgZm9yZWFjaCBmb3JtYXQgZ2V0cyBnbG9iIGdsb2JhbCBoaXN0b3J5IGh0dHAgaWYgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImluY3IgaW5mbyBpbnRlcnAgam9pbiBsYXBwZW5kIGxpbmRleCBsaW5zZXJ0IGxpc3QgbGxlbmd0aCBsb2FkIGxyYW5nZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwibHJlcGxhY2UgbHNlYXJjaCBsc2V0IGxzb3J0IG1lbW9yeSBtc2djYXQgbmFtZXNwYWNlIG9wZW4gcGFja2FnZSBwYXJyYXkgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcInBpZCBwa2c6OmNyZWF0ZSBwa2dfbWtJbmRleCBwcm9jIHB1dHMgcHdkIHJlX3N5bnRheCByZWFkIHJlZ2V4IHJlZ2V4cCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwicmVnaXN0cnkgcmVnc3ViIHJlbmFtZSByZXNvdXJjZSByZXR1cm4gc2NhbiBzZWVrIHNldCBzb2NrZXQgc291cmNlIHNwbGl0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmcgc3Vic3Qgc3dpdGNoIHRjbF9lbmRPZldvcmQgdGNsX2ZpbmRMaWJyYXJ5IHRjbF9zdGFydE9mTmV4dFdvcmQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcInRjbF93b3JkQnJlYWtBZnRlciB0Y2xfc3RhcnRPZlByZXZpb3VzV29yZCB0Y2xfd29yZEJyZWFrQmVmb3JlIHRjbHRlc3QgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcInRjbHZhcnMgdGVsbCB0aW1lIHRyYWNlIHVua25vd24gdW5zZXQgdXBkYXRlIHVwbGV2ZWwgdXB2YXIgdmFyaWFibGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcInZ3YWl0XCIpO1xudmFyIGZ1bmN0aW9ucyA9IHBhcnNlV29yZHMoXCJpZiBlbHNlaWYgZWxzZSBhbmQgbm90IG9yIGVxIG5lIGluIG5pIGZvciBmb3JlYWNoIHdoaWxlIHN3aXRjaFwiKTtcbnZhciBpc09wZXJhdG9yQ2hhciA9IC9bK1xcLSomJT08PiE/XlxcL1xcfF0vO1xuZnVuY3Rpb24gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgZikge1xuICBzdGF0ZS50b2tlbml6ZSA9IGY7XG4gIHJldHVybiBmKHN0cmVhbSwgc3RhdGUpO1xufVxuZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGJlZm9yZVBhcmFtcyA9IHN0YXRlLmJlZm9yZVBhcmFtcztcbiAgc3RhdGUuYmVmb3JlUGFyYW1zID0gZmFsc2U7XG4gIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gIGlmICgoY2ggPT0gJ1wiJyB8fCBjaCA9PSBcIidcIikgJiYgc3RhdGUuaW5QYXJhbXMpIHtcbiAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5TdHJpbmcoY2gpKTtcbiAgfSBlbHNlIGlmICgvW1xcW1xcXXt9XFwoXFwpLDtcXC5dLy50ZXN0KGNoKSkge1xuICAgIGlmIChjaCA9PSBcIihcIiAmJiBiZWZvcmVQYXJhbXMpIHN0YXRlLmluUGFyYW1zID0gdHJ1ZTtcbiAgICBlbHNlIGlmIChjaCA9PSBcIilcIikgc3RhdGUuaW5QYXJhbXMgPSBmYWxzZTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmICgvXFxkLy50ZXN0KGNoKSkge1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcLl0vKTtcbiAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgfSBlbHNlIGlmIChjaCA9PSBcIiNcIikge1xuICAgIGlmIChzdHJlYW0uZWF0KFwiKlwiKSlcbiAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlbkNvbW1lbnQpO1xuICAgIGlmIChjaCA9PSBcIiNcIiAmJiBzdHJlYW0ubWF0Y2goLyAqXFxbICpcXFsvKSlcbiAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblVucGFyc2VkKTtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9IGVsc2UgaWYgKGNoID09ICdcIicpIHtcbiAgICBzdHJlYW0uc2tpcFRvKC9cIi8pO1xuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfSBlbHNlIGlmIChjaCA9PSBcIiRcIikge1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvWyRfYS16MC05QS1aXFwuezpdLyk7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC99Lyk7XG4gICAgc3RhdGUuYmVmb3JlUGFyYW1zID0gdHJ1ZTtcbiAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gIH0gZWxzZSBpZiAoaXNPcGVyYXRvckNoYXIudGVzdChjaCkpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoaXNPcGVyYXRvckNoYXIpO1xuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfe31cXHhhMS1cXHVmZmZmXS8pO1xuICAgIHZhciB3b3JkID0gc3RyZWFtLmN1cnJlbnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChrZXl3b3JkcyAmJiBrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZSh3b3JkKSlcbiAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICBpZiAoZnVuY3Rpb25zICYmIGZ1bmN0aW9ucy5wcm9wZXJ0eUlzRW51bWVyYWJsZSh3b3JkKSkge1xuICAgICAgc3RhdGUuYmVmb3JlUGFyYW1zID0gdHJ1ZTtcbiAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dCwgZW5kID0gZmFsc2U7XG4gICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKG5leHQgPT0gcXVvdGUgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICB9XG4gICAgaWYgKGVuZCkgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH07XG59XG5mdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgY2g7XG4gIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICBpZiAoY2ggPT0gXCIjXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgfVxuICByZXR1cm4gXCJjb21tZW50XCI7XG59XG5mdW5jdGlvbiB0b2tlblVucGFyc2VkKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG1heWJlRW5kID0gMCwgY2g7XG4gIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICBpZiAoY2ggPT0gXCIjXCIgJiYgbWF5YmVFbmQgPT0gMikge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGNoID09IFwiXVwiKVxuICAgICAgbWF5YmVFbmQrKztcbiAgICBlbHNlIGlmIChjaCAhPSBcIiBcIilcbiAgICAgIG1heWJlRW5kID0gMDtcbiAgfVxuICByZXR1cm4gXCJtZXRhXCI7XG59XG5leHBvcnQgY29uc3QgdGNsID0ge1xuICBuYW1lOiBcInRjbFwiLFxuICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgIGJlZm9yZVBhcmFtczogZmFsc2UsXG4gICAgICBpblBhcmFtczogZmFsc2VcbiAgICB9O1xuICB9LFxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICB9LFxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjb21tZW50VG9rZW5zOiB7bGluZTogXCIjXCJ9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/legacy-modes/mode/tcl.js\n"));

/***/ })

}]);