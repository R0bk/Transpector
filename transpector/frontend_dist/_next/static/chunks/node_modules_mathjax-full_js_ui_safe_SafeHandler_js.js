"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_mathjax-full_js_ui_safe_SafeHandler_js"],{

/***/ "./node_modules/mathjax-full/js/ui/safe/SafeHandler.js":
/*!*************************************************************!*\
  !*** ./node_modules/mathjax-full/js/ui/safe/SafeHandler.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SafeHandler = exports.SafeMathDocumentMixin = void 0;\nvar safe_js_1 = __webpack_require__(/*! ./safe.js */ \"./node_modules/mathjax-full/js/ui/safe/safe.js\");\nfunction SafeMathDocumentMixin(BaseDocument) {\n    var _a;\n    return _a = (function (_super) {\n            __extends(class_1, _super);\n            function class_1() {\n                var e_1, _a;\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;\n                _this.safe = new _this.options.SafeClass(_this, _this.options.safeOptions);\n                var ProcessBits = _this.constructor.ProcessBits;\n                if (!ProcessBits.has('safe')) {\n                    ProcessBits.allocate('safe');\n                }\n                try {\n                    for (var _b = __values(_this.inputJax), _c = _b.next(); !_c.done; _c = _b.next()) {\n                        var jax = _c.value;\n                        if (jax.name.match(/MathML/)) {\n                            jax.mathml.filterAttribute = _this.safe.mmlAttribute.bind(_this.safe);\n                            jax.mathml.filterClassList = _this.safe.mmlClassList.bind(_this.safe);\n                        }\n                        else if (jax.name.match(/TeX/)) {\n                            jax.postFilters.add(_this.sanitize.bind(jax), -5.5);\n                        }\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n                return _this;\n            }\n            class_1.prototype.sanitize = function (data) {\n                data.math.root = this.parseOptions.root;\n                data.document.safe.sanitize(data.math, data.document);\n            };\n            return class_1;\n        }(BaseDocument)),\n        _a.OPTIONS = __assign(__assign({}, BaseDocument.OPTIONS), { safeOptions: __assign({}, safe_js_1.Safe.OPTIONS), SafeClass: safe_js_1.Safe }),\n        _a;\n}\nexports.SafeMathDocumentMixin = SafeMathDocumentMixin;\nfunction SafeHandler(handler) {\n    handler.documentClass = SafeMathDocumentMixin(handler.documentClass);\n    return handler;\n}\nexports.SafeHandler = SafeHandler;\n//# sourceMappingURL=SafeHandler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL3VpL3NhZmUvU2FmZUhhbmRsZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyw2QkFBNkI7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxVQUFVO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx5Q0FBeUMsMkJBQTJCLHdCQUF3QixzREFBc0Q7QUFDbEo7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL3VpL3NhZmUvU2FmZUhhbmRsZXIuanM/Y2FjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TYWZlSGFuZGxlciA9IGV4cG9ydHMuU2FmZU1hdGhEb2N1bWVudE1peGluID0gdm9pZCAwO1xudmFyIHNhZmVfanNfMSA9IHJlcXVpcmUoXCIuL3NhZmUuanNcIik7XG5mdW5jdGlvbiBTYWZlTWF0aERvY3VtZW50TWl4aW4oQmFzZURvY3VtZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfYSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoY2xhc3NfMSwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncyksIGZhbHNlKSkgfHwgdGhpcztcbiAgICAgICAgICAgICAgICBfdGhpcy5zYWZlID0gbmV3IF90aGlzLm9wdGlvbnMuU2FmZUNsYXNzKF90aGlzLCBfdGhpcy5vcHRpb25zLnNhZmVPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB2YXIgUHJvY2Vzc0JpdHMgPSBfdGhpcy5jb25zdHJ1Y3Rvci5Qcm9jZXNzQml0cztcbiAgICAgICAgICAgICAgICBpZiAoIVByb2Nlc3NCaXRzLmhhcygnc2FmZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIFByb2Nlc3NCaXRzLmFsbG9jYXRlKCdzYWZlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoX3RoaXMuaW5wdXRKYXgpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgamF4ID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoamF4Lm5hbWUubWF0Y2goL01hdGhNTC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgamF4Lm1hdGhtbC5maWx0ZXJBdHRyaWJ1dGUgPSBfdGhpcy5zYWZlLm1tbEF0dHJpYnV0ZS5iaW5kKF90aGlzLnNhZmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpheC5tYXRobWwuZmlsdGVyQ2xhc3NMaXN0ID0gX3RoaXMuc2FmZS5tbWxDbGFzc0xpc3QuYmluZChfdGhpcy5zYWZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGpheC5uYW1lLm1hdGNoKC9UZVgvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpheC5wb3N0RmlsdGVycy5hZGQoX3RoaXMuc2FuaXRpemUuYmluZChqYXgpLCAtNS41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuc2FuaXRpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGRhdGEubWF0aC5yb290ID0gdGhpcy5wYXJzZU9wdGlvbnMucm9vdDtcbiAgICAgICAgICAgICAgICBkYXRhLmRvY3VtZW50LnNhZmUuc2FuaXRpemUoZGF0YS5tYXRoLCBkYXRhLmRvY3VtZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gY2xhc3NfMTtcbiAgICAgICAgfShCYXNlRG9jdW1lbnQpKSxcbiAgICAgICAgX2EuT1BUSU9OUyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBCYXNlRG9jdW1lbnQuT1BUSU9OUyksIHsgc2FmZU9wdGlvbnM6IF9fYXNzaWduKHt9LCBzYWZlX2pzXzEuU2FmZS5PUFRJT05TKSwgU2FmZUNsYXNzOiBzYWZlX2pzXzEuU2FmZSB9KSxcbiAgICAgICAgX2E7XG59XG5leHBvcnRzLlNhZmVNYXRoRG9jdW1lbnRNaXhpbiA9IFNhZmVNYXRoRG9jdW1lbnRNaXhpbjtcbmZ1bmN0aW9uIFNhZmVIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICBoYW5kbGVyLmRvY3VtZW50Q2xhc3MgPSBTYWZlTWF0aERvY3VtZW50TWl4aW4oaGFuZGxlci5kb2N1bWVudENsYXNzKTtcbiAgICByZXR1cm4gaGFuZGxlcjtcbn1cbmV4cG9ydHMuU2FmZUhhbmRsZXIgPSBTYWZlSGFuZGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNhZmVIYW5kbGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mathjax-full/js/ui/safe/SafeHandler.js\n"));

/***/ }),

/***/ "./node_modules/mathjax-full/js/ui/safe/SafeMethods.js":
/*!*************************************************************!*\
  !*** ./node_modules/mathjax-full/js/ui/safe/SafeMethods.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SafeMethods = void 0;\nvar lengths_js_1 = __webpack_require__(/*! ../../util/lengths.js */ \"./node_modules/mathjax-full/js/util/lengths.js\");\nexports.SafeMethods = {\n    filterURL: function (safe, url) {\n        var protocol = (url.match(/^\\s*([a-z]+):/i) || [null, ''])[1].toLowerCase();\n        var allow = safe.allow.URLs;\n        return (allow === 'all' || (allow === 'safe' &&\n            (safe.options.safeProtocols[protocol] || !protocol))) ? url : null;\n    },\n    filterClassList: function (safe, list) {\n        var _this = this;\n        var classes = list.trim().replace(/\\s\\s+/g, ' ').split(/ /);\n        return classes.map(function (name) { return _this.filterClass(safe, name) || ''; }).join(' ').trim().replace(/\\s\\s+/g, '');\n    },\n    filterClass: function (safe, CLASS) {\n        var allow = safe.allow.classes;\n        return (allow === 'all' || (allow === 'safe' && CLASS.match(safe.options.classPattern))) ? CLASS : null;\n    },\n    filterID: function (safe, id) {\n        var allow = safe.allow.cssIDs;\n        return (allow === 'all' || (allow === 'safe' && id.match(safe.options.idPattern))) ? id : null;\n    },\n    filterStyles: function (safe, styles) {\n        var e_1, _a, e_2, _b;\n        if (safe.allow.styles === 'all')\n            return styles;\n        if (safe.allow.styles !== 'safe')\n            return null;\n        var adaptor = safe.adaptor;\n        var options = safe.options;\n        try {\n            var div1 = adaptor.node('div', { style: styles });\n            var div2 = adaptor.node('div');\n            try {\n                for (var _c = __values(Object.keys(options.safeStyles)), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var style = _d.value;\n                    if (options.styleParts[style]) {\n                        try {\n                            for (var _e = (e_2 = void 0, __values(['Top', 'Right', 'Bottom', 'Left'])), _f = _e.next(); !_f.done; _f = _e.next()) {\n                                var sufix = _f.value;\n                                var name_1 = style + sufix;\n                                var value = this.filterStyle(safe, name_1, div1);\n                                if (value) {\n                                    adaptor.setStyle(div2, name_1, value);\n                                }\n                            }\n                        }\n                        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                        finally {\n                            try {\n                                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                            }\n                            finally { if (e_2) throw e_2.error; }\n                        }\n                    }\n                    else {\n                        var value = this.filterStyle(safe, style, div1);\n                        if (value) {\n                            adaptor.setStyle(div2, style, value);\n                        }\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            styles = adaptor.allStyles(div2);\n        }\n        catch (err) {\n            styles = '';\n        }\n        return styles;\n    },\n    filterStyle: function (safe, style, div) {\n        var value = safe.adaptor.getStyle(div, style);\n        if (typeof value !== 'string' || value === '' || value.match(/^\\s*calc/) ||\n            (value.match(/javascript:/) && !safe.options.safeProtocols.javascript) ||\n            (value.match(/data:/) && !safe.options.safeProtocols.data)) {\n            return null;\n        }\n        var name = style.replace(/Top|Right|Left|Bottom/, '');\n        if (!safe.options.safeStyles[style] && !safe.options.safeStyles[name]) {\n            return null;\n        }\n        return this.filterStyleValue(safe, style, value, div);\n    },\n    filterStyleValue: function (safe, style, value, div) {\n        var name = safe.options.styleLengths[style];\n        if (!name) {\n            return value;\n        }\n        if (typeof name !== 'string') {\n            return this.filterStyleLength(safe, style, value);\n        }\n        var length = this.filterStyleLength(safe, name, safe.adaptor.getStyle(div, name));\n        if (!length) {\n            return null;\n        }\n        safe.adaptor.setStyle(div, name, length);\n        return safe.adaptor.getStyle(div, style);\n    },\n    filterStyleLength: function (safe, style, value) {\n        if (!value.match(/^(.+)(em|ex|ch|rem|px|mm|cm|in|pt|pc|%)$/))\n            return null;\n        var em = (0, lengths_js_1.length2em)(value, 1);\n        var lengths = safe.options.styleLengths[style];\n        var _a = __read((Array.isArray(lengths) ? lengths : [-safe.options.lengthMax, safe.options.lengthMax]), 2), m = _a[0], M = _a[1];\n        return (m <= em && em <= M ? value : (em < m ? m : M).toFixed(3).replace(/\\.?0+$/, '') + 'em');\n    },\n    filterFontSize: function (safe, size) {\n        return this.filterStyleLength(safe, 'fontSize', size);\n    },\n    filterSizeMultiplier: function (safe, size) {\n        var _a = __read(safe.options.scriptsizemultiplierRange || [-Infinity, Infinity], 2), m = _a[0], M = _a[1];\n        return Math.min(M, Math.max(m, parseFloat(size))).toString();\n    },\n    filterScriptLevel: function (safe, level) {\n        var _a = __read(safe.options.scriptlevelRange || [-Infinity, Infinity], 2), m = _a[0], M = _a[1];\n        return Math.min(M, Math.max(m, parseInt(level))).toString();\n    },\n    filterData: function (safe, value, id) {\n        return (id.match(safe.options.dataPattern) ? value : null);\n    }\n};\n//# sourceMappingURL=SafeMethods.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL3VpL3NhZmUvU2FmZU1ldGhvZHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsbUJBQW1CLG1CQUFPLENBQUMsNkVBQXVCO0FBQ2xELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2Q0FBNkM7QUFDMUYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGVBQWU7QUFDNUQ7QUFDQTtBQUNBLHlGQUF5RixVQUFVO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SCxVQUFVO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvdWkvc2FmZS9TYWZlTWV0aG9kcy5qcz85MDg4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TYWZlTWV0aG9kcyA9IHZvaWQgMDtcbnZhciBsZW5ndGhzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9sZW5ndGhzLmpzXCIpO1xuZXhwb3J0cy5TYWZlTWV0aG9kcyA9IHtcbiAgICBmaWx0ZXJVUkw6IGZ1bmN0aW9uIChzYWZlLCB1cmwpIHtcbiAgICAgICAgdmFyIHByb3RvY29sID0gKHVybC5tYXRjaCgvXlxccyooW2Etel0rKTovaSkgfHwgW251bGwsICcnXSlbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGFsbG93ID0gc2FmZS5hbGxvdy5VUkxzO1xuICAgICAgICByZXR1cm4gKGFsbG93ID09PSAnYWxsJyB8fCAoYWxsb3cgPT09ICdzYWZlJyAmJlxuICAgICAgICAgICAgKHNhZmUub3B0aW9ucy5zYWZlUHJvdG9jb2xzW3Byb3RvY29sXSB8fCAhcHJvdG9jb2wpKSkgPyB1cmwgOiBudWxsO1xuICAgIH0sXG4gICAgZmlsdGVyQ2xhc3NMaXN0OiBmdW5jdGlvbiAoc2FmZSwgbGlzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2xhc3NlcyA9IGxpc3QudHJpbSgpLnJlcGxhY2UoL1xcc1xccysvZywgJyAnKS5zcGxpdCgvIC8pO1xuICAgICAgICByZXR1cm4gY2xhc3Nlcy5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLmZpbHRlckNsYXNzKHNhZmUsIG5hbWUpIHx8ICcnOyB9KS5qb2luKCcgJykudHJpbSgpLnJlcGxhY2UoL1xcc1xccysvZywgJycpO1xuICAgIH0sXG4gICAgZmlsdGVyQ2xhc3M6IGZ1bmN0aW9uIChzYWZlLCBDTEFTUykge1xuICAgICAgICB2YXIgYWxsb3cgPSBzYWZlLmFsbG93LmNsYXNzZXM7XG4gICAgICAgIHJldHVybiAoYWxsb3cgPT09ICdhbGwnIHx8IChhbGxvdyA9PT0gJ3NhZmUnICYmIENMQVNTLm1hdGNoKHNhZmUub3B0aW9ucy5jbGFzc1BhdHRlcm4pKSkgPyBDTEFTUyA6IG51bGw7XG4gICAgfSxcbiAgICBmaWx0ZXJJRDogZnVuY3Rpb24gKHNhZmUsIGlkKSB7XG4gICAgICAgIHZhciBhbGxvdyA9IHNhZmUuYWxsb3cuY3NzSURzO1xuICAgICAgICByZXR1cm4gKGFsbG93ID09PSAnYWxsJyB8fCAoYWxsb3cgPT09ICdzYWZlJyAmJiBpZC5tYXRjaChzYWZlLm9wdGlvbnMuaWRQYXR0ZXJuKSkpID8gaWQgOiBudWxsO1xuICAgIH0sXG4gICAgZmlsdGVyU3R5bGVzOiBmdW5jdGlvbiAoc2FmZSwgc3R5bGVzKSB7XG4gICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iO1xuICAgICAgICBpZiAoc2FmZS5hbGxvdy5zdHlsZXMgPT09ICdhbGwnKVxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgICAgaWYgKHNhZmUuYWxsb3cuc3R5bGVzICE9PSAnc2FmZScpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGFkYXB0b3IgPSBzYWZlLmFkYXB0b3I7XG4gICAgICAgIHZhciBvcHRpb25zID0gc2FmZS5vcHRpb25zO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGRpdjEgPSBhZGFwdG9yLm5vZGUoJ2RpdicsIHsgc3R5bGU6IHN0eWxlcyB9KTtcbiAgICAgICAgICAgIHZhciBkaXYyID0gYWRhcHRvci5ub2RlKCdkaXYnKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhvcHRpb25zLnNhZmVTdHlsZXMpKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3R5bGVQYXJ0c1tzdHlsZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2UgPSAoZV8yID0gdm9pZCAwLCBfX3ZhbHVlcyhbJ1RvcCcsICdSaWdodCcsICdCb3R0b20nLCAnTGVmdCddKSksIF9mID0gX2UubmV4dCgpOyAhX2YuZG9uZTsgX2YgPSBfZS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1Zml4ID0gX2YudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBzdHlsZSArIHN1Zml4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmZpbHRlclN0eWxlKHNhZmUsIG5hbWVfMSwgZGl2MSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRhcHRvci5zZXRTdHlsZShkaXYyLCBuYW1lXzEsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2YgJiYgIV9mLmRvbmUgJiYgKF9iID0gX2UucmV0dXJuKSkgX2IuY2FsbChfZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZmlsdGVyU3R5bGUoc2FmZSwgc3R5bGUsIGRpdjEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRhcHRvci5zZXRTdHlsZShkaXYyLCBzdHlsZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVzID0gYWRhcHRvci5hbGxTdHlsZXMoZGl2Mik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc3R5bGVzID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9LFxuICAgIGZpbHRlclN0eWxlOiBmdW5jdGlvbiAoc2FmZSwgc3R5bGUsIGRpdikge1xuICAgICAgICB2YXIgdmFsdWUgPSBzYWZlLmFkYXB0b3IuZ2V0U3R5bGUoZGl2LCBzdHlsZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8IHZhbHVlID09PSAnJyB8fCB2YWx1ZS5tYXRjaCgvXlxccypjYWxjLykgfHxcbiAgICAgICAgICAgICh2YWx1ZS5tYXRjaCgvamF2YXNjcmlwdDovKSAmJiAhc2FmZS5vcHRpb25zLnNhZmVQcm90b2NvbHMuamF2YXNjcmlwdCkgfHxcbiAgICAgICAgICAgICh2YWx1ZS5tYXRjaCgvZGF0YTovKSAmJiAhc2FmZS5vcHRpb25zLnNhZmVQcm90b2NvbHMuZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gc3R5bGUucmVwbGFjZSgvVG9wfFJpZ2h0fExlZnR8Qm90dG9tLywgJycpO1xuICAgICAgICBpZiAoIXNhZmUub3B0aW9ucy5zYWZlU3R5bGVzW3N0eWxlXSAmJiAhc2FmZS5vcHRpb25zLnNhZmVTdHlsZXNbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlclN0eWxlVmFsdWUoc2FmZSwgc3R5bGUsIHZhbHVlLCBkaXYpO1xuICAgIH0sXG4gICAgZmlsdGVyU3R5bGVWYWx1ZTogZnVuY3Rpb24gKHNhZmUsIHN0eWxlLCB2YWx1ZSwgZGl2KSB7XG4gICAgICAgIHZhciBuYW1lID0gc2FmZS5vcHRpb25zLnN0eWxlTGVuZ3Roc1tzdHlsZV07XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlclN0eWxlTGVuZ3RoKHNhZmUsIHN0eWxlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuZmlsdGVyU3R5bGVMZW5ndGgoc2FmZSwgbmFtZSwgc2FmZS5hZGFwdG9yLmdldFN0eWxlKGRpdiwgbmFtZSkpO1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc2FmZS5hZGFwdG9yLnNldFN0eWxlKGRpdiwgbmFtZSwgbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHNhZmUuYWRhcHRvci5nZXRTdHlsZShkaXYsIHN0eWxlKTtcbiAgICB9LFxuICAgIGZpbHRlclN0eWxlTGVuZ3RoOiBmdW5jdGlvbiAoc2FmZSwgc3R5bGUsIHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUubWF0Y2goL14oLispKGVtfGV4fGNofHJlbXxweHxtbXxjbXxpbnxwdHxwY3wlKSQvKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgZW0gPSAoMCwgbGVuZ3Roc19qc18xLmxlbmd0aDJlbSkodmFsdWUsIDEpO1xuICAgICAgICB2YXIgbGVuZ3RocyA9IHNhZmUub3B0aW9ucy5zdHlsZUxlbmd0aHNbc3R5bGVdO1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQoKEFycmF5LmlzQXJyYXkobGVuZ3RocykgPyBsZW5ndGhzIDogWy1zYWZlLm9wdGlvbnMubGVuZ3RoTWF4LCBzYWZlLm9wdGlvbnMubGVuZ3RoTWF4XSksIDIpLCBtID0gX2FbMF0sIE0gPSBfYVsxXTtcbiAgICAgICAgcmV0dXJuIChtIDw9IGVtICYmIGVtIDw9IE0gPyB2YWx1ZSA6IChlbSA8IG0gPyBtIDogTSkudG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpICsgJ2VtJyk7XG4gICAgfSxcbiAgICBmaWx0ZXJGb250U2l6ZTogZnVuY3Rpb24gKHNhZmUsIHNpemUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyU3R5bGVMZW5ndGgoc2FmZSwgJ2ZvbnRTaXplJywgc2l6ZSk7XG4gICAgfSxcbiAgICBmaWx0ZXJTaXplTXVsdGlwbGllcjogZnVuY3Rpb24gKHNhZmUsIHNpemUpIHtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKHNhZmUub3B0aW9ucy5zY3JpcHRzaXplbXVsdGlwbGllclJhbmdlIHx8IFstSW5maW5pdHksIEluZmluaXR5XSwgMiksIG0gPSBfYVswXSwgTSA9IF9hWzFdO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oTSwgTWF0aC5tYXgobSwgcGFyc2VGbG9hdChzaXplKSkpLnRvU3RyaW5nKCk7XG4gICAgfSxcbiAgICBmaWx0ZXJTY3JpcHRMZXZlbDogZnVuY3Rpb24gKHNhZmUsIGxldmVsKSB7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChzYWZlLm9wdGlvbnMuc2NyaXB0bGV2ZWxSYW5nZSB8fCBbLUluZmluaXR5LCBJbmZpbml0eV0sIDIpLCBtID0gX2FbMF0sIE0gPSBfYVsxXTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE0sIE1hdGgubWF4KG0sIHBhcnNlSW50KGxldmVsKSkpLnRvU3RyaW5nKCk7XG4gICAgfSxcbiAgICBmaWx0ZXJEYXRhOiBmdW5jdGlvbiAoc2FmZSwgdmFsdWUsIGlkKSB7XG4gICAgICAgIHJldHVybiAoaWQubWF0Y2goc2FmZS5vcHRpb25zLmRhdGFQYXR0ZXJuKSA/IHZhbHVlIDogbnVsbCk7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNhZmVNZXRob2RzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mathjax-full/js/ui/safe/SafeMethods.js\n"));

/***/ }),

/***/ "./node_modules/mathjax-full/js/ui/safe/safe.js":
/*!******************************************************!*\
  !*** ./node_modules/mathjax-full/js/ui/safe/safe.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Safe = void 0;\nvar Options_js_1 = __webpack_require__(/*! ../../util/Options.js */ \"./node_modules/mathjax-full/js/util/Options.js\");\nvar SafeMethods_js_1 = __webpack_require__(/*! ./SafeMethods.js */ \"./node_modules/mathjax-full/js/ui/safe/SafeMethods.js\");\nvar Safe = (function () {\n    function Safe(document, options) {\n        this.filterAttributes = new Map([\n            ['href', 'filterURL'],\n            ['src', 'filterURL'],\n            ['altimg', 'filterURL'],\n            ['class', 'filterClassList'],\n            ['style', 'filterStyles'],\n            ['id', 'filterID'],\n            ['fontsize', 'filterFontSize'],\n            ['mathsize', 'filterFontSize'],\n            ['scriptminsize', 'filterFontSize'],\n            ['scriptsizemultiplier', 'filterSizeMultiplier'],\n            ['scriptlevel', 'filterScriptLevel'],\n            ['data-', 'filterData']\n        ]);\n        this.filterMethods = __assign({}, SafeMethods_js_1.SafeMethods);\n        this.adaptor = document.adaptor;\n        this.options = options;\n        this.allow = this.options.allow;\n    }\n    Safe.prototype.sanitize = function (math, document) {\n        try {\n            math.root.walkTree(this.sanitizeNode.bind(this));\n        }\n        catch (err) {\n            document.options.compileError(document, math, err);\n        }\n    };\n    Safe.prototype.sanitizeNode = function (node) {\n        var e_1, _a;\n        var attributes = node.attributes.getAllAttributes();\n        try {\n            for (var _b = __values(Object.keys(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var id = _c.value;\n                var method = this.filterAttributes.get(id);\n                if (method) {\n                    var value = this.filterMethods[method](this, attributes[id]);\n                    if (value) {\n                        if (value !== (typeof value === 'number' ? parseFloat(attributes[id]) : attributes[id])) {\n                            attributes[id] = value;\n                        }\n                    }\n                    else {\n                        delete attributes[id];\n                    }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    Safe.prototype.mmlAttribute = function (id, value) {\n        if (id === 'class')\n            return null;\n        var method = this.filterAttributes.get(id);\n        var filter = (method || (id.substr(0, 5) === 'data-' ? this.filterAttributes.get('data-') : null));\n        if (!filter) {\n            return value;\n        }\n        var result = this.filterMethods[filter](this, value, id);\n        return (typeof result === 'number' || typeof result === 'boolean' ? String(result) : result);\n    };\n    Safe.prototype.mmlClassList = function (list) {\n        var _this = this;\n        return list.map(function (name) { return _this.filterMethods.filterClass(_this, name); })\n            .filter(function (value) { return value !== null; });\n    };\n    Safe.OPTIONS = {\n        allow: {\n            URLs: 'safe',\n            classes: 'safe',\n            cssIDs: 'safe',\n            styles: 'safe'\n        },\n        lengthMax: 3,\n        scriptsizemultiplierRange: [.6, 1],\n        scriptlevelRange: [-2, 2],\n        classPattern: /^mjx-[-a-zA-Z0-9_.]+$/,\n        idPattern: /^mjx-[-a-zA-Z0-9_.]+$/,\n        dataPattern: /^data-mjx-/,\n        safeProtocols: (0, Options_js_1.expandable)({\n            http: true,\n            https: true,\n            file: true,\n            javascript: false,\n            data: false\n        }),\n        safeStyles: (0, Options_js_1.expandable)({\n            color: true,\n            backgroundColor: true,\n            border: true,\n            cursor: true,\n            margin: true,\n            padding: true,\n            textShadow: true,\n            fontFamily: true,\n            fontSize: true,\n            fontStyle: true,\n            fontWeight: true,\n            opacity: true,\n            outline: true\n        }),\n        styleParts: (0, Options_js_1.expandable)({\n            border: true,\n            padding: true,\n            margin: true,\n            outline: true\n        }),\n        styleLengths: (0, Options_js_1.expandable)({\n            borderTop: 'borderTopWidth',\n            borderRight: 'borderRightWidth',\n            borderBottom: 'borderBottomWidth',\n            borderLeft: 'borderLeftWidth',\n            paddingTop: true,\n            paddingRight: true,\n            paddingBottom: true,\n            paddingLeft: true,\n            marginTop: true,\n            marginRight: true,\n            marginBottom: true,\n            marginLeft: true,\n            outlineTop: true,\n            outlineRight: true,\n            outlineBottom: true,\n            outlineLeft: true,\n            fontSize: [.707, 1.44]\n        })\n    };\n    return Safe;\n}());\nexports.Safe = Safe;\n//# sourceMappingURL=safe.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL3VpL3NhZmUvc2FmZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVk7QUFDWixtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBdUI7QUFDbEQsdUJBQXVCLG1CQUFPLENBQUMsK0VBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFVBQVU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNEQUFzRDtBQUNoRyx1Q0FBdUMsd0JBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsWUFBWTtBQUNaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvdWkvc2FmZS9zYWZlLmpzPzgxZWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TYWZlID0gdm9pZCAwO1xudmFyIE9wdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL09wdGlvbnMuanNcIik7XG52YXIgU2FmZU1ldGhvZHNfanNfMSA9IHJlcXVpcmUoXCIuL1NhZmVNZXRob2RzLmpzXCIpO1xudmFyIFNhZmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNhZmUoZG9jdW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJBdHRyaWJ1dGVzID0gbmV3IE1hcChbXG4gICAgICAgICAgICBbJ2hyZWYnLCAnZmlsdGVyVVJMJ10sXG4gICAgICAgICAgICBbJ3NyYycsICdmaWx0ZXJVUkwnXSxcbiAgICAgICAgICAgIFsnYWx0aW1nJywgJ2ZpbHRlclVSTCddLFxuICAgICAgICAgICAgWydjbGFzcycsICdmaWx0ZXJDbGFzc0xpc3QnXSxcbiAgICAgICAgICAgIFsnc3R5bGUnLCAnZmlsdGVyU3R5bGVzJ10sXG4gICAgICAgICAgICBbJ2lkJywgJ2ZpbHRlcklEJ10sXG4gICAgICAgICAgICBbJ2ZvbnRzaXplJywgJ2ZpbHRlckZvbnRTaXplJ10sXG4gICAgICAgICAgICBbJ21hdGhzaXplJywgJ2ZpbHRlckZvbnRTaXplJ10sXG4gICAgICAgICAgICBbJ3NjcmlwdG1pbnNpemUnLCAnZmlsdGVyRm9udFNpemUnXSxcbiAgICAgICAgICAgIFsnc2NyaXB0c2l6ZW11bHRpcGxpZXInLCAnZmlsdGVyU2l6ZU11bHRpcGxpZXInXSxcbiAgICAgICAgICAgIFsnc2NyaXB0bGV2ZWwnLCAnZmlsdGVyU2NyaXB0TGV2ZWwnXSxcbiAgICAgICAgICAgIFsnZGF0YS0nLCAnZmlsdGVyRGF0YSddXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmZpbHRlck1ldGhvZHMgPSBfX2Fzc2lnbih7fSwgU2FmZU1ldGhvZHNfanNfMS5TYWZlTWV0aG9kcyk7XG4gICAgICAgIHRoaXMuYWRhcHRvciA9IGRvY3VtZW50LmFkYXB0b3I7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYWxsb3cgPSB0aGlzLm9wdGlvbnMuYWxsb3c7XG4gICAgfVxuICAgIFNhZmUucHJvdG90eXBlLnNhbml0aXplID0gZnVuY3Rpb24gKG1hdGgsIGRvY3VtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtYXRoLnJvb3Qud2Fsa1RyZWUodGhpcy5zYW5pdGl6ZU5vZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZG9jdW1lbnQub3B0aW9ucy5jb21waWxlRXJyb3IoZG9jdW1lbnQsIG1hdGgsIGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmUucHJvdG90eXBlLnNhbml0aXplTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcy5nZXRBbGxBdHRyaWJ1dGVzKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLmZpbHRlckF0dHJpYnV0ZXMuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZmlsdGVyTWV0aG9kc1ttZXRob2RdKHRoaXMsIGF0dHJpYnV0ZXNbaWRdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gcGFyc2VGbG9hdChhdHRyaWJ1dGVzW2lkXSkgOiBhdHRyaWJ1dGVzW2lkXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2lkXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNbaWRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmUucHJvdG90eXBlLm1tbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChpZCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlkID09PSAnY2xhc3MnKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBtZXRob2QgPSB0aGlzLmZpbHRlckF0dHJpYnV0ZXMuZ2V0KGlkKTtcbiAgICAgICAgdmFyIGZpbHRlciA9IChtZXRob2QgfHwgKGlkLnN1YnN0cigwLCA1KSA9PT0gJ2RhdGEtJyA/IHRoaXMuZmlsdGVyQXR0cmlidXRlcy5nZXQoJ2RhdGEtJykgOiBudWxsKSk7XG4gICAgICAgIGlmICghZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZmlsdGVyTWV0aG9kc1tmaWx0ZXJdKHRoaXMsIHZhbHVlLCBpZCk7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHJlc3VsdCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHJlc3VsdCA9PT0gJ2Jvb2xlYW4nID8gU3RyaW5nKHJlc3VsdCkgOiByZXN1bHQpO1xuICAgIH07XG4gICAgU2FmZS5wcm90b3R5cGUubW1sQ2xhc3NMaXN0ID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGxpc3QubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5maWx0ZXJNZXRob2RzLmZpbHRlckNsYXNzKF90aGlzLCBuYW1lKTsgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSAhPT0gbnVsbDsgfSk7XG4gICAgfTtcbiAgICBTYWZlLk9QVElPTlMgPSB7XG4gICAgICAgIGFsbG93OiB7XG4gICAgICAgICAgICBVUkxzOiAnc2FmZScsXG4gICAgICAgICAgICBjbGFzc2VzOiAnc2FmZScsXG4gICAgICAgICAgICBjc3NJRHM6ICdzYWZlJyxcbiAgICAgICAgICAgIHN0eWxlczogJ3NhZmUnXG4gICAgICAgIH0sXG4gICAgICAgIGxlbmd0aE1heDogMyxcbiAgICAgICAgc2NyaXB0c2l6ZW11bHRpcGxpZXJSYW5nZTogWy42LCAxXSxcbiAgICAgICAgc2NyaXB0bGV2ZWxSYW5nZTogWy0yLCAyXSxcbiAgICAgICAgY2xhc3NQYXR0ZXJuOiAvXm1qeC1bLWEtekEtWjAtOV8uXSskLyxcbiAgICAgICAgaWRQYXR0ZXJuOiAvXm1qeC1bLWEtekEtWjAtOV8uXSskLyxcbiAgICAgICAgZGF0YVBhdHRlcm46IC9eZGF0YS1tangtLyxcbiAgICAgICAgc2FmZVByb3RvY29sczogKDAsIE9wdGlvbnNfanNfMS5leHBhbmRhYmxlKSh7XG4gICAgICAgICAgICBodHRwOiB0cnVlLFxuICAgICAgICAgICAgaHR0cHM6IHRydWUsXG4gICAgICAgICAgICBmaWxlOiB0cnVlLFxuICAgICAgICAgICAgamF2YXNjcmlwdDogZmFsc2UsXG4gICAgICAgICAgICBkYXRhOiBmYWxzZVxuICAgICAgICB9KSxcbiAgICAgICAgc2FmZVN0eWxlczogKDAsIE9wdGlvbnNfanNfMS5leHBhbmRhYmxlKSh7XG4gICAgICAgICAgICBjb2xvcjogdHJ1ZSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdHJ1ZSxcbiAgICAgICAgICAgIGJvcmRlcjogdHJ1ZSxcbiAgICAgICAgICAgIGN1cnNvcjogdHJ1ZSxcbiAgICAgICAgICAgIG1hcmdpbjogdHJ1ZSxcbiAgICAgICAgICAgIHBhZGRpbmc6IHRydWUsXG4gICAgICAgICAgICB0ZXh0U2hhZG93OiB0cnVlLFxuICAgICAgICAgICAgZm9udEZhbWlseTogdHJ1ZSxcbiAgICAgICAgICAgIGZvbnRTaXplOiB0cnVlLFxuICAgICAgICAgICAgZm9udFN0eWxlOiB0cnVlLFxuICAgICAgICAgICAgZm9udFdlaWdodDogdHJ1ZSxcbiAgICAgICAgICAgIG9wYWNpdHk6IHRydWUsXG4gICAgICAgICAgICBvdXRsaW5lOiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICBzdHlsZVBhcnRzOiAoMCwgT3B0aW9uc19qc18xLmV4cGFuZGFibGUpKHtcbiAgICAgICAgICAgIGJvcmRlcjogdHJ1ZSxcbiAgICAgICAgICAgIHBhZGRpbmc6IHRydWUsXG4gICAgICAgICAgICBtYXJnaW46IHRydWUsXG4gICAgICAgICAgICBvdXRsaW5lOiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICBzdHlsZUxlbmd0aHM6ICgwLCBPcHRpb25zX2pzXzEuZXhwYW5kYWJsZSkoe1xuICAgICAgICAgICAgYm9yZGVyVG9wOiAnYm9yZGVyVG9wV2lkdGgnLFxuICAgICAgICAgICAgYm9yZGVyUmlnaHQ6ICdib3JkZXJSaWdodFdpZHRoJyxcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbTogJ2JvcmRlckJvdHRvbVdpZHRoJyxcbiAgICAgICAgICAgIGJvcmRlckxlZnQ6ICdib3JkZXJMZWZ0V2lkdGgnLFxuICAgICAgICAgICAgcGFkZGluZ1RvcDogdHJ1ZSxcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodDogdHJ1ZSxcbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IHRydWUsXG4gICAgICAgICAgICBwYWRkaW5nTGVmdDogdHJ1ZSxcbiAgICAgICAgICAgIG1hcmdpblRvcDogdHJ1ZSxcbiAgICAgICAgICAgIG1hcmdpblJpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgbWFyZ2luQm90dG9tOiB0cnVlLFxuICAgICAgICAgICAgbWFyZ2luTGVmdDogdHJ1ZSxcbiAgICAgICAgICAgIG91dGxpbmVUb3A6IHRydWUsXG4gICAgICAgICAgICBvdXRsaW5lUmlnaHQ6IHRydWUsXG4gICAgICAgICAgICBvdXRsaW5lQm90dG9tOiB0cnVlLFxuICAgICAgICAgICAgb3V0bGluZUxlZnQ6IHRydWUsXG4gICAgICAgICAgICBmb250U2l6ZTogWy43MDcsIDEuNDRdXG4gICAgICAgIH0pXG4gICAgfTtcbiAgICByZXR1cm4gU2FmZTtcbn0oKSk7XG5leHBvcnRzLlNhZmUgPSBTYWZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FmZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mathjax-full/js/ui/safe/safe.js\n"));

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/Options.js":
/*!******************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/Options.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.lookup = exports.separateOptions = exports.selectOptionsFromKeys = exports.selectOptions = exports.userOptions = exports.defaultOptions = exports.insert = exports.copy = exports.keys = exports.makeArray = exports.expandable = exports.Expandable = exports.OPTIONS = exports.REMOVE = exports.APPEND = exports.isObject = void 0;\nvar OBJECT = {}.constructor;\nfunction isObject(obj) {\n    return typeof obj === 'object' && obj !== null &&\n        (obj.constructor === OBJECT || obj.constructor === Expandable);\n}\nexports.isObject = isObject;\nexports.APPEND = '[+]';\nexports.REMOVE = '[-]';\nexports.OPTIONS = {\n    invalidOption: 'warn',\n    optionError: function (message, _key) {\n        if (exports.OPTIONS.invalidOption === 'fatal') {\n            throw new Error(message);\n        }\n        console.warn('MathJax: ' + message);\n    }\n};\nvar Expandable = (function () {\n    function Expandable() {\n    }\n    return Expandable;\n}());\nexports.Expandable = Expandable;\nfunction expandable(def) {\n    return Object.assign(Object.create(Expandable.prototype), def);\n}\nexports.expandable = expandable;\nfunction makeArray(x) {\n    return Array.isArray(x) ? x : [x];\n}\nexports.makeArray = makeArray;\nfunction keys(def) {\n    if (!def) {\n        return [];\n    }\n    return Object.keys(def).concat(Object.getOwnPropertySymbols(def));\n}\nexports.keys = keys;\nfunction copy(def) {\n    var e_1, _a;\n    var props = {};\n    try {\n        for (var _b = __values(keys(def)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var key = _c.value;\n            var prop = Object.getOwnPropertyDescriptor(def, key);\n            var value = prop.value;\n            if (Array.isArray(value)) {\n                prop.value = insert([], value, false);\n            }\n            else if (isObject(value)) {\n                prop.value = copy(value);\n            }\n            if (prop.enumerable) {\n                props[key] = prop;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return Object.defineProperties(def.constructor === Expandable ? expandable({}) : {}, props);\n}\nexports.copy = copy;\nfunction insert(dst, src, warn) {\n    var e_2, _a;\n    if (warn === void 0) { warn = true; }\n    var _loop_1 = function (key) {\n        if (warn && dst[key] === undefined && dst.constructor !== Expandable) {\n            if (typeof key === 'symbol') {\n                key = key.toString();\n            }\n            exports.OPTIONS.optionError(\"Invalid option \\\"\".concat(key, \"\\\" (no default value).\"), key);\n            return \"continue\";\n        }\n        var sval = src[key], dval = dst[key];\n        if (isObject(sval) && dval !== null &&\n            (typeof dval === 'object' || typeof dval === 'function')) {\n            var ids = keys(sval);\n            if (Array.isArray(dval) &&\n                ((ids.length === 1 && (ids[0] === exports.APPEND || ids[0] === exports.REMOVE) && Array.isArray(sval[ids[0]])) ||\n                    (ids.length === 2 && ids.sort().join(',') === exports.APPEND + ',' + exports.REMOVE &&\n                        Array.isArray(sval[exports.APPEND]) && Array.isArray(sval[exports.REMOVE])))) {\n                if (sval[exports.REMOVE]) {\n                    dval = dst[key] = dval.filter(function (x) { return sval[exports.REMOVE].indexOf(x) < 0; });\n                }\n                if (sval[exports.APPEND]) {\n                    dst[key] = __spreadArray(__spreadArray([], __read(dval), false), __read(sval[exports.APPEND]), false);\n                }\n            }\n            else {\n                insert(dval, sval, warn);\n            }\n        }\n        else if (Array.isArray(sval)) {\n            dst[key] = [];\n            insert(dst[key], sval, false);\n        }\n        else if (isObject(sval)) {\n            dst[key] = copy(sval);\n        }\n        else {\n            dst[key] = sval;\n        }\n    };\n    try {\n        for (var _b = __values(keys(src)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var key = _c.value;\n            _loop_1(key);\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return dst;\n}\nexports.insert = insert;\nfunction defaultOptions(options) {\n    var defs = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        defs[_i - 1] = arguments[_i];\n    }\n    defs.forEach(function (def) { return insert(options, def, false); });\n    return options;\n}\nexports.defaultOptions = defaultOptions;\nfunction userOptions(options) {\n    var defs = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        defs[_i - 1] = arguments[_i];\n    }\n    defs.forEach(function (def) { return insert(options, def, true); });\n    return options;\n}\nexports.userOptions = userOptions;\nfunction selectOptions(options) {\n    var e_3, _a;\n    var keys = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        keys[_i - 1] = arguments[_i];\n    }\n    var subset = {};\n    try {\n        for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n            var key = keys_1_1.value;\n            if (options.hasOwnProperty(key)) {\n                subset[key] = options[key];\n            }\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    return subset;\n}\nexports.selectOptions = selectOptions;\nfunction selectOptionsFromKeys(options, object) {\n    return selectOptions.apply(void 0, __spreadArray([options], __read(Object.keys(object)), false));\n}\nexports.selectOptionsFromKeys = selectOptionsFromKeys;\nfunction separateOptions(options) {\n    var e_4, _a, e_5, _b;\n    var objects = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        objects[_i - 1] = arguments[_i];\n    }\n    var results = [];\n    try {\n        for (var objects_1 = __values(objects), objects_1_1 = objects_1.next(); !objects_1_1.done; objects_1_1 = objects_1.next()) {\n            var object = objects_1_1.value;\n            var exists = {}, missing = {};\n            try {\n                for (var _c = (e_5 = void 0, __values(Object.keys(options || {}))), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var key = _d.value;\n                    (object[key] === undefined ? missing : exists)[key] = options[key];\n                }\n            }\n            catch (e_5_1) { e_5 = { error: e_5_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n                }\n                finally { if (e_5) throw e_5.error; }\n            }\n            results.push(exists);\n            options = missing;\n        }\n    }\n    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n    finally {\n        try {\n            if (objects_1_1 && !objects_1_1.done && (_a = objects_1.return)) _a.call(objects_1);\n        }\n        finally { if (e_4) throw e_4.error; }\n    }\n    results.unshift(options);\n    return results;\n}\nexports.separateOptions = separateOptions;\nfunction lookup(name, lookup, def) {\n    if (def === void 0) { def = null; }\n    return (lookup.hasOwnProperty(name) ? lookup[name] : def);\n}\nexports.lookup = lookup;\n//# sourceMappingURL=Options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL3V0aWwvT3B0aW9ucy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsdUJBQXVCLEdBQUcsNkJBQTZCLEdBQUcscUJBQXFCLEdBQUcsbUJBQW1CLEdBQUcsc0JBQXNCLEdBQUcsY0FBYyxHQUFHLFlBQVksR0FBRyxZQUFZLEdBQUcsaUJBQWlCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsZ0JBQWdCO0FBQ25VLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsY0FBYztBQUNkLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFVBQVU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsaUZBQWlGLE1BQU07QUFDdkY7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDZDQUE2QztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsVUFBVTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0Esa0NBQWtDLHFDQUFxQztBQUN2RTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DO0FBQ3RFO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxnQkFBZ0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLG1CQUFtQjtBQUNuRztBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLCtFQUErRSxxQkFBcUIsVUFBVTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvdXRpbC9PcHRpb25zLmpzPzkzYzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmxvb2t1cCA9IGV4cG9ydHMuc2VwYXJhdGVPcHRpb25zID0gZXhwb3J0cy5zZWxlY3RPcHRpb25zRnJvbUtleXMgPSBleHBvcnRzLnNlbGVjdE9wdGlvbnMgPSBleHBvcnRzLnVzZXJPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuaW5zZXJ0ID0gZXhwb3J0cy5jb3B5ID0gZXhwb3J0cy5rZXlzID0gZXhwb3J0cy5tYWtlQXJyYXkgPSBleHBvcnRzLmV4cGFuZGFibGUgPSBleHBvcnRzLkV4cGFuZGFibGUgPSBleHBvcnRzLk9QVElPTlMgPSBleHBvcnRzLlJFTU9WRSA9IGV4cG9ydHMuQVBQRU5EID0gZXhwb3J0cy5pc09iamVjdCA9IHZvaWQgMDtcbnZhciBPQkpFQ1QgPSB7fS5jb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwgJiZcbiAgICAgICAgKG9iai5jb25zdHJ1Y3RvciA9PT0gT0JKRUNUIHx8IG9iai5jb25zdHJ1Y3RvciA9PT0gRXhwYW5kYWJsZSk7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5leHBvcnRzLkFQUEVORCA9ICdbK10nO1xuZXhwb3J0cy5SRU1PVkUgPSAnWy1dJztcbmV4cG9ydHMuT1BUSU9OUyA9IHtcbiAgICBpbnZhbGlkT3B0aW9uOiAnd2FybicsXG4gICAgb3B0aW9uRXJyb3I6IGZ1bmN0aW9uIChtZXNzYWdlLCBfa2V5KSB7XG4gICAgICAgIGlmIChleHBvcnRzLk9QVElPTlMuaW52YWxpZE9wdGlvbiA9PT0gJ2ZhdGFsJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybignTWF0aEpheDogJyArIG1lc3NhZ2UpO1xuICAgIH1cbn07XG52YXIgRXhwYW5kYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhwYW5kYWJsZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIEV4cGFuZGFibGU7XG59KCkpO1xuZXhwb3J0cy5FeHBhbmRhYmxlID0gRXhwYW5kYWJsZTtcbmZ1bmN0aW9uIGV4cGFuZGFibGUoZGVmKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShFeHBhbmRhYmxlLnByb3RvdHlwZSksIGRlZik7XG59XG5leHBvcnRzLmV4cGFuZGFibGUgPSBleHBhbmRhYmxlO1xuZnVuY3Rpb24gbWFrZUFycmF5KHgpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh4KSA/IHggOiBbeF07XG59XG5leHBvcnRzLm1ha2VBcnJheSA9IG1ha2VBcnJheTtcbmZ1bmN0aW9uIGtleXMoZGVmKSB7XG4gICAgaWYgKCFkZWYpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZGVmKS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhkZWYpKTtcbn1cbmV4cG9ydHMua2V5cyA9IGtleXM7XG5mdW5jdGlvbiBjb3B5KGRlZikge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoa2V5cyhkZWYpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHByb3AgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRlZiwga2V5KTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBwcm9wLnZhbHVlID0gaW5zZXJ0KFtdLCB2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcHJvcC52YWx1ZSA9IGNvcHkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AuZW51bWVyYWJsZSkge1xuICAgICAgICAgICAgICAgIHByb3BzW2tleV0gPSBwcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZGVmLmNvbnN0cnVjdG9yID09PSBFeHBhbmRhYmxlID8gZXhwYW5kYWJsZSh7fSkgOiB7fSwgcHJvcHMpO1xufVxuZXhwb3J0cy5jb3B5ID0gY29weTtcbmZ1bmN0aW9uIGluc2VydChkc3QsIHNyYywgd2Fybikge1xuICAgIHZhciBlXzIsIF9hO1xuICAgIGlmICh3YXJuID09PSB2b2lkIDApIHsgd2FybiA9IHRydWU7IH1cbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKHdhcm4gJiYgZHN0W2tleV0gPT09IHVuZGVmaW5lZCAmJiBkc3QuY29uc3RydWN0b3IgIT09IEV4cGFuZGFibGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIGtleSA9IGtleS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwb3J0cy5PUFRJT05TLm9wdGlvbkVycm9yKFwiSW52YWxpZCBvcHRpb24gXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiAobm8gZGVmYXVsdCB2YWx1ZSkuXCIpLCBrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ZhbCA9IHNyY1trZXldLCBkdmFsID0gZHN0W2tleV07XG4gICAgICAgIGlmIChpc09iamVjdChzdmFsKSAmJiBkdmFsICE9PSBudWxsICYmXG4gICAgICAgICAgICAodHlwZW9mIGR2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBkdmFsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgdmFyIGlkcyA9IGtleXMoc3ZhbCk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkdmFsKSAmJlxuICAgICAgICAgICAgICAgICgoaWRzLmxlbmd0aCA9PT0gMSAmJiAoaWRzWzBdID09PSBleHBvcnRzLkFQUEVORCB8fCBpZHNbMF0gPT09IGV4cG9ydHMuUkVNT1ZFKSAmJiBBcnJheS5pc0FycmF5KHN2YWxbaWRzWzBdXSkpIHx8XG4gICAgICAgICAgICAgICAgICAgIChpZHMubGVuZ3RoID09PSAyICYmIGlkcy5zb3J0KCkuam9pbignLCcpID09PSBleHBvcnRzLkFQUEVORCArICcsJyArIGV4cG9ydHMuUkVNT1ZFICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KHN2YWxbZXhwb3J0cy5BUFBFTkRdKSAmJiBBcnJheS5pc0FycmF5KHN2YWxbZXhwb3J0cy5SRU1PVkVdKSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN2YWxbZXhwb3J0cy5SRU1PVkVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGR2YWwgPSBkc3Rba2V5XSA9IGR2YWwuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiBzdmFsW2V4cG9ydHMuUkVNT1ZFXS5pbmRleE9mKHgpIDwgMDsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdmFsW2V4cG9ydHMuQVBQRU5EXSkge1xuICAgICAgICAgICAgICAgICAgICBkc3Rba2V5XSA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGR2YWwpLCBmYWxzZSksIF9fcmVhZChzdmFsW2V4cG9ydHMuQVBQRU5EXSksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnNlcnQoZHZhbCwgc3ZhbCwgd2Fybik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzdmFsKSkge1xuICAgICAgICAgICAgZHN0W2tleV0gPSBbXTtcbiAgICAgICAgICAgIGluc2VydChkc3Rba2V5XSwgc3ZhbCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHN2YWwpKSB7XG4gICAgICAgICAgICBkc3Rba2V5XSA9IGNvcHkoc3ZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkc3Rba2V5XSA9IHN2YWw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoa2V5cyhzcmMpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgX2xvb3BfMShrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gZHN0O1xufVxuZXhwb3J0cy5pbnNlcnQgPSBpbnNlcnQ7XG5mdW5jdGlvbiBkZWZhdWx0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIGRlZnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBkZWZzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBkZWZzLmZvckVhY2goZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gaW5zZXJ0KG9wdGlvbnMsIGRlZiwgZmFsc2UpOyB9KTtcbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbmZ1bmN0aW9uIHVzZXJPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgZGVmcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGRlZnNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGRlZnMuZm9yRWFjaChmdW5jdGlvbiAoZGVmKSB7IHJldHVybiBpbnNlcnQob3B0aW9ucywgZGVmLCB0cnVlKTsgfSk7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5leHBvcnRzLnVzZXJPcHRpb25zID0gdXNlck9wdGlvbnM7XG5mdW5jdGlvbiBzZWxlY3RPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgZV8zLCBfYTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGtleXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBzdWJzZXQgPSB7fTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBrZXlzXzEgPSBfX3ZhbHVlcyhrZXlzKSwga2V5c18xXzEgPSBrZXlzXzEubmV4dCgpOyAha2V5c18xXzEuZG9uZTsga2V5c18xXzEgPSBrZXlzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c18xXzEudmFsdWU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgc3Vic2V0W2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChrZXlzXzFfMSAmJiAha2V5c18xXzEuZG9uZSAmJiAoX2EgPSBrZXlzXzEucmV0dXJuKSkgX2EuY2FsbChrZXlzXzEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIHN1YnNldDtcbn1cbmV4cG9ydHMuc2VsZWN0T3B0aW9ucyA9IHNlbGVjdE9wdGlvbnM7XG5mdW5jdGlvbiBzZWxlY3RPcHRpb25zRnJvbUtleXMob3B0aW9ucywgb2JqZWN0KSB7XG4gICAgcmV0dXJuIHNlbGVjdE9wdGlvbnMuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtvcHRpb25zXSwgX19yZWFkKE9iamVjdC5rZXlzKG9iamVjdCkpLCBmYWxzZSkpO1xufVxuZXhwb3J0cy5zZWxlY3RPcHRpb25zRnJvbUtleXMgPSBzZWxlY3RPcHRpb25zRnJvbUtleXM7XG5mdW5jdGlvbiBzZXBhcmF0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBlXzQsIF9hLCBlXzUsIF9iO1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JqZWN0c1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBvYmplY3RzXzEgPSBfX3ZhbHVlcyhvYmplY3RzKSwgb2JqZWN0c18xXzEgPSBvYmplY3RzXzEubmV4dCgpOyAhb2JqZWN0c18xXzEuZG9uZTsgb2JqZWN0c18xXzEgPSBvYmplY3RzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gb2JqZWN0c18xXzEudmFsdWU7XG4gICAgICAgICAgICB2YXIgZXhpc3RzID0ge30sIG1pc3NpbmcgPSB7fTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSAoZV81ID0gdm9pZCAwLCBfX3ZhbHVlcyhPYmplY3Qua2V5cyhvcHRpb25zIHx8IHt9KSkpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgKG9iamVjdFtrZXldID09PSB1bmRlZmluZWQgPyBtaXNzaW5nIDogZXhpc3RzKVtrZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzVfMSkgeyBlXzUgPSB7IGVycm9yOiBlXzVfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9iID0gX2MucmV0dXJuKSkgX2IuY2FsbChfYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV81KSB0aHJvdyBlXzUuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChleGlzdHMpO1xuICAgICAgICAgICAgb3B0aW9ucyA9IG1pc3Npbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChvYmplY3RzXzFfMSAmJiAhb2JqZWN0c18xXzEuZG9uZSAmJiAoX2EgPSBvYmplY3RzXzEucmV0dXJuKSkgX2EuY2FsbChvYmplY3RzXzEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7IH1cbiAgICB9XG4gICAgcmVzdWx0cy51bnNoaWZ0KG9wdGlvbnMpO1xuICAgIHJldHVybiByZXN1bHRzO1xufVxuZXhwb3J0cy5zZXBhcmF0ZU9wdGlvbnMgPSBzZXBhcmF0ZU9wdGlvbnM7XG5mdW5jdGlvbiBsb29rdXAobmFtZSwgbG9va3VwLCBkZWYpIHtcbiAgICBpZiAoZGVmID09PSB2b2lkIDApIHsgZGVmID0gbnVsbDsgfVxuICAgIHJldHVybiAobG9va3VwLmhhc093blByb3BlcnR5KG5hbWUpID8gbG9va3VwW25hbWVdIDogZGVmKTtcbn1cbmV4cG9ydHMubG9va3VwID0gbG9va3VwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3B0aW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mathjax-full/js/util/Options.js\n"));

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/lengths.js":
/*!******************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/lengths.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.px = exports.emRounded = exports.em = exports.percent = exports.length2em = exports.MATHSPACE = exports.RELUNITS = exports.UNITS = exports.BIGDIMEN = void 0;\nexports.BIGDIMEN = 1000000;\nexports.UNITS = {\n    px: 1,\n    'in': 96,\n    cm: 96 / 2.54,\n    mm: 96 / 25.4\n};\nexports.RELUNITS = {\n    em: 1,\n    ex: .431,\n    pt: 1 / 10,\n    pc: 12 / 10,\n    mu: 1 / 18\n};\nexports.MATHSPACE = {\n    veryverythinmathspace: 1 / 18,\n    verythinmathspace: 2 / 18,\n    thinmathspace: 3 / 18,\n    mediummathspace: 4 / 18,\n    thickmathspace: 5 / 18,\n    verythickmathspace: 6 / 18,\n    veryverythickmathspace: 7 / 18,\n    negativeveryverythinmathspace: -1 / 18,\n    negativeverythinmathspace: -2 / 18,\n    negativethinmathspace: -3 / 18,\n    negativemediummathspace: -4 / 18,\n    negativethickmathspace: -5 / 18,\n    negativeverythickmathspace: -6 / 18,\n    negativeveryverythickmathspace: -7 / 18,\n    thin: .04,\n    medium: .06,\n    thick: .1,\n    normal: 1,\n    big: 2,\n    small: 1 / Math.sqrt(2),\n    infinity: exports.BIGDIMEN\n};\nfunction length2em(length, size, scale, em) {\n    if (size === void 0) { size = 0; }\n    if (scale === void 0) { scale = 1; }\n    if (em === void 0) { em = 16; }\n    if (typeof length !== 'string') {\n        length = String(length);\n    }\n    if (length === '' || length == null) {\n        return size;\n    }\n    if (exports.MATHSPACE[length]) {\n        return exports.MATHSPACE[length];\n    }\n    var match = length.match(/^\\s*([-+]?(?:\\.\\d+|\\d+(?:\\.\\d*)?))?(pt|em|ex|mu|px|pc|in|mm|cm|%)?/);\n    if (!match) {\n        return size;\n    }\n    var m = parseFloat(match[1] || '1'), unit = match[2];\n    if (exports.UNITS.hasOwnProperty(unit)) {\n        return m * exports.UNITS[unit] / em / scale;\n    }\n    if (exports.RELUNITS.hasOwnProperty(unit)) {\n        return m * exports.RELUNITS[unit];\n    }\n    if (unit === '%') {\n        return m / 100 * size;\n    }\n    return m * size;\n}\nexports.length2em = length2em;\nfunction percent(m) {\n    return (100 * m).toFixed(1).replace(/\\.?0+$/, '') + '%';\n}\nexports.percent = percent;\nfunction em(m) {\n    if (Math.abs(m) < .001)\n        return '0';\n    return (m.toFixed(3).replace(/\\.?0+$/, '')) + 'em';\n}\nexports.em = em;\nfunction emRounded(m, em) {\n    if (em === void 0) { em = 16; }\n    m = (Math.round(m * em) + .05) / em;\n    if (Math.abs(m) < .001)\n        return '0em';\n    return m.toFixed(3).replace(/\\.?0+$/, '') + 'em';\n}\nexports.emRounded = emRounded;\nfunction px(m, M, em) {\n    if (M === void 0) { M = -exports.BIGDIMEN; }\n    if (em === void 0) { em = 16; }\n    m *= em;\n    if (M && m < M)\n        m = M;\n    if (Math.abs(m) < .1)\n        return '0';\n    return m.toFixed(1).replace(/\\.0$/, '') + 'px';\n}\nexports.px = px;\n//# sourceMappingURL=lengths.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL3V0aWwvbGVuZ3Rocy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxVQUFVLEdBQUcsaUJBQWlCLEdBQUcsVUFBVSxHQUFHLGVBQWUsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxnQkFBZ0IsR0FBRyxhQUFhLEdBQUcsZ0JBQWdCO0FBQzNKLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSx3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvdXRpbC9sZW5ndGhzLmpzP2Y2ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnB4ID0gZXhwb3J0cy5lbVJvdW5kZWQgPSBleHBvcnRzLmVtID0gZXhwb3J0cy5wZXJjZW50ID0gZXhwb3J0cy5sZW5ndGgyZW0gPSBleHBvcnRzLk1BVEhTUEFDRSA9IGV4cG9ydHMuUkVMVU5JVFMgPSBleHBvcnRzLlVOSVRTID0gZXhwb3J0cy5CSUdESU1FTiA9IHZvaWQgMDtcbmV4cG9ydHMuQklHRElNRU4gPSAxMDAwMDAwO1xuZXhwb3J0cy5VTklUUyA9IHtcbiAgICBweDogMSxcbiAgICAnaW4nOiA5NixcbiAgICBjbTogOTYgLyAyLjU0LFxuICAgIG1tOiA5NiAvIDI1LjRcbn07XG5leHBvcnRzLlJFTFVOSVRTID0ge1xuICAgIGVtOiAxLFxuICAgIGV4OiAuNDMxLFxuICAgIHB0OiAxIC8gMTAsXG4gICAgcGM6IDEyIC8gMTAsXG4gICAgbXU6IDEgLyAxOFxufTtcbmV4cG9ydHMuTUFUSFNQQUNFID0ge1xuICAgIHZlcnl2ZXJ5dGhpbm1hdGhzcGFjZTogMSAvIDE4LFxuICAgIHZlcnl0aGlubWF0aHNwYWNlOiAyIC8gMTgsXG4gICAgdGhpbm1hdGhzcGFjZTogMyAvIDE4LFxuICAgIG1lZGl1bW1hdGhzcGFjZTogNCAvIDE4LFxuICAgIHRoaWNrbWF0aHNwYWNlOiA1IC8gMTgsXG4gICAgdmVyeXRoaWNrbWF0aHNwYWNlOiA2IC8gMTgsXG4gICAgdmVyeXZlcnl0aGlja21hdGhzcGFjZTogNyAvIDE4LFxuICAgIG5lZ2F0aXZldmVyeXZlcnl0aGlubWF0aHNwYWNlOiAtMSAvIDE4LFxuICAgIG5lZ2F0aXZldmVyeXRoaW5tYXRoc3BhY2U6IC0yIC8gMTgsXG4gICAgbmVnYXRpdmV0aGlubWF0aHNwYWNlOiAtMyAvIDE4LFxuICAgIG5lZ2F0aXZlbWVkaXVtbWF0aHNwYWNlOiAtNCAvIDE4LFxuICAgIG5lZ2F0aXZldGhpY2ttYXRoc3BhY2U6IC01IC8gMTgsXG4gICAgbmVnYXRpdmV2ZXJ5dGhpY2ttYXRoc3BhY2U6IC02IC8gMTgsXG4gICAgbmVnYXRpdmV2ZXJ5dmVyeXRoaWNrbWF0aHNwYWNlOiAtNyAvIDE4LFxuICAgIHRoaW46IC4wNCxcbiAgICBtZWRpdW06IC4wNixcbiAgICB0aGljazogLjEsXG4gICAgbm9ybWFsOiAxLFxuICAgIGJpZzogMixcbiAgICBzbWFsbDogMSAvIE1hdGguc3FydCgyKSxcbiAgICBpbmZpbml0eTogZXhwb3J0cy5CSUdESU1FTlxufTtcbmZ1bmN0aW9uIGxlbmd0aDJlbShsZW5ndGgsIHNpemUsIHNjYWxlLCBlbSkge1xuICAgIGlmIChzaXplID09PSB2b2lkIDApIHsgc2l6ZSA9IDA7IH1cbiAgICBpZiAoc2NhbGUgPT09IHZvaWQgMCkgeyBzY2FsZSA9IDE7IH1cbiAgICBpZiAoZW0gPT09IHZvaWQgMCkgeyBlbSA9IDE2OyB9XG4gICAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxlbmd0aCA9IFN0cmluZyhsZW5ndGgpO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoID09PSAnJyB8fCBsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgaWYgKGV4cG9ydHMuTUFUSFNQQUNFW2xlbmd0aF0pIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuTUFUSFNQQUNFW2xlbmd0aF07XG4gICAgfVxuICAgIHZhciBtYXRjaCA9IGxlbmd0aC5tYXRjaCgvXlxccyooWy0rXT8oPzpcXC5cXGQrfFxcZCsoPzpcXC5cXGQqKT8pKT8ocHR8ZW18ZXh8bXV8cHh8cGN8aW58bW18Y218JSk/Lyk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgdmFyIG0gPSBwYXJzZUZsb2F0KG1hdGNoWzFdIHx8ICcxJyksIHVuaXQgPSBtYXRjaFsyXTtcbiAgICBpZiAoZXhwb3J0cy5VTklUUy5oYXNPd25Qcm9wZXJ0eSh1bml0KSkge1xuICAgICAgICByZXR1cm4gbSAqIGV4cG9ydHMuVU5JVFNbdW5pdF0gLyBlbSAvIHNjYWxlO1xuICAgIH1cbiAgICBpZiAoZXhwb3J0cy5SRUxVTklUUy5oYXNPd25Qcm9wZXJ0eSh1bml0KSkge1xuICAgICAgICByZXR1cm4gbSAqIGV4cG9ydHMuUkVMVU5JVFNbdW5pdF07XG4gICAgfVxuICAgIGlmICh1bml0ID09PSAnJScpIHtcbiAgICAgICAgcmV0dXJuIG0gLyAxMDAgKiBzaXplO1xuICAgIH1cbiAgICByZXR1cm4gbSAqIHNpemU7XG59XG5leHBvcnRzLmxlbmd0aDJlbSA9IGxlbmd0aDJlbTtcbmZ1bmN0aW9uIHBlcmNlbnQobSkge1xuICAgIHJldHVybiAoMTAwICogbSkudG9GaXhlZCgxKS5yZXBsYWNlKC9cXC4/MCskLywgJycpICsgJyUnO1xufVxuZXhwb3J0cy5wZXJjZW50ID0gcGVyY2VudDtcbmZ1bmN0aW9uIGVtKG0pIHtcbiAgICBpZiAoTWF0aC5hYnMobSkgPCAuMDAxKVxuICAgICAgICByZXR1cm4gJzAnO1xuICAgIHJldHVybiAobS50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykpICsgJ2VtJztcbn1cbmV4cG9ydHMuZW0gPSBlbTtcbmZ1bmN0aW9uIGVtUm91bmRlZChtLCBlbSkge1xuICAgIGlmIChlbSA9PT0gdm9pZCAwKSB7IGVtID0gMTY7IH1cbiAgICBtID0gKE1hdGgucm91bmQobSAqIGVtKSArIC4wNSkgLyBlbTtcbiAgICBpZiAoTWF0aC5hYnMobSkgPCAuMDAxKVxuICAgICAgICByZXR1cm4gJzBlbSc7XG4gICAgcmV0dXJuIG0udG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpICsgJ2VtJztcbn1cbmV4cG9ydHMuZW1Sb3VuZGVkID0gZW1Sb3VuZGVkO1xuZnVuY3Rpb24gcHgobSwgTSwgZW0pIHtcbiAgICBpZiAoTSA9PT0gdm9pZCAwKSB7IE0gPSAtZXhwb3J0cy5CSUdESU1FTjsgfVxuICAgIGlmIChlbSA9PT0gdm9pZCAwKSB7IGVtID0gMTY7IH1cbiAgICBtICo9IGVtO1xuICAgIGlmIChNICYmIG0gPCBNKVxuICAgICAgICBtID0gTTtcbiAgICBpZiAoTWF0aC5hYnMobSkgPCAuMSlcbiAgICAgICAgcmV0dXJuICcwJztcbiAgICByZXR1cm4gbS50b0ZpeGVkKDEpLnJlcGxhY2UoL1xcLjAkLywgJycpICsgJ3B4Jztcbn1cbmV4cG9ydHMucHggPSBweDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlbmd0aHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mathjax-full/js/util/lengths.js\n"));

/***/ })

}]);