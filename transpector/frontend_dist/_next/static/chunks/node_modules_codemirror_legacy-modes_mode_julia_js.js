"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_codemirror_legacy-modes_mode_julia_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/julia.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/julia.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"julia\": function() { return /* binding */ julia; }\n/* harmony export */ });\nfunction wordRegexp(words, end, pre) {\n  if (typeof pre === \"undefined\") pre = \"\";\n  if (typeof end === \"undefined\") { end = \"\\\\b\"; }\n  return new RegExp(\"^\" + pre + \"((\" + words.join(\")|(\") + \"))\" + end);\n}\n\nvar octChar = \"\\\\\\\\[0-7]{1,3}\";\nvar hexChar = \"\\\\\\\\x[A-Fa-f0-9]{1,2}\";\nvar sChar = \"\\\\\\\\[abefnrtv0%?'\\\"\\\\\\\\]\";\nvar uChar = \"([^\\\\u0027\\\\u005C\\\\uD800-\\\\uDFFF]|[\\\\uD800-\\\\uDFFF][\\\\uDC00-\\\\uDFFF])\";\n\nvar asciiOperatorsList = [\n  \"[<>]:\", \"[<>=]=\", \"<<=?\", \">>>?=?\", \"=>\", \"--?>\", \"<--[->]?\", \"\\\\/\\\\/\",\n  \"\\\\.{2,3}\", \"[\\\\.\\\\\\\\%*+\\\\-<>!\\\\/^|&]=?\", \"\\\\?\", \"\\\\$\", \"~\", \":\"\n];\nvar operators = wordRegexp([\n  \"[<>]:\", \"[<>=]=\", \"[!=]==\", \"<<=?\", \">>>?=?\", \"=>?\", \"--?>\", \"<--[->]?\", \"\\\\/\\\\/\",\n  \"[\\\\\\\\%*+\\\\-<>!\\\\/^|&\\\\u00F7\\\\u22BB]=?\", \"\\\\?\", \"\\\\$\", \"~\", \":\",\n  \"\\\\u00D7\", \"\\\\u2208\", \"\\\\u2209\", \"\\\\u220B\", \"\\\\u220C\", \"\\\\u2218\",\n  \"\\\\u221A\", \"\\\\u221B\", \"\\\\u2229\", \"\\\\u222A\", \"\\\\u2260\", \"\\\\u2264\",\n  \"\\\\u2265\", \"\\\\u2286\", \"\\\\u2288\", \"\\\\u228A\", \"\\\\u22C5\",\n  \"\\\\b(in|isa)\\\\b(?!\\.?\\\\()\"\n], \"\");\nvar delimiters = /^[;,()[\\]{}]/;\nvar identifiers = /^[_A-Za-z\\u00A1-\\u2217\\u2219-\\uFFFF][\\w\\u00A1-\\u2217\\u2219-\\uFFFF]*!*/;\n\nvar chars = wordRegexp([octChar, hexChar, sChar, uChar], \"'\");\n\nvar openersList = [\"begin\", \"function\", \"type\", \"struct\", \"immutable\", \"let\",\n                   \"macro\", \"for\", \"while\", \"quote\", \"if\", \"else\", \"elseif\", \"try\",\n                   \"finally\", \"catch\", \"do\"];\n\nvar closersList = [\"end\", \"else\", \"elseif\", \"catch\", \"finally\"];\n\nvar keywordsList = [\"if\", \"else\", \"elseif\", \"while\", \"for\", \"begin\", \"let\",\n                    \"end\", \"do\", \"try\", \"catch\", \"finally\", \"return\", \"break\", \"continue\",\n                    \"global\", \"local\", \"const\", \"export\", \"import\", \"importall\", \"using\",\n                    \"function\", \"where\", \"macro\", \"module\", \"baremodule\", \"struct\", \"type\",\n                    \"mutable\", \"immutable\", \"quote\", \"typealias\", \"abstract\", \"primitive\",\n                    \"bitstype\"];\n\nvar builtinsList = [\"true\", \"false\", \"nothing\", \"NaN\", \"Inf\"];\n\nvar openers = wordRegexp(openersList);\nvar closers = wordRegexp(closersList);\nvar keywords = wordRegexp(keywordsList);\nvar builtins = wordRegexp(builtinsList);\n\nvar macro = /^@[_A-Za-z\\u00A1-\\uFFFF][\\w\\u00A1-\\uFFFF]*!*/;\nvar symbol = /^:[_A-Za-z\\u00A1-\\uFFFF][\\w\\u00A1-\\uFFFF]*!*/;\nvar stringPrefixes = /^(`|([_A-Za-z\\u00A1-\\uFFFF]*\"(\"\")?))/;\n\nvar macroOperators = wordRegexp(asciiOperatorsList, \"\", \"@\");\nvar symbolOperators = wordRegexp(asciiOperatorsList, \"\", \":\");\n\nfunction inArray(state) {\n  return (state.nestedArrays > 0);\n}\n\nfunction inGenerator(state) {\n  return (state.nestedGenerators > 0);\n}\n\nfunction currentScope(state, n) {\n  if (typeof(n) === \"undefined\") { n = 0; }\n  if (state.scopes.length <= n) {\n    return null;\n  }\n  return state.scopes[state.scopes.length - (n + 1)];\n}\n\n// tokenizers\nfunction tokenBase(stream, state) {\n  // Handle multiline comments\n  if (stream.match('#=', false)) {\n    state.tokenize = tokenComment;\n    return state.tokenize(stream, state);\n  }\n\n  // Handle scope changes\n  var leavingExpr = state.leavingExpr;\n  if (stream.sol()) {\n    leavingExpr = false;\n  }\n  state.leavingExpr = false;\n\n  if (leavingExpr) {\n    if (stream.match(/^'+/)) {\n      return \"operator\";\n    }\n  }\n\n  if (stream.match(/\\.{4,}/)) {\n    return \"error\";\n  } else if (stream.match(/\\.{1,3}/)) {\n    return \"operator\";\n  }\n\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  var ch = stream.peek();\n\n  // Handle single line comments\n  if (ch === '#') {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  if (ch === '[') {\n    state.scopes.push('[');\n    state.nestedArrays++;\n  }\n\n  if (ch === '(') {\n    state.scopes.push('(');\n    state.nestedGenerators++;\n  }\n\n  if (inArray(state) && ch === ']') {\n    while (state.scopes.length && currentScope(state) !== \"[\") { state.scopes.pop(); }\n    state.scopes.pop();\n    state.nestedArrays--;\n    state.leavingExpr = true;\n  }\n\n  if (inGenerator(state) && ch === ')') {\n    while (state.scopes.length && currentScope(state) !== \"(\") { state.scopes.pop(); }\n    state.scopes.pop();\n    state.nestedGenerators--;\n    state.leavingExpr = true;\n  }\n\n  if (inArray(state)) {\n    if (state.lastToken == \"end\" && stream.match(':')) {\n      return \"operator\";\n    }\n    if (stream.match('end')) {\n      return \"number\";\n    }\n  }\n\n  var match;\n  if (match = stream.match(openers, false)) {\n    state.scopes.push(match[0]);\n  }\n\n  if (stream.match(closers, false)) {\n    state.scopes.pop();\n  }\n\n  // Handle type annotations\n  if (stream.match(/^::(?![:\\$])/)) {\n    state.tokenize = tokenAnnotation;\n    return state.tokenize(stream, state);\n  }\n\n  // Handle symbols\n  if (!leavingExpr && (stream.match(symbol) || stream.match(symbolOperators))) {\n    return \"builtin\";\n  }\n\n  // Handle parametric types\n  //if (stream.match(/^{[^}]*}(?=\\()/)) {\n  //  return \"builtin\";\n  //}\n\n  // Handle operators and Delimiters\n  if (stream.match(operators)) {\n    return \"operator\";\n  }\n\n  // Handle Number Literals\n  if (stream.match(/^\\.?\\d/, false)) {\n    var imMatcher = RegExp(/^im\\b/);\n    var numberLiteral = false;\n    if (stream.match(/^0x\\.[0-9a-f_]+p[\\+\\-]?[_\\d]+/i)) { numberLiteral = true; }\n    // Integers\n    if (stream.match(/^0x[0-9a-f_]+/i)) { numberLiteral = true; } // Hex\n    if (stream.match(/^0b[01_]+/i)) { numberLiteral = true; } // Binary\n    if (stream.match(/^0o[0-7_]+/i)) { numberLiteral = true; } // Octal\n    // Floats\n    if (stream.match(/^(?:(?:\\d[_\\d]*)?\\.(?!\\.)(?:\\d[_\\d]*)?|\\d[_\\d]*\\.(?!\\.)(?:\\d[_\\d]*))?([Eef][\\+\\-]?[_\\d]+)?/i)) { numberLiteral = true; }\n    if (stream.match(/^\\d[_\\d]*(e[\\+\\-]?\\d+)?/i)) { numberLiteral = true; } // Decimal\n    if (numberLiteral) {\n      // Integer literals may be \"long\"\n      stream.match(imMatcher);\n      state.leavingExpr = true;\n      return \"number\";\n    }\n  }\n\n  // Handle Chars\n  if (stream.match(\"'\")) {\n    state.tokenize = tokenChar;\n    return state.tokenize(stream, state);\n  }\n\n  // Handle Strings\n  if (stream.match(stringPrefixes)) {\n    state.tokenize = tokenStringFactory(stream.current());\n    return state.tokenize(stream, state);\n  }\n\n  if (stream.match(macro) || stream.match(macroOperators)) {\n    return \"meta\";\n  }\n\n  if (stream.match(delimiters)) {\n    return null;\n  }\n\n  if (stream.match(keywords)) {\n    return \"keyword\";\n  }\n\n  if (stream.match(builtins)) {\n    return \"builtin\";\n  }\n\n  var isDefinition = state.isDefinition || state.lastToken == \"function\" ||\n      state.lastToken == \"macro\" || state.lastToken == \"type\" ||\n      state.lastToken == \"struct\" || state.lastToken == \"immutable\";\n\n  if (stream.match(identifiers)) {\n    if (isDefinition) {\n      if (stream.peek() === '.') {\n        state.isDefinition = true;\n        return \"variable\";\n      }\n      state.isDefinition = false;\n      return \"def\";\n    }\n    state.leavingExpr = true;\n    return \"variable\";\n  }\n\n  // Handle non-detected items\n  stream.next();\n  return \"error\";\n}\n\nfunction tokenAnnotation(stream, state) {\n  stream.match(/.*?(?=[,;{}()=\\s]|$)/);\n  if (stream.match('{')) {\n    state.nestedParameters++;\n  } else if (stream.match('}') && state.nestedParameters > 0) {\n    state.nestedParameters--;\n  }\n  if (state.nestedParameters > 0) {\n    stream.match(/.*?(?={|})/) || stream.next();\n  } else if (state.nestedParameters == 0) {\n    state.tokenize = tokenBase;\n  }\n  return \"builtin\";\n}\n\nfunction tokenComment(stream, state) {\n  if (stream.match('#=')) {\n    state.nestedComments++;\n  }\n  if (!stream.match(/.*?(?=(#=|=#))/)) {\n    stream.skipToEnd();\n  }\n  if (stream.match('=#')) {\n    state.nestedComments--;\n    if (state.nestedComments == 0)\n      state.tokenize = tokenBase;\n  }\n  return \"comment\";\n}\n\nfunction tokenChar(stream, state) {\n  var isChar = false, match;\n  if (stream.match(chars)) {\n    isChar = true;\n  } else if (match = stream.match(/\\\\u([a-f0-9]{1,4})(?=')/i)) {\n    var value = parseInt(match[1], 16);\n    if (value <= 55295 || value >= 57344) { // (U+0,U+D7FF), (U+E000,U+FFFF)\n      isChar = true;\n      stream.next();\n    }\n  } else if (match = stream.match(/\\\\U([A-Fa-f0-9]{5,8})(?=')/)) {\n    var value = parseInt(match[1], 16);\n    if (value <= 1114111) { // U+10FFFF\n      isChar = true;\n      stream.next();\n    }\n  }\n  if (isChar) {\n    state.leavingExpr = true;\n    state.tokenize = tokenBase;\n    return \"string\";\n  }\n  if (!stream.match(/^[^']+(?=')/)) { stream.skipToEnd(); }\n  if (stream.match(\"'\")) { state.tokenize = tokenBase; }\n  return \"error\";\n}\n\nfunction tokenStringFactory(delimiter) {\n  if (delimiter.substr(-3) === '\"\"\"') {\n    delimiter = '\"\"\"';\n  } else if (delimiter.substr(-1) === '\"') {\n    delimiter = '\"';\n  }\n  function tokenString(stream, state) {\n    if (stream.eat('\\\\')) {\n      stream.next();\n    } else if (stream.match(delimiter)) {\n      state.tokenize = tokenBase;\n      state.leavingExpr = true;\n      return \"string\";\n    } else {\n      stream.eat(/[`\"]/);\n    }\n    stream.eatWhile(/[^\\\\`\"]/);\n    return \"string\";\n  }\n  return tokenString;\n}\n\nconst julia = {\n  name: \"julia\",\n  startState: function() {\n    return {\n      tokenize: tokenBase,\n      scopes: [],\n      lastToken: null,\n      leavingExpr: false,\n      isDefinition: false,\n      nestedArrays: 0,\n      nestedComments: 0,\n      nestedGenerators: 0,\n      nestedParameters: 0,\n      firstParenPos: -1\n    };\n  },\n\n  token: function(stream, state) {\n    var style = state.tokenize(stream, state);\n    var current = stream.current();\n\n    if (current && style) {\n      state.lastToken = current;\n    }\n\n    return style;\n  },\n\n  indent: function(state, textAfter, cx) {\n    var delta = 0;\n    if ( textAfter === ']' || textAfter === ')' || /^end\\b/.test(textAfter) ||\n         /^else/.test(textAfter) || /^catch\\b/.test(textAfter) || /^elseif\\b/.test(textAfter) ||\n         /^finally/.test(textAfter) ) {\n      delta = -1;\n    }\n    return (state.scopes.length + delta) * cx.unit;\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*(end|else|catch|finally)\\b$/,\n    commentTokens: {line: \"#\", block: {open: \"#=\", close: \"=#\"}},\n    closeBrackets: {brackets: [\"(\", \"[\", \"{\", '\"']},\n    autocomplete: keywordsList.concat(builtinsList)\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvanVsaWEuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQSx5QkFBeUIsSUFBSTtBQUM3QixnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsR0FBRztBQUMxQjtBQUNBLElBQUksMEJBQTBCLElBQUk7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLEdBQUcsR0FBRztBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsMENBQTBDLHdCQUF3QjtBQUNsRSxzQ0FBc0Msd0JBQXdCO0FBQzlELHVDQUF1Qyx3QkFBd0I7QUFDL0Q7QUFDQSx1SEFBdUg7QUFDdkgsb0RBQW9ELHdCQUF3QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0IscUJBQXFCO0FBQ3JCO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEVBQUU7QUFDM0IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRDQUE0QyxJQUFJO0FBQ3BEO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLElBQUksK0NBQStDLElBQUk7QUFDdkQ7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CLHlCQUF5QjtBQUNoRSxvQkFBb0IsdUJBQXVCLFFBQVE7QUFDbkQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9qdWxpYS5qcz81MDE5Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHdvcmRSZWdleHAod29yZHMsIGVuZCwgcHJlKSB7XG4gIGlmICh0eXBlb2YgcHJlID09PSBcInVuZGVmaW5lZFwiKSBwcmUgPSBcIlwiO1xuICBpZiAodHlwZW9mIGVuZCA9PT0gXCJ1bmRlZmluZWRcIikgeyBlbmQgPSBcIlxcXFxiXCI7IH1cbiAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeXCIgKyBwcmUgKyBcIigoXCIgKyB3b3Jkcy5qb2luKFwiKXwoXCIpICsgXCIpKVwiICsgZW5kKTtcbn1cblxudmFyIG9jdENoYXIgPSBcIlxcXFxcXFxcWzAtN117MSwzfVwiO1xudmFyIGhleENoYXIgPSBcIlxcXFxcXFxceFtBLUZhLWYwLTldezEsMn1cIjtcbnZhciBzQ2hhciA9IFwiXFxcXFxcXFxbYWJlZm5ydHYwJT8nXFxcIlxcXFxcXFxcXVwiO1xudmFyIHVDaGFyID0gXCIoW15cXFxcdTAwMjdcXFxcdTAwNUNcXFxcdUQ4MDAtXFxcXHVERkZGXXxbXFxcXHVEODAwLVxcXFx1REZGRl1bXFxcXHVEQzAwLVxcXFx1REZGRl0pXCI7XG5cbnZhciBhc2NpaU9wZXJhdG9yc0xpc3QgPSBbXG4gIFwiWzw+XTpcIiwgXCJbPD49XT1cIiwgXCI8PD0/XCIsIFwiPj4+Pz0/XCIsIFwiPT5cIiwgXCItLT8+XCIsIFwiPC0tWy0+XT9cIiwgXCJcXFxcL1xcXFwvXCIsXG4gIFwiXFxcXC57MiwzfVwiLCBcIltcXFxcLlxcXFxcXFxcJSorXFxcXC08PiFcXFxcL158Jl09P1wiLCBcIlxcXFw/XCIsIFwiXFxcXCRcIiwgXCJ+XCIsIFwiOlwiXG5dO1xudmFyIG9wZXJhdG9ycyA9IHdvcmRSZWdleHAoW1xuICBcIls8Pl06XCIsIFwiWzw+PV09XCIsIFwiWyE9XT09XCIsIFwiPDw9P1wiLCBcIj4+Pj89P1wiLCBcIj0+P1wiLCBcIi0tPz5cIiwgXCI8LS1bLT5dP1wiLCBcIlxcXFwvXFxcXC9cIixcbiAgXCJbXFxcXFxcXFwlKitcXFxcLTw+IVxcXFwvXnwmXFxcXHUwMEY3XFxcXHUyMkJCXT0/XCIsIFwiXFxcXD9cIiwgXCJcXFxcJFwiLCBcIn5cIiwgXCI6XCIsXG4gIFwiXFxcXHUwMEQ3XCIsIFwiXFxcXHUyMjA4XCIsIFwiXFxcXHUyMjA5XCIsIFwiXFxcXHUyMjBCXCIsIFwiXFxcXHUyMjBDXCIsIFwiXFxcXHUyMjE4XCIsXG4gIFwiXFxcXHUyMjFBXCIsIFwiXFxcXHUyMjFCXCIsIFwiXFxcXHUyMjI5XCIsIFwiXFxcXHUyMjJBXCIsIFwiXFxcXHUyMjYwXCIsIFwiXFxcXHUyMjY0XCIsXG4gIFwiXFxcXHUyMjY1XCIsIFwiXFxcXHUyMjg2XCIsIFwiXFxcXHUyMjg4XCIsIFwiXFxcXHUyMjhBXCIsIFwiXFxcXHUyMkM1XCIsXG4gIFwiXFxcXGIoaW58aXNhKVxcXFxiKD8hXFwuP1xcXFwoKVwiXG5dLCBcIlwiKTtcbnZhciBkZWxpbWl0ZXJzID0gL15bOywoKVtcXF17fV0vO1xudmFyIGlkZW50aWZpZXJzID0gL15bX0EtWmEtelxcdTAwQTEtXFx1MjIxN1xcdTIyMTktXFx1RkZGRl1bXFx3XFx1MDBBMS1cXHUyMjE3XFx1MjIxOS1cXHVGRkZGXSohKi87XG5cbnZhciBjaGFycyA9IHdvcmRSZWdleHAoW29jdENoYXIsIGhleENoYXIsIHNDaGFyLCB1Q2hhcl0sIFwiJ1wiKTtcblxudmFyIG9wZW5lcnNMaXN0ID0gW1wiYmVnaW5cIiwgXCJmdW5jdGlvblwiLCBcInR5cGVcIiwgXCJzdHJ1Y3RcIiwgXCJpbW11dGFibGVcIiwgXCJsZXRcIixcbiAgICAgICAgICAgICAgICAgICBcIm1hY3JvXCIsIFwiZm9yXCIsIFwid2hpbGVcIiwgXCJxdW90ZVwiLCBcImlmXCIsIFwiZWxzZVwiLCBcImVsc2VpZlwiLCBcInRyeVwiLFxuICAgICAgICAgICAgICAgICAgIFwiZmluYWxseVwiLCBcImNhdGNoXCIsIFwiZG9cIl07XG5cbnZhciBjbG9zZXJzTGlzdCA9IFtcImVuZFwiLCBcImVsc2VcIiwgXCJlbHNlaWZcIiwgXCJjYXRjaFwiLCBcImZpbmFsbHlcIl07XG5cbnZhciBrZXl3b3Jkc0xpc3QgPSBbXCJpZlwiLCBcImVsc2VcIiwgXCJlbHNlaWZcIiwgXCJ3aGlsZVwiLCBcImZvclwiLCBcImJlZ2luXCIsIFwibGV0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZW5kXCIsIFwiZG9cIiwgXCJ0cnlcIiwgXCJjYXRjaFwiLCBcImZpbmFsbHlcIiwgXCJyZXR1cm5cIiwgXCJicmVha1wiLCBcImNvbnRpbnVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2xvYmFsXCIsIFwibG9jYWxcIiwgXCJjb25zdFwiLCBcImV4cG9ydFwiLCBcImltcG9ydFwiLCBcImltcG9ydGFsbFwiLCBcInVzaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiwgXCJ3aGVyZVwiLCBcIm1hY3JvXCIsIFwibW9kdWxlXCIsIFwiYmFyZW1vZHVsZVwiLCBcInN0cnVjdFwiLCBcInR5cGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtdXRhYmxlXCIsIFwiaW1tdXRhYmxlXCIsIFwicXVvdGVcIiwgXCJ0eXBlYWxpYXNcIiwgXCJhYnN0cmFjdFwiLCBcInByaW1pdGl2ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImJpdHN0eXBlXCJdO1xuXG52YXIgYnVpbHRpbnNMaXN0ID0gW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwibm90aGluZ1wiLCBcIk5hTlwiLCBcIkluZlwiXTtcblxudmFyIG9wZW5lcnMgPSB3b3JkUmVnZXhwKG9wZW5lcnNMaXN0KTtcbnZhciBjbG9zZXJzID0gd29yZFJlZ2V4cChjbG9zZXJzTGlzdCk7XG52YXIga2V5d29yZHMgPSB3b3JkUmVnZXhwKGtleXdvcmRzTGlzdCk7XG52YXIgYnVpbHRpbnMgPSB3b3JkUmVnZXhwKGJ1aWx0aW5zTGlzdCk7XG5cbnZhciBtYWNybyA9IC9eQFtfQS1aYS16XFx1MDBBMS1cXHVGRkZGXVtcXHdcXHUwMEExLVxcdUZGRkZdKiEqLztcbnZhciBzeW1ib2wgPSAvXjpbX0EtWmEtelxcdTAwQTEtXFx1RkZGRl1bXFx3XFx1MDBBMS1cXHVGRkZGXSohKi87XG52YXIgc3RyaW5nUHJlZml4ZXMgPSAvXihgfChbX0EtWmEtelxcdTAwQTEtXFx1RkZGRl0qXCIoXCJcIik/KSkvO1xuXG52YXIgbWFjcm9PcGVyYXRvcnMgPSB3b3JkUmVnZXhwKGFzY2lpT3BlcmF0b3JzTGlzdCwgXCJcIiwgXCJAXCIpO1xudmFyIHN5bWJvbE9wZXJhdG9ycyA9IHdvcmRSZWdleHAoYXNjaWlPcGVyYXRvcnNMaXN0LCBcIlwiLCBcIjpcIik7XG5cbmZ1bmN0aW9uIGluQXJyYXkoc3RhdGUpIHtcbiAgcmV0dXJuIChzdGF0ZS5uZXN0ZWRBcnJheXMgPiAwKTtcbn1cblxuZnVuY3Rpb24gaW5HZW5lcmF0b3Ioc3RhdGUpIHtcbiAgcmV0dXJuIChzdGF0ZS5uZXN0ZWRHZW5lcmF0b3JzID4gMCk7XG59XG5cbmZ1bmN0aW9uIGN1cnJlbnRTY29wZShzdGF0ZSwgbikge1xuICBpZiAodHlwZW9mKG4pID09PSBcInVuZGVmaW5lZFwiKSB7IG4gPSAwOyB9XG4gIGlmIChzdGF0ZS5zY29wZXMubGVuZ3RoIDw9IG4pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gc3RhdGUuc2NvcGVzW3N0YXRlLnNjb3Blcy5sZW5ndGggLSAobiArIDEpXTtcbn1cblxuLy8gdG9rZW5pemVyc1xuZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gSGFuZGxlIG11bHRpbGluZSBjb21tZW50c1xuICBpZiAoc3RyZWFtLm1hdGNoKCcjPScsIGZhbHNlKSkge1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5Db21tZW50O1xuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIC8vIEhhbmRsZSBzY29wZSBjaGFuZ2VzXG4gIHZhciBsZWF2aW5nRXhwciA9IHN0YXRlLmxlYXZpbmdFeHByO1xuICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgbGVhdmluZ0V4cHIgPSBmYWxzZTtcbiAgfVxuICBzdGF0ZS5sZWF2aW5nRXhwciA9IGZhbHNlO1xuXG4gIGlmIChsZWF2aW5nRXhwcikge1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL14nKy8pKSB7XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdHJlYW0ubWF0Y2goL1xcLns0LH0vKSkge1xuICAgIHJldHVybiBcImVycm9yXCI7XG4gIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9cXC57MSwzfS8pKSB7XG4gICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgfVxuXG4gIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcblxuICAvLyBIYW5kbGUgc2luZ2xlIGxpbmUgY29tbWVudHNcbiAgaWYgKGNoID09PSAnIycpIHtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9XG5cbiAgaWYgKGNoID09PSAnWycpIHtcbiAgICBzdGF0ZS5zY29wZXMucHVzaCgnWycpO1xuICAgIHN0YXRlLm5lc3RlZEFycmF5cysrO1xuICB9XG5cbiAgaWYgKGNoID09PSAnKCcpIHtcbiAgICBzdGF0ZS5zY29wZXMucHVzaCgnKCcpO1xuICAgIHN0YXRlLm5lc3RlZEdlbmVyYXRvcnMrKztcbiAgfVxuXG4gIGlmIChpbkFycmF5KHN0YXRlKSAmJiBjaCA9PT0gJ10nKSB7XG4gICAgd2hpbGUgKHN0YXRlLnNjb3Blcy5sZW5ndGggJiYgY3VycmVudFNjb3BlKHN0YXRlKSAhPT0gXCJbXCIpIHsgc3RhdGUuc2NvcGVzLnBvcCgpOyB9XG4gICAgc3RhdGUuc2NvcGVzLnBvcCgpO1xuICAgIHN0YXRlLm5lc3RlZEFycmF5cy0tO1xuICAgIHN0YXRlLmxlYXZpbmdFeHByID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChpbkdlbmVyYXRvcihzdGF0ZSkgJiYgY2ggPT09ICcpJykge1xuICAgIHdoaWxlIChzdGF0ZS5zY29wZXMubGVuZ3RoICYmIGN1cnJlbnRTY29wZShzdGF0ZSkgIT09IFwiKFwiKSB7IHN0YXRlLnNjb3Blcy5wb3AoKTsgfVxuICAgIHN0YXRlLnNjb3Blcy5wb3AoKTtcbiAgICBzdGF0ZS5uZXN0ZWRHZW5lcmF0b3JzLS07XG4gICAgc3RhdGUubGVhdmluZ0V4cHIgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGluQXJyYXkoc3RhdGUpKSB7XG4gICAgaWYgKHN0YXRlLmxhc3RUb2tlbiA9PSBcImVuZFwiICYmIHN0cmVhbS5tYXRjaCgnOicpKSB7XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLm1hdGNoKCdlbmQnKSkge1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1hdGNoO1xuICBpZiAobWF0Y2ggPSBzdHJlYW0ubWF0Y2gob3BlbmVycywgZmFsc2UpKSB7XG4gICAgc3RhdGUuc2NvcGVzLnB1c2gobWF0Y2hbMF0pO1xuICB9XG5cbiAgaWYgKHN0cmVhbS5tYXRjaChjbG9zZXJzLCBmYWxzZSkpIHtcbiAgICBzdGF0ZS5zY29wZXMucG9wKCk7XG4gIH1cblxuICAvLyBIYW5kbGUgdHlwZSBhbm5vdGF0aW9uc1xuICBpZiAoc3RyZWFtLm1hdGNoKC9eOjooPyFbOlxcJF0pLykpIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQW5ub3RhdGlvbjtcbiAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuICAvLyBIYW5kbGUgc3ltYm9sc1xuICBpZiAoIWxlYXZpbmdFeHByICYmIChzdHJlYW0ubWF0Y2goc3ltYm9sKSB8fCBzdHJlYW0ubWF0Y2goc3ltYm9sT3BlcmF0b3JzKSkpIHtcbiAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gIH1cblxuICAvLyBIYW5kbGUgcGFyYW1ldHJpYyB0eXBlc1xuICAvL2lmIChzdHJlYW0ubWF0Y2goL157W159XSp9KD89XFwoKS8pKSB7XG4gIC8vICByZXR1cm4gXCJidWlsdGluXCI7XG4gIC8vfVxuXG4gIC8vIEhhbmRsZSBvcGVyYXRvcnMgYW5kIERlbGltaXRlcnNcbiAgaWYgKHN0cmVhbS5tYXRjaChvcGVyYXRvcnMpKSB7XG4gICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgfVxuXG4gIC8vIEhhbmRsZSBOdW1iZXIgTGl0ZXJhbHNcbiAgaWYgKHN0cmVhbS5tYXRjaCgvXlxcLj9cXGQvLCBmYWxzZSkpIHtcbiAgICB2YXIgaW1NYXRjaGVyID0gUmVnRXhwKC9eaW1cXGIvKTtcbiAgICB2YXIgbnVtYmVyTGl0ZXJhbCA9IGZhbHNlO1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL14weFxcLlswLTlhLWZfXStwW1xcK1xcLV0/W19cXGRdKy9pKSkgeyBudW1iZXJMaXRlcmFsID0gdHJ1ZTsgfVxuICAgIC8vIEludGVnZXJzXG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXjB4WzAtOWEtZl9dKy9pKSkgeyBudW1iZXJMaXRlcmFsID0gdHJ1ZTsgfSAvLyBIZXhcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eMGJbMDFfXSsvaSkpIHsgbnVtYmVyTGl0ZXJhbCA9IHRydWU7IH0gLy8gQmluYXJ5XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXjBvWzAtN19dKy9pKSkgeyBudW1iZXJMaXRlcmFsID0gdHJ1ZTsgfSAvLyBPY3RhbFxuICAgIC8vIEZsb2F0c1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL14oPzooPzpcXGRbX1xcZF0qKT9cXC4oPyFcXC4pKD86XFxkW19cXGRdKik/fFxcZFtfXFxkXSpcXC4oPyFcXC4pKD86XFxkW19cXGRdKikpPyhbRWVmXVtcXCtcXC1dP1tfXFxkXSspPy9pKSkgeyBudW1iZXJMaXRlcmFsID0gdHJ1ZTsgfVxuICAgIGlmIChzdHJlYW0ubWF0Y2goL15cXGRbX1xcZF0qKGVbXFwrXFwtXT9cXGQrKT8vaSkpIHsgbnVtYmVyTGl0ZXJhbCA9IHRydWU7IH0gLy8gRGVjaW1hbFxuICAgIGlmIChudW1iZXJMaXRlcmFsKSB7XG4gICAgICAvLyBJbnRlZ2VyIGxpdGVyYWxzIG1heSBiZSBcImxvbmdcIlxuICAgICAgc3RyZWFtLm1hdGNoKGltTWF0Y2hlcik7XG4gICAgICBzdGF0ZS5sZWF2aW5nRXhwciA9IHRydWU7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgQ2hhcnNcbiAgaWYgKHN0cmVhbS5tYXRjaChcIidcIikpIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ2hhcjtcbiAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuICAvLyBIYW5kbGUgU3RyaW5nc1xuICBpZiAoc3RyZWFtLm1hdGNoKHN0cmluZ1ByZWZpeGVzKSkge1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmdGYWN0b3J5KHN0cmVhbS5jdXJyZW50KCkpO1xuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIGlmIChzdHJlYW0ubWF0Y2gobWFjcm8pIHx8IHN0cmVhbS5tYXRjaChtYWNyb09wZXJhdG9ycykpIHtcbiAgICByZXR1cm4gXCJtZXRhXCI7XG4gIH1cblxuICBpZiAoc3RyZWFtLm1hdGNoKGRlbGltaXRlcnMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoc3RyZWFtLm1hdGNoKGtleXdvcmRzKSkge1xuICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgfVxuXG4gIGlmIChzdHJlYW0ubWF0Y2goYnVpbHRpbnMpKSB7XG4gICAgcmV0dXJuIFwiYnVpbHRpblwiO1xuICB9XG5cbiAgdmFyIGlzRGVmaW5pdGlvbiA9IHN0YXRlLmlzRGVmaW5pdGlvbiB8fCBzdGF0ZS5sYXN0VG9rZW4gPT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICBzdGF0ZS5sYXN0VG9rZW4gPT0gXCJtYWNyb1wiIHx8IHN0YXRlLmxhc3RUb2tlbiA9PSBcInR5cGVcIiB8fFxuICAgICAgc3RhdGUubGFzdFRva2VuID09IFwic3RydWN0XCIgfHwgc3RhdGUubGFzdFRva2VuID09IFwiaW1tdXRhYmxlXCI7XG5cbiAgaWYgKHN0cmVhbS5tYXRjaChpZGVudGlmaWVycykpIHtcbiAgICBpZiAoaXNEZWZpbml0aW9uKSB7XG4gICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PT0gJy4nKSB7XG4gICAgICAgIHN0YXRlLmlzRGVmaW5pdGlvbiA9IHRydWU7XG4gICAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgICB9XG4gICAgICBzdGF0ZS5pc0RlZmluaXRpb24gPSBmYWxzZTtcbiAgICAgIHJldHVybiBcImRlZlwiO1xuICAgIH1cbiAgICBzdGF0ZS5sZWF2aW5nRXhwciA9IHRydWU7XG4gICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgfVxuXG4gIC8vIEhhbmRsZSBub24tZGV0ZWN0ZWQgaXRlbXNcbiAgc3RyZWFtLm5leHQoKTtcbiAgcmV0dXJuIFwiZXJyb3JcIjtcbn1cblxuZnVuY3Rpb24gdG9rZW5Bbm5vdGF0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLm1hdGNoKC8uKj8oPz1bLDt7fSgpPVxcc118JCkvKTtcbiAgaWYgKHN0cmVhbS5tYXRjaCgneycpKSB7XG4gICAgc3RhdGUubmVzdGVkUGFyYW1ldGVycysrO1xuICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgnfScpICYmIHN0YXRlLm5lc3RlZFBhcmFtZXRlcnMgPiAwKSB7XG4gICAgc3RhdGUubmVzdGVkUGFyYW1ldGVycy0tO1xuICB9XG4gIGlmIChzdGF0ZS5uZXN0ZWRQYXJhbWV0ZXJzID4gMCkge1xuICAgIHN0cmVhbS5tYXRjaCgvLio/KD89e3x9KS8pIHx8IHN0cmVhbS5uZXh0KCk7XG4gIH0gZWxzZSBpZiAoc3RhdGUubmVzdGVkUGFyYW1ldGVycyA9PSAwKSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gIH1cbiAgcmV0dXJuIFwiYnVpbHRpblwiO1xufVxuXG5mdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RyZWFtLm1hdGNoKCcjPScpKSB7XG4gICAgc3RhdGUubmVzdGVkQ29tbWVudHMrKztcbiAgfVxuICBpZiAoIXN0cmVhbS5tYXRjaCgvLio/KD89KCM9fD0jKSkvKSkge1xuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgfVxuICBpZiAoc3RyZWFtLm1hdGNoKCc9IycpKSB7XG4gICAgc3RhdGUubmVzdGVkQ29tbWVudHMtLTtcbiAgICBpZiAoc3RhdGUubmVzdGVkQ29tbWVudHMgPT0gMClcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICB9XG4gIHJldHVybiBcImNvbW1lbnRcIjtcbn1cblxuZnVuY3Rpb24gdG9rZW5DaGFyKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGlzQ2hhciA9IGZhbHNlLCBtYXRjaDtcbiAgaWYgKHN0cmVhbS5tYXRjaChjaGFycykpIHtcbiAgICBpc0NoYXIgPSB0cnVlO1xuICB9IGVsc2UgaWYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKC9cXFxcdShbYS1mMC05XXsxLDR9KSg/PScpL2kpKSB7XG4gICAgdmFyIHZhbHVlID0gcGFyc2VJbnQobWF0Y2hbMV0sIDE2KTtcbiAgICBpZiAodmFsdWUgPD0gNTUyOTUgfHwgdmFsdWUgPj0gNTczNDQpIHsgLy8gKFUrMCxVK0Q3RkYpLCAoVStFMDAwLFUrRkZGRilcbiAgICAgIGlzQ2hhciA9IHRydWU7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChtYXRjaCA9IHN0cmVhbS5tYXRjaCgvXFxcXFUoW0EtRmEtZjAtOV17NSw4fSkoPz0nKS8pKSB7XG4gICAgdmFyIHZhbHVlID0gcGFyc2VJbnQobWF0Y2hbMV0sIDE2KTtcbiAgICBpZiAodmFsdWUgPD0gMTExNDExMSkgeyAvLyBVKzEwRkZGRlxuICAgICAgaXNDaGFyID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgfVxuICB9XG4gIGlmIChpc0NoYXIpIHtcbiAgICBzdGF0ZS5sZWF2aW5nRXhwciA9IHRydWU7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH1cbiAgaWYgKCFzdHJlYW0ubWF0Y2goL15bXiddKyg/PScpLykpIHsgc3RyZWFtLnNraXBUb0VuZCgpOyB9XG4gIGlmIChzdHJlYW0ubWF0Y2goXCInXCIpKSB7IHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlOyB9XG4gIHJldHVybiBcImVycm9yXCI7XG59XG5cbmZ1bmN0aW9uIHRva2VuU3RyaW5nRmFjdG9yeShkZWxpbWl0ZXIpIHtcbiAgaWYgKGRlbGltaXRlci5zdWJzdHIoLTMpID09PSAnXCJcIlwiJykge1xuICAgIGRlbGltaXRlciA9ICdcIlwiXCInO1xuICB9IGVsc2UgaWYgKGRlbGltaXRlci5zdWJzdHIoLTEpID09PSAnXCInKSB7XG4gICAgZGVsaW1pdGVyID0gJ1wiJztcbiAgfVxuICBmdW5jdGlvbiB0b2tlblN0cmluZyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5lYXQoJ1xcXFwnKSkge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChkZWxpbWl0ZXIpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHN0YXRlLmxlYXZpbmdFeHByID0gdHJ1ZTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uZWF0KC9bYFwiXS8pO1xuICAgIH1cbiAgICBzdHJlYW0uZWF0V2hpbGUoL1teXFxcXGBcIl0vKTtcbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfVxuICByZXR1cm4gdG9rZW5TdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBqdWxpYSA9IHtcbiAgbmFtZTogXCJqdWxpYVwiLFxuICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgIHNjb3BlczogW10sXG4gICAgICBsYXN0VG9rZW46IG51bGwsXG4gICAgICBsZWF2aW5nRXhwcjogZmFsc2UsXG4gICAgICBpc0RlZmluaXRpb246IGZhbHNlLFxuICAgICAgbmVzdGVkQXJyYXlzOiAwLFxuICAgICAgbmVzdGVkQ29tbWVudHM6IDAsXG4gICAgICBuZXN0ZWRHZW5lcmF0b3JzOiAwLFxuICAgICAgbmVzdGVkUGFyYW1ldGVyczogMCxcbiAgICAgIGZpcnN0UGFyZW5Qb3M6IC0xXG4gICAgfTtcbiAgfSxcblxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIHZhciBjdXJyZW50ID0gc3RyZWFtLmN1cnJlbnQoKTtcblxuICAgIGlmIChjdXJyZW50ICYmIHN0eWxlKSB7XG4gICAgICBzdGF0ZS5sYXN0VG9rZW4gPSBjdXJyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcblxuICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGN4KSB7XG4gICAgdmFyIGRlbHRhID0gMDtcbiAgICBpZiAoIHRleHRBZnRlciA9PT0gJ10nIHx8IHRleHRBZnRlciA9PT0gJyknIHx8IC9eZW5kXFxiLy50ZXN0KHRleHRBZnRlcikgfHxcbiAgICAgICAgIC9eZWxzZS8udGVzdCh0ZXh0QWZ0ZXIpIHx8IC9eY2F0Y2hcXGIvLnRlc3QodGV4dEFmdGVyKSB8fCAvXmVsc2VpZlxcYi8udGVzdCh0ZXh0QWZ0ZXIpIHx8XG4gICAgICAgICAvXmZpbmFsbHkvLnRlc3QodGV4dEFmdGVyKSApIHtcbiAgICAgIGRlbHRhID0gLTE7XG4gICAgfVxuICAgIHJldHVybiAoc3RhdGUuc2NvcGVzLmxlbmd0aCArIGRlbHRhKSAqIGN4LnVuaXQ7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgaW5kZW50T25JbnB1dDogL15cXHMqKGVuZHxlbHNlfGNhdGNofGZpbmFsbHkpXFxiJC8sXG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiI1wiLCBibG9jazoge29wZW46IFwiIz1cIiwgY2xvc2U6IFwiPSNcIn19LFxuICAgIGNsb3NlQnJhY2tldHM6IHticmFja2V0czogW1wiKFwiLCBcIltcIiwgXCJ7XCIsICdcIiddfSxcbiAgICBhdXRvY29tcGxldGU6IGtleXdvcmRzTGlzdC5jb25jYXQoYnVpbHRpbnNMaXN0KVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/legacy-modes/mode/julia.js\n"));

/***/ })

}]);