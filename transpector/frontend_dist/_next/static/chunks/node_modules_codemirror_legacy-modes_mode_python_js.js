"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_codemirror_legacy-modes_mode_python_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/python.js":
/*!**************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/python.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cython\": function() { return /* binding */ cython; },\n/* harmony export */   \"mkPython\": function() { return /* binding */ mkPython; },\n/* harmony export */   \"python\": function() { return /* binding */ python; }\n/* harmony export */ });\nfunction wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\n\nvar wordOperators = wordRegexp([\"and\", \"or\", \"not\", \"is\"]);\nvar commonKeywords = [\"as\", \"assert\", \"break\", \"class\", \"continue\",\n                      \"def\", \"del\", \"elif\", \"else\", \"except\", \"finally\",\n                      \"for\", \"from\", \"global\", \"if\", \"import\",\n                      \"lambda\", \"pass\", \"raise\", \"return\",\n                      \"try\", \"while\", \"with\", \"yield\", \"in\"];\nvar commonBuiltins = [\"abs\", \"all\", \"any\", \"bin\", \"bool\", \"bytearray\", \"callable\", \"chr\",\n                      \"classmethod\", \"compile\", \"complex\", \"delattr\", \"dict\", \"dir\", \"divmod\",\n                      \"enumerate\", \"eval\", \"filter\", \"float\", \"format\", \"frozenset\",\n                      \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\",\n                      \"input\", \"int\", \"isinstance\", \"issubclass\", \"iter\", \"len\",\n                      \"list\", \"locals\", \"map\", \"max\", \"memoryview\", \"min\", \"next\",\n                      \"object\", \"oct\", \"open\", \"ord\", \"pow\", \"property\", \"range\",\n                      \"repr\", \"reversed\", \"round\", \"set\", \"setattr\", \"slice\",\n                      \"sorted\", \"staticmethod\", \"str\", \"sum\", \"super\", \"tuple\",\n                      \"type\", \"vars\", \"zip\", \"__import__\", \"NotImplemented\",\n                      \"Ellipsis\", \"__debug__\"];\n\nfunction top(state) {\n  return state.scopes[state.scopes.length - 1];\n}\n\nfunction mkPython(parserConf) {\n  var ERRORCLASS = \"error\";\n\n  var delimiters = parserConf.delimiters || parserConf.singleDelimiters || /^[\\(\\)\\[\\]\\{\\}@,:`=;\\.\\\\]/;\n  //               (Backwards-compatibility with old, cumbersome config system)\n  var operators = [parserConf.singleOperators, parserConf.doubleOperators, parserConf.doubleDelimiters, parserConf.tripleDelimiters,\n                   parserConf.operators || /^([-+*/%\\/&|^]=?|[<>=]+|\\/\\/=?|\\*\\*=?|!=|[~!@]|\\.\\.\\.)/]\n  for (var i = 0; i < operators.length; i++) if (!operators[i]) operators.splice(i--, 1)\n\n  var hangingIndent = parserConf.hangingIndent;\n\n  var myKeywords = commonKeywords, myBuiltins = commonBuiltins;\n  if (parserConf.extra_keywords != undefined)\n    myKeywords = myKeywords.concat(parserConf.extra_keywords);\n\n  if (parserConf.extra_builtins != undefined)\n    myBuiltins = myBuiltins.concat(parserConf.extra_builtins);\n\n  var py3 = !(parserConf.version && Number(parserConf.version) < 3)\n  if (py3) {\n    // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator\n    var identifiers = parserConf.identifiers|| /^[_A-Za-z\\u00A1-\\uFFFF][_A-Za-z0-9\\u00A1-\\uFFFF]*/;\n    myKeywords = myKeywords.concat([\"nonlocal\", \"False\", \"True\", \"None\", \"async\", \"await\"]);\n    myBuiltins = myBuiltins.concat([\"ascii\", \"bytes\", \"exec\", \"print\"]);\n    var stringPrefixes = new RegExp(\"^(([rbuf]|(br)|(rb)|(fr)|(rf))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n  } else {\n    var identifiers = parserConf.identifiers|| /^[_A-Za-z][_A-Za-z0-9]*/;\n    myKeywords = myKeywords.concat([\"exec\", \"print\"]);\n    myBuiltins = myBuiltins.concat([\"apply\", \"basestring\", \"buffer\", \"cmp\", \"coerce\", \"execfile\",\n                                    \"file\", \"intern\", \"long\", \"raw_input\", \"reduce\", \"reload\",\n                                    \"unichr\", \"unicode\", \"xrange\", \"False\", \"True\", \"None\"]);\n    var stringPrefixes = new RegExp(\"^(([rubf]|(ur)|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n  }\n  var keywords = wordRegexp(myKeywords);\n  var builtins = wordRegexp(myBuiltins);\n\n  // tokenizers\n  function tokenBase(stream, state) {\n    var sol = stream.sol() && state.lastToken != \"\\\\\"\n    if (sol) state.indent = stream.indentation()\n    // Handle scope changes\n    if (sol && top(state).type == \"py\") {\n      var scopeOffset = top(state).offset;\n      if (stream.eatSpace()) {\n        var lineOffset = stream.indentation();\n        if (lineOffset > scopeOffset)\n          pushPyScope(stream, state);\n        else if (lineOffset < scopeOffset && dedent(stream, state) && stream.peek() != \"#\")\n          state.errorToken = true;\n        return null;\n      } else {\n        var style = tokenBaseInner(stream, state);\n        if (scopeOffset > 0 && dedent(stream, state))\n          style += \" \" + ERRORCLASS;\n        return style;\n      }\n    }\n    return tokenBaseInner(stream, state);\n  }\n\n  function tokenBaseInner(stream, state, inFormat) {\n    if (stream.eatSpace()) return null;\n\n    // Handle Comments\n    if (!inFormat && stream.match(/^#.*/)) return \"comment\";\n\n    // Handle Number Literals\n    if (stream.match(/^[0-9\\.]/, false)) {\n      var floatLiteral = false;\n      // Floats\n      if (stream.match(/^[\\d_]*\\.\\d+(e[\\+\\-]?\\d+)?/i)) { floatLiteral = true; }\n      if (stream.match(/^[\\d_]+\\.\\d*/)) { floatLiteral = true; }\n      if (stream.match(/^\\.\\d+/)) { floatLiteral = true; }\n      if (floatLiteral) {\n        // Float literals may be \"imaginary\"\n        stream.eat(/J/i);\n        return \"number\";\n      }\n      // Integers\n      var intLiteral = false;\n      // Hex\n      if (stream.match(/^0x[0-9a-f_]+/i)) intLiteral = true;\n      // Binary\n      if (stream.match(/^0b[01_]+/i)) intLiteral = true;\n      // Octal\n      if (stream.match(/^0o[0-7_]+/i)) intLiteral = true;\n      // Decimal\n      if (stream.match(/^[1-9][\\d_]*(e[\\+\\-]?[\\d_]+)?/)) {\n        // Decimal literals may be \"imaginary\"\n        stream.eat(/J/i);\n        // TODO - Can you have imaginary longs?\n        intLiteral = true;\n      }\n      // Zero by itself with no other piece of number.\n      if (stream.match(/^0(?![\\dx])/i)) intLiteral = true;\n      if (intLiteral) {\n        // Integer literals may be \"long\"\n        stream.eat(/L/i);\n        return \"number\";\n      }\n    }\n\n    // Handle Strings\n    if (stream.match(stringPrefixes)) {\n      var isFmtString = stream.current().toLowerCase().indexOf('f') !== -1;\n      if (!isFmtString) {\n        state.tokenize = tokenStringFactory(stream.current(), state.tokenize);\n        return state.tokenize(stream, state);\n      } else {\n        state.tokenize = formatStringFactory(stream.current(), state.tokenize);\n        return state.tokenize(stream, state);\n      }\n    }\n\n    for (var i = 0; i < operators.length; i++)\n      if (stream.match(operators[i])) return \"operator\"\n\n    if (stream.match(delimiters)) return \"punctuation\";\n\n    if (state.lastToken == \".\" && stream.match(identifiers))\n      return \"property\";\n\n    if (stream.match(keywords) || stream.match(wordOperators))\n      return \"keyword\";\n\n    if (stream.match(builtins))\n      return \"builtin\";\n\n    if (stream.match(/^(self|cls)\\b/))\n      return \"self\";\n\n    if (stream.match(identifiers)) {\n      if (state.lastToken == \"def\" || state.lastToken == \"class\")\n        return \"def\";\n      return \"variable\";\n    }\n\n    // Handle non-detected items\n    stream.next();\n    return inFormat ? null :ERRORCLASS;\n  }\n\n  function formatStringFactory(delimiter, tokenOuter) {\n    while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n      delimiter = delimiter.substr(1);\n\n    var singleline = delimiter.length == 1;\n    var OUTCLASS = \"string\";\n\n    function tokenNestedExpr(depth) {\n      return function(stream, state) {\n        var inner = tokenBaseInner(stream, state, true)\n        if (inner == \"punctuation\") {\n          if (stream.current() == \"{\") {\n            state.tokenize = tokenNestedExpr(depth + 1)\n          } else if (stream.current() == \"}\") {\n            if (depth > 1) state.tokenize = tokenNestedExpr(depth - 1)\n            else state.tokenize = tokenString\n          }\n        }\n        return inner\n      }\n    }\n\n    function tokenString(stream, state) {\n      while (!stream.eol()) {\n        stream.eatWhile(/[^'\"\\{\\}\\\\]/);\n        if (stream.eat(\"\\\\\")) {\n          stream.next();\n          if (singleline && stream.eol())\n            return OUTCLASS;\n        } else if (stream.match(delimiter)) {\n          state.tokenize = tokenOuter;\n          return OUTCLASS;\n        } else if (stream.match('{{')) {\n          // ignore {{ in f-str\n          return OUTCLASS;\n        } else if (stream.match('{', false)) {\n          // switch to nested mode\n          state.tokenize = tokenNestedExpr(0)\n          if (stream.current()) return OUTCLASS;\n          else return state.tokenize(stream, state)\n        } else if (stream.match('}}')) {\n          return OUTCLASS;\n        } else if (stream.match('}')) {\n          // single } in f-string is an error\n          return ERRORCLASS;\n        } else {\n          stream.eat(/['\"]/);\n        }\n      }\n      if (singleline) {\n        if (parserConf.singleLineStringErrors)\n          return ERRORCLASS;\n        else\n          state.tokenize = tokenOuter;\n      }\n      return OUTCLASS;\n    }\n    tokenString.isString = true;\n    return tokenString;\n  }\n\n  function tokenStringFactory(delimiter, tokenOuter) {\n    while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n      delimiter = delimiter.substr(1);\n\n    var singleline = delimiter.length == 1;\n    var OUTCLASS = \"string\";\n\n    function tokenString(stream, state) {\n      while (!stream.eol()) {\n        stream.eatWhile(/[^'\"\\\\]/);\n        if (stream.eat(\"\\\\\")) {\n          stream.next();\n          if (singleline && stream.eol())\n            return OUTCLASS;\n        } else if (stream.match(delimiter)) {\n          state.tokenize = tokenOuter;\n          return OUTCLASS;\n        } else {\n          stream.eat(/['\"]/);\n        }\n      }\n      if (singleline) {\n        if (parserConf.singleLineStringErrors)\n          return ERRORCLASS;\n        else\n          state.tokenize = tokenOuter;\n      }\n      return OUTCLASS;\n    }\n    tokenString.isString = true;\n    return tokenString;\n  }\n\n  function pushPyScope(stream, state) {\n    while (top(state).type != \"py\") state.scopes.pop()\n    state.scopes.push({offset: top(state).offset + stream.indentUnit,\n                       type: \"py\",\n                       align: null})\n  }\n\n  function pushBracketScope(stream, state, type) {\n    var align = stream.match(/^[\\s\\[\\{\\(]*(?:#|$)/, false) ? null : stream.column() + 1\n    state.scopes.push({offset: state.indent + (hangingIndent || stream.indentUnit),\n                       type: type,\n                       align: align})\n  }\n\n  function dedent(stream, state) {\n    var indented = stream.indentation();\n    while (state.scopes.length > 1 && top(state).offset > indented) {\n      if (top(state).type != \"py\") return true;\n      state.scopes.pop();\n    }\n    return top(state).offset != indented;\n  }\n\n  function tokenLexer(stream, state) {\n    if (stream.sol()) {\n      state.beginningOfLine = true;\n      state.dedent = false;\n    }\n\n    var style = state.tokenize(stream, state);\n    var current = stream.current();\n\n    // Handle decorators\n    if (state.beginningOfLine && current == \"@\")\n      return stream.match(identifiers, false) ? \"meta\" : py3 ? \"operator\" : ERRORCLASS;\n\n    if (/\\S/.test(current)) state.beginningOfLine = false;\n\n    if ((style == \"variable\" || style == \"builtin\")\n        && state.lastToken == \"meta\")\n      style = \"meta\";\n\n    // Handle scope changes.\n    if (current == \"pass\" || current == \"return\")\n      state.dedent = true;\n\n    if (current == \"lambda\") state.lambda = true;\n    if (current == \":\" && !state.lambda && top(state).type == \"py\" && stream.match(/^\\s*(?:#|$)/, false))\n      pushPyScope(stream, state);\n\n    if (current.length == 1 && !/string|comment/.test(style)) {\n      var delimiter_index = \"[({\".indexOf(current);\n      if (delimiter_index != -1)\n        pushBracketScope(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n\n      delimiter_index = \"])}\".indexOf(current);\n      if (delimiter_index != -1) {\n        if (top(state).type == current) state.indent = state.scopes.pop().offset - (hangingIndent || stream.indentUnit)\n        else return ERRORCLASS;\n      }\n    }\n    if (state.dedent && stream.eol() && top(state).type == \"py\" && state.scopes.length > 1)\n      state.scopes.pop();\n\n    return style;\n  }\n\n  return {\n    name: \"python\",\n\n    startState: function() {\n      return {\n        tokenize: tokenBase,\n        scopes: [{offset: 0, type: \"py\", align: null}],\n        indent: 0,\n        lastToken: null,\n        lambda: false,\n        dedent: 0\n      };\n    },\n\n    token: function(stream, state) {\n      var addErr = state.errorToken;\n      if (addErr) state.errorToken = false;\n      var style = tokenLexer(stream, state);\n\n      if (style && style != \"comment\")\n        state.lastToken = (style == \"keyword\" || style == \"punctuation\") ? stream.current() : style;\n      if (style == \"punctuation\") style = null;\n\n      if (stream.eol() && state.lambda)\n        state.lambda = false;\n      return addErr ? ERRORCLASS : style;\n    },\n\n    indent: function(state, textAfter, cx) {\n      if (state.tokenize != tokenBase)\n        return state.tokenize.isString ? null : 0;\n\n      var scope = top(state)\n      var closing = scope.type == textAfter.charAt(0) ||\n          scope.type == \"py\" && !state.dedent && /^(else:|elif |except |finally:)/.test(textAfter)\n      if (scope.align != null)\n        return scope.align - (closing ? 1 : 0)\n      else\n        return scope.offset - (closing ? hangingIndent || cx.unit : 0)\n    },\n\n    languageData: {\n      autocomplete: commonKeywords.concat(commonBuiltins).concat([\"exec\", \"print\"]),\n      indentOnInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/,\n      commentTokens: {line: \"#\"},\n      closeBrackets: {brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"'''\", '\"\"\"']}\n    }\n  };\n};\n\nvar words = function(str) { return str.split(\" \"); };\n\nconst python = mkPython({})\n\nconst cython = mkPython({\n  extra_keywords: words(\"by cdef cimport cpdef ctypedef enum except \"+\n                        \"extern gil include nogil property public \"+\n                        \"readonly struct union DEF IF ELIF ELSE\")\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvcHl0aG9uLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQOztBQUVBLHdGQUF3RixFQUFFLE1BQU07QUFDaEc7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLEVBQUUsSUFBSSxFQUFFO0FBQy9FLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELEVBQUUsSUFBSSxFQUFFO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pELDBDQUEwQztBQUMxQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixFQUFFO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQyx1QkFBdUI7QUFDdkI7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEMsc0JBQXNCO0FBQ3RCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEMsdUJBQXVCO0FBQ3ZCO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLDRDQUE0Qzs7QUFFNUMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUNBQW1DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixzQkFBc0IsVUFBVTtBQUNoQyxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRXJCLDBCQUEwQjs7QUFFMUI7QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9weXRob24uanM/ZDZiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiB3b3JkUmVnZXhwKHdvcmRzKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXigoXCIgKyB3b3Jkcy5qb2luKFwiKXwoXCIpICsgXCIpKVxcXFxiXCIpO1xufVxuXG52YXIgd29yZE9wZXJhdG9ycyA9IHdvcmRSZWdleHAoW1wiYW5kXCIsIFwib3JcIiwgXCJub3RcIiwgXCJpc1wiXSk7XG52YXIgY29tbW9uS2V5d29yZHMgPSBbXCJhc1wiLCBcImFzc2VydFwiLCBcImJyZWFrXCIsIFwiY2xhc3NcIiwgXCJjb250aW51ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZGVmXCIsIFwiZGVsXCIsIFwiZWxpZlwiLCBcImVsc2VcIiwgXCJleGNlcHRcIiwgXCJmaW5hbGx5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJmb3JcIiwgXCJmcm9tXCIsIFwiZ2xvYmFsXCIsIFwiaWZcIiwgXCJpbXBvcnRcIixcbiAgICAgICAgICAgICAgICAgICAgICBcImxhbWJkYVwiLCBcInBhc3NcIiwgXCJyYWlzZVwiLCBcInJldHVyblwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwidHJ5XCIsIFwid2hpbGVcIiwgXCJ3aXRoXCIsIFwieWllbGRcIiwgXCJpblwiXTtcbnZhciBjb21tb25CdWlsdGlucyA9IFtcImFic1wiLCBcImFsbFwiLCBcImFueVwiLCBcImJpblwiLCBcImJvb2xcIiwgXCJieXRlYXJyYXlcIiwgXCJjYWxsYWJsZVwiLCBcImNoclwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiY2xhc3NtZXRob2RcIiwgXCJjb21waWxlXCIsIFwiY29tcGxleFwiLCBcImRlbGF0dHJcIiwgXCJkaWN0XCIsIFwiZGlyXCIsIFwiZGl2bW9kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJlbnVtZXJhdGVcIiwgXCJldmFsXCIsIFwiZmlsdGVyXCIsIFwiZmxvYXRcIiwgXCJmb3JtYXRcIiwgXCJmcm96ZW5zZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICBcImdldGF0dHJcIiwgXCJnbG9iYWxzXCIsIFwiaGFzYXR0clwiLCBcImhhc2hcIiwgXCJoZWxwXCIsIFwiaGV4XCIsIFwiaWRcIixcbiAgICAgICAgICAgICAgICAgICAgICBcImlucHV0XCIsIFwiaW50XCIsIFwiaXNpbnN0YW5jZVwiLCBcImlzc3ViY2xhc3NcIiwgXCJpdGVyXCIsIFwibGVuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJsaXN0XCIsIFwibG9jYWxzXCIsIFwibWFwXCIsIFwibWF4XCIsIFwibWVtb3J5dmlld1wiLCBcIm1pblwiLCBcIm5leHRcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIm9iamVjdFwiLCBcIm9jdFwiLCBcIm9wZW5cIiwgXCJvcmRcIiwgXCJwb3dcIiwgXCJwcm9wZXJ0eVwiLCBcInJhbmdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJyZXByXCIsIFwicmV2ZXJzZWRcIiwgXCJyb3VuZFwiLCBcInNldFwiLCBcInNldGF0dHJcIiwgXCJzbGljZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwic29ydGVkXCIsIFwic3RhdGljbWV0aG9kXCIsIFwic3RyXCIsIFwic3VtXCIsIFwic3VwZXJcIiwgXCJ0dXBsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiLCBcInZhcnNcIiwgXCJ6aXBcIiwgXCJfX2ltcG9ydF9fXCIsIFwiTm90SW1wbGVtZW50ZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkVsbGlwc2lzXCIsIFwiX19kZWJ1Z19fXCJdO1xuXG5mdW5jdGlvbiB0b3Aoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnNjb3Blc1tzdGF0ZS5zY29wZXMubGVuZ3RoIC0gMV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBta1B5dGhvbihwYXJzZXJDb25mKSB7XG4gIHZhciBFUlJPUkNMQVNTID0gXCJlcnJvclwiO1xuXG4gIHZhciBkZWxpbWl0ZXJzID0gcGFyc2VyQ29uZi5kZWxpbWl0ZXJzIHx8IHBhcnNlckNvbmYuc2luZ2xlRGVsaW1pdGVycyB8fCAvXltcXChcXClcXFtcXF1cXHtcXH1ALDpgPTtcXC5cXFxcXS87XG4gIC8vICAgICAgICAgICAgICAgKEJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdpdGggb2xkLCBjdW1iZXJzb21lIGNvbmZpZyBzeXN0ZW0pXG4gIHZhciBvcGVyYXRvcnMgPSBbcGFyc2VyQ29uZi5zaW5nbGVPcGVyYXRvcnMsIHBhcnNlckNvbmYuZG91YmxlT3BlcmF0b3JzLCBwYXJzZXJDb25mLmRvdWJsZURlbGltaXRlcnMsIHBhcnNlckNvbmYudHJpcGxlRGVsaW1pdGVycyxcbiAgICAgICAgICAgICAgICAgICBwYXJzZXJDb25mLm9wZXJhdG9ycyB8fCAvXihbLSsqLyVcXC8mfF5dPT98Wzw+PV0rfFxcL1xcLz0/fFxcKlxcKj0/fCE9fFt+IUBdfFxcLlxcLlxcLikvXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wZXJhdG9ycy5sZW5ndGg7IGkrKykgaWYgKCFvcGVyYXRvcnNbaV0pIG9wZXJhdG9ycy5zcGxpY2UoaS0tLCAxKVxuXG4gIHZhciBoYW5naW5nSW5kZW50ID0gcGFyc2VyQ29uZi5oYW5naW5nSW5kZW50O1xuXG4gIHZhciBteUtleXdvcmRzID0gY29tbW9uS2V5d29yZHMsIG15QnVpbHRpbnMgPSBjb21tb25CdWlsdGlucztcbiAgaWYgKHBhcnNlckNvbmYuZXh0cmFfa2V5d29yZHMgIT0gdW5kZWZpbmVkKVxuICAgIG15S2V5d29yZHMgPSBteUtleXdvcmRzLmNvbmNhdChwYXJzZXJDb25mLmV4dHJhX2tleXdvcmRzKTtcblxuICBpZiAocGFyc2VyQ29uZi5leHRyYV9idWlsdGlucyAhPSB1bmRlZmluZWQpXG4gICAgbXlCdWlsdGlucyA9IG15QnVpbHRpbnMuY29uY2F0KHBhcnNlckNvbmYuZXh0cmFfYnVpbHRpbnMpO1xuXG4gIHZhciBweTMgPSAhKHBhcnNlckNvbmYudmVyc2lvbiAmJiBOdW1iZXIocGFyc2VyQ29uZi52ZXJzaW9uKSA8IDMpXG4gIGlmIChweTMpIHtcbiAgICAvLyBzaW5jZSBodHRwOi8vbGVnYWN5LnB5dGhvbi5vcmcvZGV2L3BlcHMvcGVwLTA0NjUvIEAgaXMgYWxzbyBhbiBvcGVyYXRvclxuICAgIHZhciBpZGVudGlmaWVycyA9IHBhcnNlckNvbmYuaWRlbnRpZmllcnN8fCAvXltfQS1aYS16XFx1MDBBMS1cXHVGRkZGXVtfQS1aYS16MC05XFx1MDBBMS1cXHVGRkZGXSovO1xuICAgIG15S2V5d29yZHMgPSBteUtleXdvcmRzLmNvbmNhdChbXCJub25sb2NhbFwiLCBcIkZhbHNlXCIsIFwiVHJ1ZVwiLCBcIk5vbmVcIiwgXCJhc3luY1wiLCBcImF3YWl0XCJdKTtcbiAgICBteUJ1aWx0aW5zID0gbXlCdWlsdGlucy5jb25jYXQoW1wiYXNjaWlcIiwgXCJieXRlc1wiLCBcImV4ZWNcIiwgXCJwcmludFwiXSk7XG4gICAgdmFyIHN0cmluZ1ByZWZpeGVzID0gbmV3IFJlZ0V4cChcIl4oKFtyYnVmXXwoYnIpfChyYil8KGZyKXwocmYpKT8oJ3szfXxcXFwiezN9fFsnXFxcIl0pKVwiLCBcImlcIik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlkZW50aWZpZXJzID0gcGFyc2VyQ29uZi5pZGVudGlmaWVyc3x8IC9eW19BLVphLXpdW19BLVphLXowLTldKi87XG4gICAgbXlLZXl3b3JkcyA9IG15S2V5d29yZHMuY29uY2F0KFtcImV4ZWNcIiwgXCJwcmludFwiXSk7XG4gICAgbXlCdWlsdGlucyA9IG15QnVpbHRpbnMuY29uY2F0KFtcImFwcGx5XCIsIFwiYmFzZXN0cmluZ1wiLCBcImJ1ZmZlclwiLCBcImNtcFwiLCBcImNvZXJjZVwiLCBcImV4ZWNmaWxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZpbGVcIiwgXCJpbnRlcm5cIiwgXCJsb25nXCIsIFwicmF3X2lucHV0XCIsIFwicmVkdWNlXCIsIFwicmVsb2FkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInVuaWNoclwiLCBcInVuaWNvZGVcIiwgXCJ4cmFuZ2VcIiwgXCJGYWxzZVwiLCBcIlRydWVcIiwgXCJOb25lXCJdKTtcbiAgICB2YXIgc3RyaW5nUHJlZml4ZXMgPSBuZXcgUmVnRXhwKFwiXigoW3J1YmZdfCh1cil8KGJyKSk/KCd7M318XFxcInszfXxbJ1xcXCJdKSlcIiwgXCJpXCIpO1xuICB9XG4gIHZhciBrZXl3b3JkcyA9IHdvcmRSZWdleHAobXlLZXl3b3Jkcyk7XG4gIHZhciBidWlsdGlucyA9IHdvcmRSZWdleHAobXlCdWlsdGlucyk7XG5cbiAgLy8gdG9rZW5pemVyc1xuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBzb2wgPSBzdHJlYW0uc29sKCkgJiYgc3RhdGUubGFzdFRva2VuICE9IFwiXFxcXFwiXG4gICAgaWYgKHNvbCkgc3RhdGUuaW5kZW50ID0gc3RyZWFtLmluZGVudGF0aW9uKClcbiAgICAvLyBIYW5kbGUgc2NvcGUgY2hhbmdlc1xuICAgIGlmIChzb2wgJiYgdG9wKHN0YXRlKS50eXBlID09IFwicHlcIikge1xuICAgICAgdmFyIHNjb3BlT2Zmc2V0ID0gdG9wKHN0YXRlKS5vZmZzZXQ7XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHtcbiAgICAgICAgdmFyIGxpbmVPZmZzZXQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICAgICAgaWYgKGxpbmVPZmZzZXQgPiBzY29wZU9mZnNldClcbiAgICAgICAgICBwdXNoUHlTY29wZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgZWxzZSBpZiAobGluZU9mZnNldCA8IHNjb3BlT2Zmc2V0ICYmIGRlZGVudChzdHJlYW0sIHN0YXRlKSAmJiBzdHJlYW0ucGVlaygpICE9IFwiI1wiKVxuICAgICAgICAgIHN0YXRlLmVycm9yVG9rZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRva2VuQmFzZUlubmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICBpZiAoc2NvcGVPZmZzZXQgPiAwICYmIGRlZGVudChzdHJlYW0sIHN0YXRlKSlcbiAgICAgICAgICBzdHlsZSArPSBcIiBcIiArIEVSUk9SQ0xBU1M7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRva2VuQmFzZUlubmVyKHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5CYXNlSW5uZXIoc3RyZWFtLCBzdGF0ZSwgaW5Gb3JtYXQpIHtcbiAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuXG4gICAgLy8gSGFuZGxlIENvbW1lbnRzXG4gICAgaWYgKCFpbkZvcm1hdCAmJiBzdHJlYW0ubWF0Y2goL14jLiovKSkgcmV0dXJuIFwiY29tbWVudFwiO1xuXG4gICAgLy8gSGFuZGxlIE51bWJlciBMaXRlcmFsc1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL15bMC05XFwuXS8sIGZhbHNlKSkge1xuICAgICAgdmFyIGZsb2F0TGl0ZXJhbCA9IGZhbHNlO1xuICAgICAgLy8gRmxvYXRzXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eW1xcZF9dKlxcLlxcZCsoZVtcXCtcXC1dP1xcZCspPy9pKSkgeyBmbG9hdExpdGVyYWwgPSB0cnVlOyB9XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eW1xcZF9dK1xcLlxcZCovKSkgeyBmbG9hdExpdGVyYWwgPSB0cnVlOyB9XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFwuXFxkKy8pKSB7IGZsb2F0TGl0ZXJhbCA9IHRydWU7IH1cbiAgICAgIGlmIChmbG9hdExpdGVyYWwpIHtcbiAgICAgICAgLy8gRmxvYXQgbGl0ZXJhbHMgbWF5IGJlIFwiaW1hZ2luYXJ5XCJcbiAgICAgICAgc3RyZWFtLmVhdCgvSi9pKTtcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICB9XG4gICAgICAvLyBJbnRlZ2Vyc1xuICAgICAgdmFyIGludExpdGVyYWwgPSBmYWxzZTtcbiAgICAgIC8vIEhleFxuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXjB4WzAtOWEtZl9dKy9pKSkgaW50TGl0ZXJhbCA9IHRydWU7XG4gICAgICAvLyBCaW5hcnlcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14wYlswMV9dKy9pKSkgaW50TGl0ZXJhbCA9IHRydWU7XG4gICAgICAvLyBPY3RhbFxuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXjBvWzAtN19dKy9pKSkgaW50TGl0ZXJhbCA9IHRydWU7XG4gICAgICAvLyBEZWNpbWFsXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eWzEtOV1bXFxkX10qKGVbXFwrXFwtXT9bXFxkX10rKT8vKSkge1xuICAgICAgICAvLyBEZWNpbWFsIGxpdGVyYWxzIG1heSBiZSBcImltYWdpbmFyeVwiXG4gICAgICAgIHN0cmVhbS5lYXQoL0ovaSk7XG4gICAgICAgIC8vIFRPRE8gLSBDYW4geW91IGhhdmUgaW1hZ2luYXJ5IGxvbmdzP1xuICAgICAgICBpbnRMaXRlcmFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFplcm8gYnkgaXRzZWxmIHdpdGggbm8gb3RoZXIgcGllY2Ugb2YgbnVtYmVyLlxuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXjAoPyFbXFxkeF0pL2kpKSBpbnRMaXRlcmFsID0gdHJ1ZTtcbiAgICAgIGlmIChpbnRMaXRlcmFsKSB7XG4gICAgICAgIC8vIEludGVnZXIgbGl0ZXJhbHMgbWF5IGJlIFwibG9uZ1wiXG4gICAgICAgIHN0cmVhbS5lYXQoL0wvaSk7XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBTdHJpbmdzXG4gICAgaWYgKHN0cmVhbS5tYXRjaChzdHJpbmdQcmVmaXhlcykpIHtcbiAgICAgIHZhciBpc0ZtdFN0cmluZyA9IHN0cmVhbS5jdXJyZW50KCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmJykgIT09IC0xO1xuICAgICAgaWYgKCFpc0ZtdFN0cmluZykge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nRmFjdG9yeShzdHJlYW0uY3VycmVudCgpLCBzdGF0ZS50b2tlbml6ZSk7XG4gICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gZm9ybWF0U3RyaW5nRmFjdG9yeShzdHJlYW0uY3VycmVudCgpLCBzdGF0ZS50b2tlbml6ZSk7XG4gICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wZXJhdG9ycy5sZW5ndGg7IGkrKylcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2gob3BlcmF0b3JzW2ldKSkgcmV0dXJuIFwib3BlcmF0b3JcIlxuXG4gICAgaWYgKHN0cmVhbS5tYXRjaChkZWxpbWl0ZXJzKSkgcmV0dXJuIFwicHVuY3R1YXRpb25cIjtcblxuICAgIGlmIChzdGF0ZS5sYXN0VG9rZW4gPT0gXCIuXCIgJiYgc3RyZWFtLm1hdGNoKGlkZW50aWZpZXJzKSlcbiAgICAgIHJldHVybiBcInByb3BlcnR5XCI7XG5cbiAgICBpZiAoc3RyZWFtLm1hdGNoKGtleXdvcmRzKSB8fCBzdHJlYW0ubWF0Y2god29yZE9wZXJhdG9ycykpXG4gICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG5cbiAgICBpZiAoc3RyZWFtLm1hdGNoKGJ1aWx0aW5zKSlcbiAgICAgIHJldHVybiBcImJ1aWx0aW5cIjtcblxuICAgIGlmIChzdHJlYW0ubWF0Y2goL14oc2VsZnxjbHMpXFxiLykpXG4gICAgICByZXR1cm4gXCJzZWxmXCI7XG5cbiAgICBpZiAoc3RyZWFtLm1hdGNoKGlkZW50aWZpZXJzKSkge1xuICAgICAgaWYgKHN0YXRlLmxhc3RUb2tlbiA9PSBcImRlZlwiIHx8IHN0YXRlLmxhc3RUb2tlbiA9PSBcImNsYXNzXCIpXG4gICAgICAgIHJldHVybiBcImRlZlwiO1xuICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgbm9uLWRldGVjdGVkIGl0ZW1zXG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICByZXR1cm4gaW5Gb3JtYXQgPyBudWxsIDpFUlJPUkNMQVNTO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0U3RyaW5nRmFjdG9yeShkZWxpbWl0ZXIsIHRva2VuT3V0ZXIpIHtcbiAgICB3aGlsZSAoXCJydWJmXCIuaW5kZXhPZihkZWxpbWl0ZXIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkpID49IDApXG4gICAgICBkZWxpbWl0ZXIgPSBkZWxpbWl0ZXIuc3Vic3RyKDEpO1xuXG4gICAgdmFyIHNpbmdsZWxpbmUgPSBkZWxpbWl0ZXIubGVuZ3RoID09IDE7XG4gICAgdmFyIE9VVENMQVNTID0gXCJzdHJpbmdcIjtcblxuICAgIGZ1bmN0aW9uIHRva2VuTmVzdGVkRXhwcihkZXB0aCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGlubmVyID0gdG9rZW5CYXNlSW5uZXIoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSlcbiAgICAgICAgaWYgKGlubmVyID09IFwicHVuY3R1YXRpb25cIikge1xuICAgICAgICAgIGlmIChzdHJlYW0uY3VycmVudCgpID09IFwie1wiKSB7XG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuTmVzdGVkRXhwcihkZXB0aCArIDEpXG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0uY3VycmVudCgpID09IFwifVwiKSB7XG4gICAgICAgICAgICBpZiAoZGVwdGggPiAxKSBzdGF0ZS50b2tlbml6ZSA9IHRva2VuTmVzdGVkRXhwcihkZXB0aCAtIDEpXG4gICAgICAgICAgICBlbHNlIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlubmVyXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9rZW5TdHJpbmcoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXidcIlxce1xcfVxcXFxdLyk7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFwiXFxcXFwiKSkge1xuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgaWYgKHNpbmdsZWxpbmUgJiYgc3RyZWFtLmVvbCgpKVxuICAgICAgICAgICAgcmV0dXJuIE9VVENMQVNTO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChkZWxpbWl0ZXIpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk91dGVyO1xuICAgICAgICAgIHJldHVybiBPVVRDTEFTUztcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goJ3t7JykpIHtcbiAgICAgICAgICAvLyBpZ25vcmUge3sgaW4gZi1zdHJcbiAgICAgICAgICByZXR1cm4gT1VUQ0xBU1M7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKCd7JywgZmFsc2UpKSB7XG4gICAgICAgICAgLy8gc3dpdGNoIHRvIG5lc3RlZCBtb2RlXG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk5lc3RlZEV4cHIoMClcbiAgICAgICAgICBpZiAoc3RyZWFtLmN1cnJlbnQoKSkgcmV0dXJuIE9VVENMQVNTO1xuICAgICAgICAgIGVsc2UgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpXG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKCd9fScpKSB7XG4gICAgICAgICAgcmV0dXJuIE9VVENMQVNTO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgnfScpKSB7XG4gICAgICAgICAgLy8gc2luZ2xlIH0gaW4gZi1zdHJpbmcgaXMgYW4gZXJyb3JcbiAgICAgICAgICByZXR1cm4gRVJST1JDTEFTUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW0uZWF0KC9bJ1wiXS8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2luZ2xlbGluZSkge1xuICAgICAgICBpZiAocGFyc2VyQ29uZi5zaW5nbGVMaW5lU3RyaW5nRXJyb3JzKVxuICAgICAgICAgIHJldHVybiBFUlJPUkNMQVNTO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk91dGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9VVENMQVNTO1xuICAgIH1cbiAgICB0b2tlblN0cmluZy5pc1N0cmluZyA9IHRydWU7XG4gICAgcmV0dXJuIHRva2VuU3RyaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmdGYWN0b3J5KGRlbGltaXRlciwgdG9rZW5PdXRlcikge1xuICAgIHdoaWxlIChcInJ1YmZcIi5pbmRleE9mKGRlbGltaXRlci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSkgPj0gMClcbiAgICAgIGRlbGltaXRlciA9IGRlbGltaXRlci5zdWJzdHIoMSk7XG5cbiAgICB2YXIgc2luZ2xlbGluZSA9IGRlbGltaXRlci5sZW5ndGggPT0gMTtcbiAgICB2YXIgT1VUQ0xBU1MgPSBcInN0cmluZ1wiO1xuXG4gICAgZnVuY3Rpb24gdG9rZW5TdHJpbmcoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXidcIlxcXFxdLyk7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFwiXFxcXFwiKSkge1xuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgaWYgKHNpbmdsZWxpbmUgJiYgc3RyZWFtLmVvbCgpKVxuICAgICAgICAgICAgcmV0dXJuIE9VVENMQVNTO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChkZWxpbWl0ZXIpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk91dGVyO1xuICAgICAgICAgIHJldHVybiBPVVRDTEFTUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW0uZWF0KC9bJ1wiXS8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2luZ2xlbGluZSkge1xuICAgICAgICBpZiAocGFyc2VyQ29uZi5zaW5nbGVMaW5lU3RyaW5nRXJyb3JzKVxuICAgICAgICAgIHJldHVybiBFUlJPUkNMQVNTO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk91dGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9VVENMQVNTO1xuICAgIH1cbiAgICB0b2tlblN0cmluZy5pc1N0cmluZyA9IHRydWU7XG4gICAgcmV0dXJuIHRva2VuU3RyaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaFB5U2NvcGUoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHdoaWxlICh0b3Aoc3RhdGUpLnR5cGUgIT0gXCJweVwiKSBzdGF0ZS5zY29wZXMucG9wKClcbiAgICBzdGF0ZS5zY29wZXMucHVzaCh7b2Zmc2V0OiB0b3Aoc3RhdGUpLm9mZnNldCArIHN0cmVhbS5pbmRlbnRVbml0LFxuICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInB5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgIGFsaWduOiBudWxsfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hCcmFja2V0U2NvcGUoc3RyZWFtLCBzdGF0ZSwgdHlwZSkge1xuICAgIHZhciBhbGlnbiA9IHN0cmVhbS5tYXRjaCgvXltcXHNcXFtcXHtcXChdKig/OiN8JCkvLCBmYWxzZSkgPyBudWxsIDogc3RyZWFtLmNvbHVtbigpICsgMVxuICAgIHN0YXRlLnNjb3Blcy5wdXNoKHtvZmZzZXQ6IHN0YXRlLmluZGVudCArIChoYW5naW5nSW5kZW50IHx8IHN0cmVhbS5pbmRlbnRVbml0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgYWxpZ246IGFsaWdufSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZGVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgd2hpbGUgKHN0YXRlLnNjb3Blcy5sZW5ndGggPiAxICYmIHRvcChzdGF0ZSkub2Zmc2V0ID4gaW5kZW50ZWQpIHtcbiAgICAgIGlmICh0b3Aoc3RhdGUpLnR5cGUgIT0gXCJweVwiKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHN0YXRlLnNjb3Blcy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvcChzdGF0ZSkub2Zmc2V0ICE9IGluZGVudGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5MZXhlcihzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgc3RhdGUuYmVnaW5uaW5nT2ZMaW5lID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmRlZGVudCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIHZhciBjdXJyZW50ID0gc3RyZWFtLmN1cnJlbnQoKTtcblxuICAgIC8vIEhhbmRsZSBkZWNvcmF0b3JzXG4gICAgaWYgKHN0YXRlLmJlZ2lubmluZ09mTGluZSAmJiBjdXJyZW50ID09IFwiQFwiKVxuICAgICAgcmV0dXJuIHN0cmVhbS5tYXRjaChpZGVudGlmaWVycywgZmFsc2UpID8gXCJtZXRhXCIgOiBweTMgPyBcIm9wZXJhdG9yXCIgOiBFUlJPUkNMQVNTO1xuXG4gICAgaWYgKC9cXFMvLnRlc3QoY3VycmVudCkpIHN0YXRlLmJlZ2lubmluZ09mTGluZSA9IGZhbHNlO1xuXG4gICAgaWYgKChzdHlsZSA9PSBcInZhcmlhYmxlXCIgfHwgc3R5bGUgPT0gXCJidWlsdGluXCIpXG4gICAgICAgICYmIHN0YXRlLmxhc3RUb2tlbiA9PSBcIm1ldGFcIilcbiAgICAgIHN0eWxlID0gXCJtZXRhXCI7XG5cbiAgICAvLyBIYW5kbGUgc2NvcGUgY2hhbmdlcy5cbiAgICBpZiAoY3VycmVudCA9PSBcInBhc3NcIiB8fCBjdXJyZW50ID09IFwicmV0dXJuXCIpXG4gICAgICBzdGF0ZS5kZWRlbnQgPSB0cnVlO1xuXG4gICAgaWYgKGN1cnJlbnQgPT0gXCJsYW1iZGFcIikgc3RhdGUubGFtYmRhID0gdHJ1ZTtcbiAgICBpZiAoY3VycmVudCA9PSBcIjpcIiAmJiAhc3RhdGUubGFtYmRhICYmIHRvcChzdGF0ZSkudHlwZSA9PSBcInB5XCIgJiYgc3RyZWFtLm1hdGNoKC9eXFxzKig/OiN8JCkvLCBmYWxzZSkpXG4gICAgICBwdXNoUHlTY29wZShzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmIChjdXJyZW50Lmxlbmd0aCA9PSAxICYmICEvc3RyaW5nfGNvbW1lbnQvLnRlc3Qoc3R5bGUpKSB7XG4gICAgICB2YXIgZGVsaW1pdGVyX2luZGV4ID0gXCJbKHtcIi5pbmRleE9mKGN1cnJlbnQpO1xuICAgICAgaWYgKGRlbGltaXRlcl9pbmRleCAhPSAtMSlcbiAgICAgICAgcHVzaEJyYWNrZXRTY29wZShzdHJlYW0sIHN0YXRlLCBcIl0pfVwiLnNsaWNlKGRlbGltaXRlcl9pbmRleCwgZGVsaW1pdGVyX2luZGV4KzEpKTtcblxuICAgICAgZGVsaW1pdGVyX2luZGV4ID0gXCJdKX1cIi5pbmRleE9mKGN1cnJlbnQpO1xuICAgICAgaWYgKGRlbGltaXRlcl9pbmRleCAhPSAtMSkge1xuICAgICAgICBpZiAodG9wKHN0YXRlKS50eXBlID09IGN1cnJlbnQpIHN0YXRlLmluZGVudCA9IHN0YXRlLnNjb3Blcy5wb3AoKS5vZmZzZXQgLSAoaGFuZ2luZ0luZGVudCB8fCBzdHJlYW0uaW5kZW50VW5pdClcbiAgICAgICAgZWxzZSByZXR1cm4gRVJST1JDTEFTUztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXRlLmRlZGVudCAmJiBzdHJlYW0uZW9sKCkgJiYgdG9wKHN0YXRlKS50eXBlID09IFwicHlcIiAmJiBzdGF0ZS5zY29wZXMubGVuZ3RoID4gMSlcbiAgICAgIHN0YXRlLnNjb3Blcy5wb3AoKTtcblxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogXCJweXRob25cIixcblxuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgICAgc2NvcGVzOiBbe29mZnNldDogMCwgdHlwZTogXCJweVwiLCBhbGlnbjogbnVsbH1dLFxuICAgICAgICBpbmRlbnQ6IDAsXG4gICAgICAgIGxhc3RUb2tlbjogbnVsbCxcbiAgICAgICAgbGFtYmRhOiBmYWxzZSxcbiAgICAgICAgZGVkZW50OiAwXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGFkZEVyciA9IHN0YXRlLmVycm9yVG9rZW47XG4gICAgICBpZiAoYWRkRXJyKSBzdGF0ZS5lcnJvclRva2VuID0gZmFsc2U7XG4gICAgICB2YXIgc3R5bGUgPSB0b2tlbkxleGVyKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgICBpZiAoc3R5bGUgJiYgc3R5bGUgIT0gXCJjb21tZW50XCIpXG4gICAgICAgIHN0YXRlLmxhc3RUb2tlbiA9IChzdHlsZSA9PSBcImtleXdvcmRcIiB8fCBzdHlsZSA9PSBcInB1bmN0dWF0aW9uXCIpID8gc3RyZWFtLmN1cnJlbnQoKSA6IHN0eWxlO1xuICAgICAgaWYgKHN0eWxlID09IFwicHVuY3R1YXRpb25cIikgc3R5bGUgPSBudWxsO1xuXG4gICAgICBpZiAoc3RyZWFtLmVvbCgpICYmIHN0YXRlLmxhbWJkYSlcbiAgICAgICAgc3RhdGUubGFtYmRhID0gZmFsc2U7XG4gICAgICByZXR1cm4gYWRkRXJyID8gRVJST1JDTEFTUyA6IHN0eWxlO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGN4KSB7XG4gICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gdG9rZW5CYXNlKVxuICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUuaXNTdHJpbmcgPyBudWxsIDogMDtcblxuICAgICAgdmFyIHNjb3BlID0gdG9wKHN0YXRlKVxuICAgICAgdmFyIGNsb3NpbmcgPSBzY29wZS50eXBlID09IHRleHRBZnRlci5jaGFyQXQoMCkgfHxcbiAgICAgICAgICBzY29wZS50eXBlID09IFwicHlcIiAmJiAhc3RhdGUuZGVkZW50ICYmIC9eKGVsc2U6fGVsaWYgfGV4Y2VwdCB8ZmluYWxseTopLy50ZXN0KHRleHRBZnRlcilcbiAgICAgIGlmIChzY29wZS5hbGlnbiAhPSBudWxsKVxuICAgICAgICByZXR1cm4gc2NvcGUuYWxpZ24gLSAoY2xvc2luZyA/IDEgOiAwKVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gc2NvcGUub2Zmc2V0IC0gKGNsb3NpbmcgPyBoYW5naW5nSW5kZW50IHx8IGN4LnVuaXQgOiAwKVxuICAgIH0sXG5cbiAgICBsYW5ndWFnZURhdGE6IHtcbiAgICAgIGF1dG9jb21wbGV0ZTogY29tbW9uS2V5d29yZHMuY29uY2F0KGNvbW1vbkJ1aWx0aW5zKS5jb25jYXQoW1wiZXhlY1wiLCBcInByaW50XCJdKSxcbiAgICAgIGluZGVudE9uSW5wdXQ6IC9eXFxzKihbXFx9XFxdXFwpXXxlbHNlOnxlbGlmIHxleGNlcHQgfGZpbmFsbHk6KSQvLFxuICAgICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiI1wifSxcbiAgICAgIGNsb3NlQnJhY2tldHM6IHticmFja2V0czogW1wiKFwiLCBcIltcIiwgXCJ7XCIsIFwiJ1wiLCAnXCInLCBcIicnJ1wiLCAnXCJcIlwiJ119XG4gICAgfVxuICB9O1xufTtcblxudmFyIHdvcmRzID0gZnVuY3Rpb24oc3RyKSB7IHJldHVybiBzdHIuc3BsaXQoXCIgXCIpOyB9O1xuXG5leHBvcnQgY29uc3QgcHl0aG9uID0gbWtQeXRob24oe30pXG5cbmV4cG9ydCBjb25zdCBjeXRob24gPSBta1B5dGhvbih7XG4gIGV4dHJhX2tleXdvcmRzOiB3b3JkcyhcImJ5IGNkZWYgY2ltcG9ydCBjcGRlZiBjdHlwZWRlZiBlbnVtIGV4Y2VwdCBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZXh0ZXJuIGdpbCBpbmNsdWRlIG5vZ2lsIHByb3BlcnR5IHB1YmxpYyBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmVhZG9ubHkgc3RydWN0IHVuaW9uIERFRiBJRiBFTElGIEVMU0VcIilcbn0pXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/legacy-modes/mode/python.js\n"));

/***/ })

}]);