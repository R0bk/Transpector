"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_codemirror_legacy-modes_mode_modelica_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/modelica.js":
/*!****************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/modelica.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"modelica\": function() { return /* binding */ modelica; }\n/* harmony export */ });\nfunction words(str) {\n  var obj = {}, words = str.split(\" \");\n  for (var i=0; i<words.length; ++i)\n    obj[words[i]] = true;\n  return obj;\n}\n\nvar keywords = words(\"algorithm and annotation assert block break class connect connector constant constrainedby der discrete each else elseif elsewhen encapsulated end enumeration equation expandable extends external false final flow for function if import impure in initial inner input loop model not operator or outer output package parameter partial protected public pure record redeclare replaceable return stream then true type when while within\")\nvar builtin = words(\"abs acos actualStream asin atan atan2 cardinality ceil cos cosh delay div edge exp floor getInstanceName homotopy inStream integer log log10 mod pre reinit rem semiLinear sign sin sinh spatialDistribution sqrt tan tanh\")\nvar atoms = words(\"Real Boolean Integer String\")\n\nvar completions = [].concat(Object.keys(keywords), Object.keys(builtin), Object.keys(atoms))\n\nvar isSingleOperatorChar = /[;=\\(:\\),{}.*<>+\\-\\/^\\[\\]]/;\nvar isDoubleOperatorChar = /(:=|<=|>=|==|<>|\\.\\+|\\.\\-|\\.\\*|\\.\\/|\\.\\^)/;\nvar isDigit = /[0-9]/;\nvar isNonDigit = /[_a-zA-Z]/;\n\nfunction tokenLineComment(stream, state) {\n  stream.skipToEnd();\n  state.tokenize = null;\n  return \"comment\";\n}\n\nfunction tokenBlockComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (maybeEnd && ch == \"/\") {\n      state.tokenize = null;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return \"comment\";\n}\n\nfunction tokenString(stream, state) {\n  var escaped = false, ch;\n  while ((ch = stream.next()) != null) {\n    if (ch == '\"' && !escaped) {\n      state.tokenize = null;\n      state.sol = false;\n      break;\n    }\n    escaped = !escaped && ch == \"\\\\\";\n  }\n\n  return \"string\";\n}\n\nfunction tokenIdent(stream, state) {\n  stream.eatWhile(isDigit);\n  while (stream.eat(isDigit) || stream.eat(isNonDigit)) { }\n\n\n  var cur = stream.current();\n\n  if(state.sol && (cur == \"package\" || cur == \"model\" || cur == \"when\" || cur == \"connector\")) state.level++;\n  else if(state.sol && cur == \"end\" && state.level > 0) state.level--;\n\n  state.tokenize = null;\n  state.sol = false;\n\n  if (keywords.propertyIsEnumerable(cur)) return \"keyword\";\n  else if (builtin.propertyIsEnumerable(cur)) return \"builtin\";\n  else if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n  else return \"variable\";\n}\n\nfunction tokenQIdent(stream, state) {\n  while (stream.eat(/[^']/)) { }\n\n  state.tokenize = null;\n  state.sol = false;\n\n  if(stream.eat(\"'\"))\n    return \"variable\";\n  else\n    return \"error\";\n}\n\nfunction tokenUnsignedNumber(stream, state) {\n  stream.eatWhile(isDigit);\n  if (stream.eat('.')) {\n    stream.eatWhile(isDigit);\n  }\n  if (stream.eat('e') || stream.eat('E')) {\n    if (!stream.eat('-'))\n      stream.eat('+');\n    stream.eatWhile(isDigit);\n  }\n\n  state.tokenize = null;\n  state.sol = false;\n  return \"number\";\n}\n\n// Interface\nconst modelica = {\n  name: \"modelica\",\n  startState: function() {\n    return {\n      tokenize: null,\n      level: 0,\n      sol: true\n    };\n  },\n\n  token: function(stream, state) {\n    if(state.tokenize != null) {\n      return state.tokenize(stream, state);\n    }\n\n    if(stream.sol()) {\n      state.sol = true;\n    }\n\n    // WHITESPACE\n    if(stream.eatSpace()) {\n      state.tokenize = null;\n      return null;\n    }\n\n    var ch = stream.next();\n\n    // LINECOMMENT\n    if(ch == '/' && stream.eat('/')) {\n      state.tokenize = tokenLineComment;\n    }\n    // BLOCKCOMMENT\n    else if(ch == '/' && stream.eat('*')) {\n      state.tokenize = tokenBlockComment;\n    }\n    // TWO SYMBOL TOKENS\n    else if(isDoubleOperatorChar.test(ch+stream.peek())) {\n      stream.next();\n      state.tokenize = null;\n      return \"operator\";\n    }\n    // SINGLE SYMBOL TOKENS\n    else if(isSingleOperatorChar.test(ch)) {\n      state.tokenize = null;\n      return \"operator\";\n    }\n    // IDENT\n    else if(isNonDigit.test(ch)) {\n      state.tokenize = tokenIdent;\n    }\n    // Q-IDENT\n    else if(ch == \"'\" && stream.peek() && stream.peek() != \"'\") {\n      state.tokenize = tokenQIdent;\n    }\n    // STRING\n    else if(ch == '\"') {\n      state.tokenize = tokenString;\n    }\n    // UNSIGNED_NUMBER\n    else if(isDigit.test(ch)) {\n      state.tokenize = tokenUnsignedNumber;\n    }\n    // ERROR\n    else {\n      state.tokenize = null;\n      return \"error\";\n    }\n\n    return state.tokenize(stream, state);\n  },\n\n  indent: function(state, textAfter, cx) {\n    if (state.tokenize != null) return null;\n\n    var level = state.level;\n    if(/(algorithm)/.test(textAfter)) level--;\n    if(/(equation)/.test(textAfter)) level--;\n    if(/(initial algorithm)/.test(textAfter)) level--;\n    if(/(initial equation)/.test(textAfter)) level--;\n    if(/(end)/.test(textAfter)) level--;\n\n    if(level > 0)\n      return cx.unit*level;\n    else\n      return 0;\n  },\n\n  languageData: {\n    commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}},\n    autocomplete: completions\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvbW9kZWxpY2EuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0EsY0FBYztBQUNkLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxvQkFBb0Isb0JBQW9CLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL21vZGVsaWNhLmpzPzA3NmYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gd29yZHMoc3RyKSB7XG4gIHZhciBvYmogPSB7fSwgd29yZHMgPSBzdHIuc3BsaXQoXCIgXCIpO1xuICBmb3IgKHZhciBpPTA7IGk8d29yZHMubGVuZ3RoOyArK2kpXG4gICAgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gIHJldHVybiBvYmo7XG59XG5cbnZhciBrZXl3b3JkcyA9IHdvcmRzKFwiYWxnb3JpdGhtIGFuZCBhbm5vdGF0aW9uIGFzc2VydCBibG9jayBicmVhayBjbGFzcyBjb25uZWN0IGNvbm5lY3RvciBjb25zdGFudCBjb25zdHJhaW5lZGJ5IGRlciBkaXNjcmV0ZSBlYWNoIGVsc2UgZWxzZWlmIGVsc2V3aGVuIGVuY2Fwc3VsYXRlZCBlbmQgZW51bWVyYXRpb24gZXF1YXRpb24gZXhwYW5kYWJsZSBleHRlbmRzIGV4dGVybmFsIGZhbHNlIGZpbmFsIGZsb3cgZm9yIGZ1bmN0aW9uIGlmIGltcG9ydCBpbXB1cmUgaW4gaW5pdGlhbCBpbm5lciBpbnB1dCBsb29wIG1vZGVsIG5vdCBvcGVyYXRvciBvciBvdXRlciBvdXRwdXQgcGFja2FnZSBwYXJhbWV0ZXIgcGFydGlhbCBwcm90ZWN0ZWQgcHVibGljIHB1cmUgcmVjb3JkIHJlZGVjbGFyZSByZXBsYWNlYWJsZSByZXR1cm4gc3RyZWFtIHRoZW4gdHJ1ZSB0eXBlIHdoZW4gd2hpbGUgd2l0aGluXCIpXG52YXIgYnVpbHRpbiA9IHdvcmRzKFwiYWJzIGFjb3MgYWN0dWFsU3RyZWFtIGFzaW4gYXRhbiBhdGFuMiBjYXJkaW5hbGl0eSBjZWlsIGNvcyBjb3NoIGRlbGF5IGRpdiBlZGdlIGV4cCBmbG9vciBnZXRJbnN0YW5jZU5hbWUgaG9tb3RvcHkgaW5TdHJlYW0gaW50ZWdlciBsb2cgbG9nMTAgbW9kIHByZSByZWluaXQgcmVtIHNlbWlMaW5lYXIgc2lnbiBzaW4gc2luaCBzcGF0aWFsRGlzdHJpYnV0aW9uIHNxcnQgdGFuIHRhbmhcIilcbnZhciBhdG9tcyA9IHdvcmRzKFwiUmVhbCBCb29sZWFuIEludGVnZXIgU3RyaW5nXCIpXG5cbnZhciBjb21wbGV0aW9ucyA9IFtdLmNvbmNhdChPYmplY3Qua2V5cyhrZXl3b3JkcyksIE9iamVjdC5rZXlzKGJ1aWx0aW4pLCBPYmplY3Qua2V5cyhhdG9tcykpXG5cbnZhciBpc1NpbmdsZU9wZXJhdG9yQ2hhciA9IC9bOz1cXCg6XFwpLHt9Lio8PitcXC1cXC9eXFxbXFxdXS87XG52YXIgaXNEb3VibGVPcGVyYXRvckNoYXIgPSAvKDo9fDw9fD49fD09fDw+fFxcLlxcK3xcXC5cXC18XFwuXFwqfFxcLlxcL3xcXC5cXF4pLztcbnZhciBpc0RpZ2l0ID0gL1swLTldLztcbnZhciBpc05vbkRpZ2l0ID0gL1tfYS16QS1aXS87XG5cbmZ1bmN0aW9uIHRva2VuTGluZUNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgcmV0dXJuIFwiY29tbWVudFwiO1xufVxuXG5mdW5jdGlvbiB0b2tlbkJsb2NrQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgIGlmIChtYXliZUVuZCAmJiBjaCA9PSBcIi9cIikge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgfVxuICByZXR1cm4gXCJjb21tZW50XCI7XG59XG5cbmZ1bmN0aW9uIHRva2VuU3RyaW5nKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgY2g7XG4gIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgaWYgKGNoID09ICdcIicgJiYgIWVzY2FwZWQpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgIHN0YXRlLnNvbCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBjaCA9PSBcIlxcXFxcIjtcbiAgfVxuXG4gIHJldHVybiBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiB0b2tlbklkZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLmVhdFdoaWxlKGlzRGlnaXQpO1xuICB3aGlsZSAoc3RyZWFtLmVhdChpc0RpZ2l0KSB8fCBzdHJlYW0uZWF0KGlzTm9uRGlnaXQpKSB7IH1cblxuXG4gIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpO1xuXG4gIGlmKHN0YXRlLnNvbCAmJiAoY3VyID09IFwicGFja2FnZVwiIHx8IGN1ciA9PSBcIm1vZGVsXCIgfHwgY3VyID09IFwid2hlblwiIHx8IGN1ciA9PSBcImNvbm5lY3RvclwiKSkgc3RhdGUubGV2ZWwrKztcbiAgZWxzZSBpZihzdGF0ZS5zb2wgJiYgY3VyID09IFwiZW5kXCIgJiYgc3RhdGUubGV2ZWwgPiAwKSBzdGF0ZS5sZXZlbC0tO1xuXG4gIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgc3RhdGUuc29sID0gZmFsc2U7XG5cbiAgaWYgKGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHJldHVybiBcImtleXdvcmRcIjtcbiAgZWxzZSBpZiAoYnVpbHRpbi5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJidWlsdGluXCI7XG4gIGVsc2UgaWYgKGF0b21zLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHJldHVybiBcImF0b21cIjtcbiAgZWxzZSByZXR1cm4gXCJ2YXJpYWJsZVwiO1xufVxuXG5mdW5jdGlvbiB0b2tlblFJZGVudChzdHJlYW0sIHN0YXRlKSB7XG4gIHdoaWxlIChzdHJlYW0uZWF0KC9bXiddLykpIHsgfVxuXG4gIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgc3RhdGUuc29sID0gZmFsc2U7XG5cbiAgaWYoc3RyZWFtLmVhdChcIidcIikpXG4gICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgZWxzZVxuICAgIHJldHVybiBcImVycm9yXCI7XG59XG5cbmZ1bmN0aW9uIHRva2VuVW5zaWduZWROdW1iZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uZWF0V2hpbGUoaXNEaWdpdCk7XG4gIGlmIChzdHJlYW0uZWF0KCcuJykpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoaXNEaWdpdCk7XG4gIH1cbiAgaWYgKHN0cmVhbS5lYXQoJ2UnKSB8fCBzdHJlYW0uZWF0KCdFJykpIHtcbiAgICBpZiAoIXN0cmVhbS5lYXQoJy0nKSlcbiAgICAgIHN0cmVhbS5lYXQoJysnKTtcbiAgICBzdHJlYW0uZWF0V2hpbGUoaXNEaWdpdCk7XG4gIH1cblxuICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gIHN0YXRlLnNvbCA9IGZhbHNlO1xuICByZXR1cm4gXCJudW1iZXJcIjtcbn1cblxuLy8gSW50ZXJmYWNlXG5leHBvcnQgY29uc3QgbW9kZWxpY2EgPSB7XG4gIG5hbWU6IFwibW9kZWxpY2FcIixcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuaXplOiBudWxsLFxuICAgICAgbGV2ZWw6IDAsXG4gICAgICBzb2w6IHRydWVcbiAgICB9O1xuICB9LFxuXG4gIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYoc3RhdGUudG9rZW5pemUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmKHN0cmVhbS5zb2woKSkge1xuICAgICAgc3RhdGUuc29sID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBXSElURVNQQUNFXG4gICAgaWYoc3RyZWFtLmVhdFNwYWNlKCkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cbiAgICAvLyBMSU5FQ09NTUVOVFxuICAgIGlmKGNoID09ICcvJyAmJiBzdHJlYW0uZWF0KCcvJykpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5MaW5lQ29tbWVudDtcbiAgICB9XG4gICAgLy8gQkxPQ0tDT01NRU5UXG4gICAgZWxzZSBpZihjaCA9PSAnLycgJiYgc3RyZWFtLmVhdCgnKicpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmxvY2tDb21tZW50O1xuICAgIH1cbiAgICAvLyBUV08gU1lNQk9MIFRPS0VOU1xuICAgIGVsc2UgaWYoaXNEb3VibGVPcGVyYXRvckNoYXIudGVzdChjaCtzdHJlYW0ucGVlaygpKSkge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgfVxuICAgIC8vIFNJTkdMRSBTWU1CT0wgVE9LRU5TXG4gICAgZWxzZSBpZihpc1NpbmdsZU9wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9XG4gICAgLy8gSURFTlRcbiAgICBlbHNlIGlmKGlzTm9uRGlnaXQudGVzdChjaCkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5JZGVudDtcbiAgICB9XG4gICAgLy8gUS1JREVOVFxuICAgIGVsc2UgaWYoY2ggPT0gXCInXCIgJiYgc3RyZWFtLnBlZWsoKSAmJiBzdHJlYW0ucGVlaygpICE9IFwiJ1wiKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuUUlkZW50O1xuICAgIH1cbiAgICAvLyBTVFJJTkdcbiAgICBlbHNlIGlmKGNoID09ICdcIicpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmc7XG4gICAgfVxuICAgIC8vIFVOU0lHTkVEX05VTUJFUlxuICAgIGVsc2UgaWYoaXNEaWdpdC50ZXN0KGNoKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblVuc2lnbmVkTnVtYmVyO1xuICAgIH1cbiAgICAvLyBFUlJPUlxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgcmV0dXJuIFwiZXJyb3JcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0sXG5cbiAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBjeCkge1xuICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBsZXZlbCA9IHN0YXRlLmxldmVsO1xuICAgIGlmKC8oYWxnb3JpdGhtKS8udGVzdCh0ZXh0QWZ0ZXIpKSBsZXZlbC0tO1xuICAgIGlmKC8oZXF1YXRpb24pLy50ZXN0KHRleHRBZnRlcikpIGxldmVsLS07XG4gICAgaWYoLyhpbml0aWFsIGFsZ29yaXRobSkvLnRlc3QodGV4dEFmdGVyKSkgbGV2ZWwtLTtcbiAgICBpZigvKGluaXRpYWwgZXF1YXRpb24pLy50ZXN0KHRleHRBZnRlcikpIGxldmVsLS07XG4gICAgaWYoLyhlbmQpLy50ZXN0KHRleHRBZnRlcikpIGxldmVsLS07XG5cbiAgICBpZihsZXZlbCA+IDApXG4gICAgICByZXR1cm4gY3gudW5pdCpsZXZlbDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gMDtcbiAgfSxcblxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjb21tZW50VG9rZW5zOiB7bGluZTogXCIvL1wiLCBibG9jazoge29wZW46IFwiLypcIiwgY2xvc2U6IFwiKi9cIn19LFxuICAgIGF1dG9jb21wbGV0ZTogY29tcGxldGlvbnNcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/legacy-modes/mode/modelica.js\n"));

/***/ })

}]);