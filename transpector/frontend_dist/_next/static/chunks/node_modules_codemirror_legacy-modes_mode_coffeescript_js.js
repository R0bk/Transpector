"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_codemirror_legacy-modes_mode_coffeescript_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/coffeescript.js":
/*!********************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/coffeescript.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"coffeeScript\": function() { return /* binding */ coffeeScript; }\n/* harmony export */ });\nvar ERRORCLASS = \"error\";\n\nfunction wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\n\nvar operators = /^(?:->|=>|\\+[+=]?|-[\\-=]?|\\*[\\*=]?|\\/[\\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\\|=?|\\^=?|\\~|!|\\?|(or|and|\\|\\||&&|\\?)=)/;\nvar delimiters = /^(?:[()\\[\\]{},:`=;]|\\.\\.?\\.?)/;\nvar identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;\nvar atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;\n\nvar wordOperators = wordRegexp([\"and\", \"or\", \"not\",\n                                \"is\", \"isnt\", \"in\",\n                                \"instanceof\", \"typeof\"]);\nvar indentKeywords = [\"for\", \"while\", \"loop\", \"if\", \"unless\", \"else\",\n                      \"switch\", \"try\", \"catch\", \"finally\", \"class\"];\nvar commonKeywords = [\"break\", \"by\", \"continue\", \"debugger\", \"delete\",\n                      \"do\", \"in\", \"of\", \"new\", \"return\", \"then\",\n                      \"this\", \"@\", \"throw\", \"when\", \"until\", \"extends\"];\n\nvar keywords = wordRegexp(indentKeywords.concat(commonKeywords));\n\nindentKeywords = wordRegexp(indentKeywords);\n\n\nvar stringPrefixes = /^('{3}|\\\"{3}|['\\\"])/;\nvar regexPrefixes = /^(\\/{3}|\\/)/;\nvar commonConstants = [\"Infinity\", \"NaN\", \"undefined\", \"null\", \"true\", \"false\", \"on\", \"off\", \"yes\", \"no\"];\nvar constants = wordRegexp(commonConstants);\n\n// Tokenizers\nfunction tokenBase(stream, state) {\n  // Handle scope changes\n  if (stream.sol()) {\n    if (state.scope.align === null) state.scope.align = false;\n    var scopeOffset = state.scope.offset;\n    if (stream.eatSpace()) {\n      var lineOffset = stream.indentation();\n      if (lineOffset > scopeOffset && state.scope.type == \"coffee\") {\n        return \"indent\";\n      } else if (lineOffset < scopeOffset) {\n        return \"dedent\";\n      }\n      return null;\n    } else {\n      if (scopeOffset > 0) {\n        dedent(stream, state);\n      }\n    }\n  }\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  var ch = stream.peek();\n\n  // Handle docco title comment (single line)\n  if (stream.match(\"####\")) {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  // Handle multi line comments\n  if (stream.match(\"###\")) {\n    state.tokenize = longComment;\n    return state.tokenize(stream, state);\n  }\n\n  // Single line comment\n  if (ch === \"#\") {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  // Handle number literals\n  if (stream.match(/^-?[0-9\\.]/, false)) {\n    var floatLiteral = false;\n    // Floats\n    if (stream.match(/^-?\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n      floatLiteral = true;\n    }\n    if (stream.match(/^-?\\d+\\.\\d*/)) {\n      floatLiteral = true;\n    }\n    if (stream.match(/^-?\\.\\d+/)) {\n      floatLiteral = true;\n    }\n\n    if (floatLiteral) {\n      // prevent from getting extra . on 1..\n      if (stream.peek() == \".\"){\n        stream.backUp(1);\n      }\n      return \"number\";\n    }\n    // Integers\n    var intLiteral = false;\n    // Hex\n    if (stream.match(/^-?0x[0-9a-f]+/i)) {\n      intLiteral = true;\n    }\n    // Decimal\n    if (stream.match(/^-?[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n      intLiteral = true;\n    }\n    // Zero by itself with no other piece of number.\n    if (stream.match(/^-?0(?![\\dx])/i)) {\n      intLiteral = true;\n    }\n    if (intLiteral) {\n      return \"number\";\n    }\n  }\n\n  // Handle strings\n  if (stream.match(stringPrefixes)) {\n    state.tokenize = tokenFactory(stream.current(), false, \"string\");\n    return state.tokenize(stream, state);\n  }\n  // Handle regex literals\n  if (stream.match(regexPrefixes)) {\n    if (stream.current() != \"/\" || stream.match(/^.*\\//, false)) { // prevent highlight of division\n      state.tokenize = tokenFactory(stream.current(), true, \"string.special\");\n      return state.tokenize(stream, state);\n    } else {\n      stream.backUp(1);\n    }\n  }\n\n\n\n  // Handle operators and delimiters\n  if (stream.match(operators) || stream.match(wordOperators)) {\n    return \"operator\";\n  }\n  if (stream.match(delimiters)) {\n    return \"punctuation\";\n  }\n\n  if (stream.match(constants)) {\n    return \"atom\";\n  }\n\n  if (stream.match(atProp) || state.prop && stream.match(identifiers)) {\n    return \"property\";\n  }\n\n  if (stream.match(keywords)) {\n    return \"keyword\";\n  }\n\n  if (stream.match(identifiers)) {\n    return \"variable\";\n  }\n\n  // Handle non-detected items\n  stream.next();\n  return ERRORCLASS;\n}\n\nfunction tokenFactory(delimiter, singleline, outclass) {\n  return function(stream, state) {\n    while (!stream.eol()) {\n      stream.eatWhile(/[^'\"\\/\\\\]/);\n      if (stream.eat(\"\\\\\")) {\n        stream.next();\n        if (singleline && stream.eol()) {\n          return outclass;\n        }\n      } else if (stream.match(delimiter)) {\n        state.tokenize = tokenBase;\n        return outclass;\n      } else {\n        stream.eat(/['\"\\/]/);\n      }\n    }\n    if (singleline) {\n      state.tokenize = tokenBase;\n    }\n    return outclass;\n  };\n}\n\nfunction longComment(stream, state) {\n  while (!stream.eol()) {\n    stream.eatWhile(/[^#]/);\n    if (stream.match(\"###\")) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    stream.eatWhile(\"#\");\n  }\n  return \"comment\";\n}\n\nfunction indent(stream, state, type = \"coffee\") {\n  var offset = 0, align = false, alignOffset = null;\n  for (var scope = state.scope; scope; scope = scope.prev) {\n    if (scope.type === \"coffee\" || scope.type == \"}\") {\n      offset = scope.offset + stream.indentUnit;\n      break;\n    }\n  }\n  if (type !== \"coffee\") {\n    align = null;\n    alignOffset = stream.column() + stream.current().length;\n  } else if (state.scope.align) {\n    state.scope.align = false;\n  }\n  state.scope = {\n    offset: offset,\n    type: type,\n    prev: state.scope,\n    align: align,\n    alignOffset: alignOffset\n  };\n}\n\nfunction dedent(stream, state) {\n  if (!state.scope.prev) return;\n  if (state.scope.type === \"coffee\") {\n    var _indent = stream.indentation();\n    var matched = false;\n    for (var scope = state.scope; scope; scope = scope.prev) {\n      if (_indent === scope.offset) {\n        matched = true;\n        break;\n      }\n    }\n    if (!matched) {\n      return true;\n    }\n    while (state.scope.prev && state.scope.offset !== _indent) {\n      state.scope = state.scope.prev;\n    }\n    return false;\n  } else {\n    state.scope = state.scope.prev;\n    return false;\n  }\n}\n\nfunction tokenLexer(stream, state) {\n  var style = state.tokenize(stream, state);\n  var current = stream.current();\n\n  // Handle scope changes.\n  if (current === \"return\") {\n    state.dedent = true;\n  }\n  if (((current === \"->\" || current === \"=>\") && stream.eol())\n      || style === \"indent\") {\n    indent(stream, state);\n  }\n  var delimiter_index = \"[({\".indexOf(current);\n  if (delimiter_index !== -1) {\n    indent(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n  }\n  if (indentKeywords.exec(current)){\n    indent(stream, state);\n  }\n  if (current == \"then\"){\n    dedent(stream, state);\n  }\n\n\n  if (style === \"dedent\") {\n    if (dedent(stream, state)) {\n      return ERRORCLASS;\n    }\n  }\n  delimiter_index = \"])}\".indexOf(current);\n  if (delimiter_index !== -1) {\n    while (state.scope.type == \"coffee\" && state.scope.prev)\n      state.scope = state.scope.prev;\n    if (state.scope.type == current)\n      state.scope = state.scope.prev;\n  }\n  if (state.dedent && stream.eol()) {\n    if (state.scope.type == \"coffee\" && state.scope.prev)\n      state.scope = state.scope.prev;\n    state.dedent = false;\n  }\n\n  return style == \"indent\" || style == \"dedent\" ? null : style;\n}\n\nconst coffeeScript = {\n  name: \"coffeescript\",\n  startState: function() {\n    return {\n      tokenize: tokenBase,\n      scope: {offset: 0, type:\"coffee\", prev: null, align: false},\n      prop: false,\n      dedent: 0\n    };\n  },\n\n  token: function(stream, state) {\n    var fillAlign = state.scope.align === null && state.scope;\n    if (fillAlign && stream.sol()) fillAlign.align = false;\n\n    var style = tokenLexer(stream, state);\n    if (style && style != \"comment\") {\n      if (fillAlign) fillAlign.align = true;\n      state.prop = style == \"punctuation\" && stream.current() == \".\"\n    }\n\n    return style;\n  },\n\n  indent: function(state, text) {\n    if (state.tokenize != tokenBase) return 0;\n    var scope = state.scope;\n    var closer = text && \"])}\".indexOf(text.charAt(0)) > -1;\n    if (closer) while (scope.type == \"coffee\" && scope.prev) scope = scope.prev;\n    var closes = closer && scope.type === text.charAt(0);\n    if (scope.align)\n      return scope.alignOffset - (closes ? 1 : 0);\n    else\n      return (closes ? scope.prev : scope).offset;\n  },\n\n  languageData: {\n    commentTokens: {line: \"#\"}\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvY29mZmVlc2NyaXB0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLDBCQUEwQixFQUFFLElBQUksRUFBRTtBQUNsQywwQkFBMEIsRUFBRTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QyxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbURBQW1EO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL2NvZmZlZXNjcmlwdC5qcz9lMTBhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBFUlJPUkNMQVNTID0gXCJlcnJvclwiO1xuXG5mdW5jdGlvbiB3b3JkUmVnZXhwKHdvcmRzKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXigoXCIgKyB3b3Jkcy5qb2luKFwiKXwoXCIpICsgXCIpKVxcXFxiXCIpO1xufVxuXG52YXIgb3BlcmF0b3JzID0gL14oPzotPnw9PnxcXCtbKz1dP3wtW1xcLT1dP3xcXCpbXFwqPV0/fFxcL1tcXC89XT98Wz0hXT18PFs+PF0/PT98Pj4/PT98JT0/fCY9P3xcXHw9P3xcXF49P3xcXH58IXxcXD98KG9yfGFuZHxcXHxcXHx8JiZ8XFw/KT0pLztcbnZhciBkZWxpbWl0ZXJzID0gL14oPzpbKClcXFtcXF17fSw6YD07XXxcXC5cXC4/XFwuPykvO1xudmFyIGlkZW50aWZpZXJzID0gL15bX0EtWmEteiRdW19BLVphLXokMC05XSovO1xudmFyIGF0UHJvcCA9IC9eQFtfQS1aYS16JF1bX0EtWmEteiQwLTldKi87XG5cbnZhciB3b3JkT3BlcmF0b3JzID0gd29yZFJlZ2V4cChbXCJhbmRcIiwgXCJvclwiLCBcIm5vdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlzXCIsIFwiaXNudFwiLCBcImluXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW5zdGFuY2VvZlwiLCBcInR5cGVvZlwiXSk7XG52YXIgaW5kZW50S2V5d29yZHMgPSBbXCJmb3JcIiwgXCJ3aGlsZVwiLCBcImxvb3BcIiwgXCJpZlwiLCBcInVubGVzc1wiLCBcImVsc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICBcInN3aXRjaFwiLCBcInRyeVwiLCBcImNhdGNoXCIsIFwiZmluYWxseVwiLCBcImNsYXNzXCJdO1xudmFyIGNvbW1vbktleXdvcmRzID0gW1wiYnJlYWtcIiwgXCJieVwiLCBcImNvbnRpbnVlXCIsIFwiZGVidWdnZXJcIiwgXCJkZWxldGVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcImRvXCIsIFwiaW5cIiwgXCJvZlwiLCBcIm5ld1wiLCBcInJldHVyblwiLCBcInRoZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICBcInRoaXNcIiwgXCJAXCIsIFwidGhyb3dcIiwgXCJ3aGVuXCIsIFwidW50aWxcIiwgXCJleHRlbmRzXCJdO1xuXG52YXIga2V5d29yZHMgPSB3b3JkUmVnZXhwKGluZGVudEtleXdvcmRzLmNvbmNhdChjb21tb25LZXl3b3JkcykpO1xuXG5pbmRlbnRLZXl3b3JkcyA9IHdvcmRSZWdleHAoaW5kZW50S2V5d29yZHMpO1xuXG5cbnZhciBzdHJpbmdQcmVmaXhlcyA9IC9eKCd7M318XFxcInszfXxbJ1xcXCJdKS87XG52YXIgcmVnZXhQcmVmaXhlcyA9IC9eKFxcL3szfXxcXC8pLztcbnZhciBjb21tb25Db25zdGFudHMgPSBbXCJJbmZpbml0eVwiLCBcIk5hTlwiLCBcInVuZGVmaW5lZFwiLCBcIm51bGxcIiwgXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJvblwiLCBcIm9mZlwiLCBcInllc1wiLCBcIm5vXCJdO1xudmFyIGNvbnN0YW50cyA9IHdvcmRSZWdleHAoY29tbW9uQ29uc3RhbnRzKTtcblxuLy8gVG9rZW5pemVyc1xuZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gSGFuZGxlIHNjb3BlIGNoYW5nZXNcbiAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgIGlmIChzdGF0ZS5zY29wZS5hbGlnbiA9PT0gbnVsbCkgc3RhdGUuc2NvcGUuYWxpZ24gPSBmYWxzZTtcbiAgICB2YXIgc2NvcGVPZmZzZXQgPSBzdGF0ZS5zY29wZS5vZmZzZXQ7XG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7XG4gICAgICB2YXIgbGluZU9mZnNldCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgICAgaWYgKGxpbmVPZmZzZXQgPiBzY29wZU9mZnNldCAmJiBzdGF0ZS5zY29wZS50eXBlID09IFwiY29mZmVlXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiaW5kZW50XCI7XG4gICAgICB9IGVsc2UgaWYgKGxpbmVPZmZzZXQgPCBzY29wZU9mZnNldCkge1xuICAgICAgICByZXR1cm4gXCJkZWRlbnRcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2NvcGVPZmZzZXQgPiAwKSB7XG4gICAgICAgIGRlZGVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY2ggPSBzdHJlYW0ucGVlaygpO1xuXG4gIC8vIEhhbmRsZSBkb2NjbyB0aXRsZSBjb21tZW50IChzaW5nbGUgbGluZSlcbiAgaWYgKHN0cmVhbS5tYXRjaChcIiMjIyNcIikpIHtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9XG5cbiAgLy8gSGFuZGxlIG11bHRpIGxpbmUgY29tbWVudHNcbiAgaWYgKHN0cmVhbS5tYXRjaChcIiMjI1wiKSkge1xuICAgIHN0YXRlLnRva2VuaXplID0gbG9uZ0NvbW1lbnQ7XG4gICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cbiAgLy8gU2luZ2xlIGxpbmUgY29tbWVudFxuICBpZiAoY2ggPT09IFwiI1wiKSB7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuXG4gIC8vIEhhbmRsZSBudW1iZXIgbGl0ZXJhbHNcbiAgaWYgKHN0cmVhbS5tYXRjaCgvXi0/WzAtOVxcLl0vLCBmYWxzZSkpIHtcbiAgICB2YXIgZmxvYXRMaXRlcmFsID0gZmFsc2U7XG4gICAgLy8gRmxvYXRzXG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXi0/XFxkKlxcLlxcZCsoZVtcXCtcXC1dP1xcZCspPy9pKSkge1xuICAgICAgZmxvYXRMaXRlcmFsID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXi0/XFxkK1xcLlxcZCovKSkge1xuICAgICAgZmxvYXRMaXRlcmFsID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXi0/XFwuXFxkKy8pKSB7XG4gICAgICBmbG9hdExpdGVyYWwgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChmbG9hdExpdGVyYWwpIHtcbiAgICAgIC8vIHByZXZlbnQgZnJvbSBnZXR0aW5nIGV4dHJhIC4gb24gMS4uXG4gICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PSBcIi5cIil7XG4gICAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG4gICAgLy8gSW50ZWdlcnNcbiAgICB2YXIgaW50TGl0ZXJhbCA9IGZhbHNlO1xuICAgIC8vIEhleFxuICAgIGlmIChzdHJlYW0ubWF0Y2goL14tPzB4WzAtOWEtZl0rL2kpKSB7XG4gICAgICBpbnRMaXRlcmFsID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gRGVjaW1hbFxuICAgIGlmIChzdHJlYW0ubWF0Y2goL14tP1sxLTldXFxkKihlW1xcK1xcLV0/XFxkKyk/LykpIHtcbiAgICAgIGludExpdGVyYWwgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBaZXJvIGJ5IGl0c2VsZiB3aXRoIG5vIG90aGVyIHBpZWNlIG9mIG51bWJlci5cbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eLT8wKD8hW1xcZHhdKS9pKSkge1xuICAgICAgaW50TGl0ZXJhbCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpbnRMaXRlcmFsKSB7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgc3RyaW5nc1xuICBpZiAoc3RyZWFtLm1hdGNoKHN0cmluZ1ByZWZpeGVzKSkge1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5GYWN0b3J5KHN0cmVhbS5jdXJyZW50KCksIGZhbHNlLCBcInN0cmluZ1wiKTtcbiAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgLy8gSGFuZGxlIHJlZ2V4IGxpdGVyYWxzXG4gIGlmIChzdHJlYW0ubWF0Y2gocmVnZXhQcmVmaXhlcykpIHtcbiAgICBpZiAoc3RyZWFtLmN1cnJlbnQoKSAhPSBcIi9cIiB8fCBzdHJlYW0ubWF0Y2goL14uKlxcLy8sIGZhbHNlKSkgeyAvLyBwcmV2ZW50IGhpZ2hsaWdodCBvZiBkaXZpc2lvblxuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkZhY3Rvcnkoc3RyZWFtLmN1cnJlbnQoKSwgdHJ1ZSwgXCJzdHJpbmcuc3BlY2lhbFwiKTtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICB9XG4gIH1cblxuXG5cbiAgLy8gSGFuZGxlIG9wZXJhdG9ycyBhbmQgZGVsaW1pdGVyc1xuICBpZiAoc3RyZWFtLm1hdGNoKG9wZXJhdG9ycykgfHwgc3RyZWFtLm1hdGNoKHdvcmRPcGVyYXRvcnMpKSB7XG4gICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgfVxuICBpZiAoc3RyZWFtLm1hdGNoKGRlbGltaXRlcnMpKSB7XG4gICAgcmV0dXJuIFwicHVuY3R1YXRpb25cIjtcbiAgfVxuXG4gIGlmIChzdHJlYW0ubWF0Y2goY29uc3RhbnRzKSkge1xuICAgIHJldHVybiBcImF0b21cIjtcbiAgfVxuXG4gIGlmIChzdHJlYW0ubWF0Y2goYXRQcm9wKSB8fCBzdGF0ZS5wcm9wICYmIHN0cmVhbS5tYXRjaChpZGVudGlmaWVycykpIHtcbiAgICByZXR1cm4gXCJwcm9wZXJ0eVwiO1xuICB9XG5cbiAgaWYgKHN0cmVhbS5tYXRjaChrZXl3b3JkcykpIHtcbiAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gIH1cblxuICBpZiAoc3RyZWFtLm1hdGNoKGlkZW50aWZpZXJzKSkge1xuICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gIH1cblxuICAvLyBIYW5kbGUgbm9uLWRldGVjdGVkIGl0ZW1zXG4gIHN0cmVhbS5uZXh0KCk7XG4gIHJldHVybiBFUlJPUkNMQVNTO1xufVxuXG5mdW5jdGlvbiB0b2tlbkZhY3RvcnkoZGVsaW1pdGVyLCBzaW5nbGVsaW5lLCBvdXRjbGFzcykge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1teJ1wiXFwvXFxcXF0vKTtcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiXFxcXFwiKSkge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICBpZiAoc2luZ2xlbGluZSAmJiBzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICByZXR1cm4gb3V0Y2xhc3M7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKGRlbGltaXRlcikpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIHJldHVybiBvdXRjbGFzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lYXQoL1snXCJcXC9dLyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaW5nbGVsaW5lKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICB9XG4gICAgcmV0dXJuIG91dGNsYXNzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBsb25nQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXiNdLyk7XG4gICAgaWYgKHN0cmVhbS5tYXRjaChcIiMjI1wiKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc3RyZWFtLmVhdFdoaWxlKFwiI1wiKTtcbiAgfVxuICByZXR1cm4gXCJjb21tZW50XCI7XG59XG5cbmZ1bmN0aW9uIGluZGVudChzdHJlYW0sIHN0YXRlLCB0eXBlID0gXCJjb2ZmZWVcIikge1xuICB2YXIgb2Zmc2V0ID0gMCwgYWxpZ24gPSBmYWxzZSwgYWxpZ25PZmZzZXQgPSBudWxsO1xuICBmb3IgKHZhciBzY29wZSA9IHN0YXRlLnNjb3BlOyBzY29wZTsgc2NvcGUgPSBzY29wZS5wcmV2KSB7XG4gICAgaWYgKHNjb3BlLnR5cGUgPT09IFwiY29mZmVlXCIgfHwgc2NvcGUudHlwZSA9PSBcIn1cIikge1xuICAgICAgb2Zmc2V0ID0gc2NvcGUub2Zmc2V0ICsgc3RyZWFtLmluZGVudFVuaXQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGUgIT09IFwiY29mZmVlXCIpIHtcbiAgICBhbGlnbiA9IG51bGw7XG4gICAgYWxpZ25PZmZzZXQgPSBzdHJlYW0uY29sdW1uKCkgKyBzdHJlYW0uY3VycmVudCgpLmxlbmd0aDtcbiAgfSBlbHNlIGlmIChzdGF0ZS5zY29wZS5hbGlnbikge1xuICAgIHN0YXRlLnNjb3BlLmFsaWduID0gZmFsc2U7XG4gIH1cbiAgc3RhdGUuc2NvcGUgPSB7XG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgdHlwZTogdHlwZSxcbiAgICBwcmV2OiBzdGF0ZS5zY29wZSxcbiAgICBhbGlnbjogYWxpZ24sXG4gICAgYWxpZ25PZmZzZXQ6IGFsaWduT2Zmc2V0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlZGVudChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUuc2NvcGUucHJldikgcmV0dXJuO1xuICBpZiAoc3RhdGUuc2NvcGUudHlwZSA9PT0gXCJjb2ZmZWVcIikge1xuICAgIHZhciBfaW5kZW50ID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgdmFyIG1hdGNoZWQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBzY29wZSA9IHN0YXRlLnNjb3BlOyBzY29wZTsgc2NvcGUgPSBzY29wZS5wcmV2KSB7XG4gICAgICBpZiAoX2luZGVudCA9PT0gc2NvcGUub2Zmc2V0KSB7XG4gICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgd2hpbGUgKHN0YXRlLnNjb3BlLnByZXYgJiYgc3RhdGUuc2NvcGUub2Zmc2V0ICE9PSBfaW5kZW50KSB7XG4gICAgICBzdGF0ZS5zY29wZSA9IHN0YXRlLnNjb3BlLnByZXY7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5zY29wZSA9IHN0YXRlLnNjb3BlLnByZXY7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRva2VuTGV4ZXIoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgdmFyIGN1cnJlbnQgPSBzdHJlYW0uY3VycmVudCgpO1xuXG4gIC8vIEhhbmRsZSBzY29wZSBjaGFuZ2VzLlxuICBpZiAoY3VycmVudCA9PT0gXCJyZXR1cm5cIikge1xuICAgIHN0YXRlLmRlZGVudCA9IHRydWU7XG4gIH1cbiAgaWYgKCgoY3VycmVudCA9PT0gXCItPlwiIHx8IGN1cnJlbnQgPT09IFwiPT5cIikgJiYgc3RyZWFtLmVvbCgpKVxuICAgICAgfHwgc3R5bGUgPT09IFwiaW5kZW50XCIpIHtcbiAgICBpbmRlbnQoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgdmFyIGRlbGltaXRlcl9pbmRleCA9IFwiWyh7XCIuaW5kZXhPZihjdXJyZW50KTtcbiAgaWYgKGRlbGltaXRlcl9pbmRleCAhPT0gLTEpIHtcbiAgICBpbmRlbnQoc3RyZWFtLCBzdGF0ZSwgXCJdKX1cIi5zbGljZShkZWxpbWl0ZXJfaW5kZXgsIGRlbGltaXRlcl9pbmRleCsxKSk7XG4gIH1cbiAgaWYgKGluZGVudEtleXdvcmRzLmV4ZWMoY3VycmVudCkpe1xuICAgIGluZGVudChzdHJlYW0sIHN0YXRlKTtcbiAgfVxuICBpZiAoY3VycmVudCA9PSBcInRoZW5cIil7XG4gICAgZGVkZW50KHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cblxuICBpZiAoc3R5bGUgPT09IFwiZGVkZW50XCIpIHtcbiAgICBpZiAoZGVkZW50KHN0cmVhbSwgc3RhdGUpKSB7XG4gICAgICByZXR1cm4gRVJST1JDTEFTUztcbiAgICB9XG4gIH1cbiAgZGVsaW1pdGVyX2luZGV4ID0gXCJdKX1cIi5pbmRleE9mKGN1cnJlbnQpO1xuICBpZiAoZGVsaW1pdGVyX2luZGV4ICE9PSAtMSkge1xuICAgIHdoaWxlIChzdGF0ZS5zY29wZS50eXBlID09IFwiY29mZmVlXCIgJiYgc3RhdGUuc2NvcGUucHJldilcbiAgICAgIHN0YXRlLnNjb3BlID0gc3RhdGUuc2NvcGUucHJldjtcbiAgICBpZiAoc3RhdGUuc2NvcGUudHlwZSA9PSBjdXJyZW50KVxuICAgICAgc3RhdGUuc2NvcGUgPSBzdGF0ZS5zY29wZS5wcmV2O1xuICB9XG4gIGlmIChzdGF0ZS5kZWRlbnQgJiYgc3RyZWFtLmVvbCgpKSB7XG4gICAgaWYgKHN0YXRlLnNjb3BlLnR5cGUgPT0gXCJjb2ZmZWVcIiAmJiBzdGF0ZS5zY29wZS5wcmV2KVxuICAgICAgc3RhdGUuc2NvcGUgPSBzdGF0ZS5zY29wZS5wcmV2O1xuICAgIHN0YXRlLmRlZGVudCA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlID09IFwiaW5kZW50XCIgfHwgc3R5bGUgPT0gXCJkZWRlbnRcIiA/IG51bGwgOiBzdHlsZTtcbn1cblxuZXhwb3J0IGNvbnN0IGNvZmZlZVNjcmlwdCA9IHtcbiAgbmFtZTogXCJjb2ZmZWVzY3JpcHRcIixcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuaXplOiB0b2tlbkJhc2UsXG4gICAgICBzY29wZToge29mZnNldDogMCwgdHlwZTpcImNvZmZlZVwiLCBwcmV2OiBudWxsLCBhbGlnbjogZmFsc2V9LFxuICAgICAgcHJvcDogZmFsc2UsXG4gICAgICBkZWRlbnQ6IDBcbiAgICB9O1xuICB9LFxuXG4gIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGZpbGxBbGlnbiA9IHN0YXRlLnNjb3BlLmFsaWduID09PSBudWxsICYmIHN0YXRlLnNjb3BlO1xuICAgIGlmIChmaWxsQWxpZ24gJiYgc3RyZWFtLnNvbCgpKSBmaWxsQWxpZ24uYWxpZ24gPSBmYWxzZTtcblxuICAgIHZhciBzdHlsZSA9IHRva2VuTGV4ZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0eWxlICYmIHN0eWxlICE9IFwiY29tbWVudFwiKSB7XG4gICAgICBpZiAoZmlsbEFsaWduKSBmaWxsQWxpZ24uYWxpZ24gPSB0cnVlO1xuICAgICAgc3RhdGUucHJvcCA9IHN0eWxlID09IFwicHVuY3R1YXRpb25cIiAmJiBzdHJlYW0uY3VycmVudCgpID09IFwiLlwiXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuXG4gIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHQpIHtcbiAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gdG9rZW5CYXNlKSByZXR1cm4gMDtcbiAgICB2YXIgc2NvcGUgPSBzdGF0ZS5zY29wZTtcbiAgICB2YXIgY2xvc2VyID0gdGV4dCAmJiBcIl0pfVwiLmluZGV4T2YodGV4dC5jaGFyQXQoMCkpID4gLTE7XG4gICAgaWYgKGNsb3Nlcikgd2hpbGUgKHNjb3BlLnR5cGUgPT0gXCJjb2ZmZWVcIiAmJiBzY29wZS5wcmV2KSBzY29wZSA9IHNjb3BlLnByZXY7XG4gICAgdmFyIGNsb3NlcyA9IGNsb3NlciAmJiBzY29wZS50eXBlID09PSB0ZXh0LmNoYXJBdCgwKTtcbiAgICBpZiAoc2NvcGUuYWxpZ24pXG4gICAgICByZXR1cm4gc2NvcGUuYWxpZ25PZmZzZXQgLSAoY2xvc2VzID8gMSA6IDApO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiAoY2xvc2VzID8gc2NvcGUucHJldiA6IHNjb3BlKS5vZmZzZXQ7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiI1wifVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/legacy-modes/mode/coffeescript.js\n"));

/***/ })

}]);