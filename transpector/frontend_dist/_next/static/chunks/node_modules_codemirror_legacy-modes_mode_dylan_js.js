"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_codemirror_legacy-modes_mode_dylan_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/dylan.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/dylan.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dylan\": function() { return /* binding */ dylan; }\n/* harmony export */ });\nfunction forEach(arr, f) {\n  for (var i = 0; i < arr.length; i++) f(arr[i], i)\n}\nfunction some(arr, f) {\n  for (var i = 0; i < arr.length; i++) if (f(arr[i], i)) return true\n  return false\n}\n\n// Words\nvar words = {\n  // Words that introduce unnamed definitions like \"define interface\"\n  unnamedDefinition: [\"interface\"],\n\n  // Words that introduce simple named definitions like \"define library\"\n  namedDefinition: [\"module\", \"library\", \"macro\",\n                    \"C-struct\", \"C-union\",\n                    \"C-function\", \"C-callable-wrapper\"\n                   ],\n\n  // Words that introduce type definitions like \"define class\".\n  // These are also parameterized like \"define method\" and are\n  // appended to otherParameterizedDefinitionWords\n  typeParameterizedDefinition: [\"class\", \"C-subtype\", \"C-mapped-subtype\"],\n\n  // Words that introduce trickier definitions like \"define method\".\n  // These require special definitions to be added to startExpressions\n  otherParameterizedDefinition: [\"method\", \"function\",\n                                 \"C-variable\", \"C-address\"\n                                ],\n\n  // Words that introduce module constant definitions.\n  // These must also be simple definitions and are\n  // appended to otherSimpleDefinitionWords\n  constantSimpleDefinition: [\"constant\"],\n\n  // Words that introduce module variable definitions.\n  // These must also be simple definitions and are\n  // appended to otherSimpleDefinitionWords\n  variableSimpleDefinition: [\"variable\"],\n\n  // Other words that introduce simple definitions\n  // (without implicit bodies).\n  otherSimpleDefinition: [\"generic\", \"domain\",\n                          \"C-pointer-type\",\n                          \"table\"\n                         ],\n\n  // Words that begin statements with implicit bodies.\n  statement: [\"if\", \"block\", \"begin\", \"method\", \"case\",\n              \"for\", \"select\", \"when\", \"unless\", \"until\",\n              \"while\", \"iterate\", \"profiling\", \"dynamic-bind\"\n             ],\n\n  // Patterns that act as separators in compound statements.\n  // This may include any general pattern that must be indented\n  // specially.\n  separator: [\"finally\", \"exception\", \"cleanup\", \"else\",\n              \"elseif\", \"afterwards\"\n             ],\n\n  // Keywords that do not require special indentation handling,\n  // but which should be highlighted\n  other: [\"above\", \"below\", \"by\", \"from\", \"handler\", \"in\",\n          \"instance\", \"let\", \"local\", \"otherwise\", \"slot\",\n          \"subclass\", \"then\", \"to\", \"keyed-by\", \"virtual\"\n         ],\n\n  // Condition signaling function calls\n  signalingCalls: [\"signal\", \"error\", \"cerror\",\n                   \"break\", \"check-type\", \"abort\"\n                  ]\n};\n\nwords[\"otherDefinition\"] =\n  words[\"unnamedDefinition\"]\n  .concat(words[\"namedDefinition\"])\n  .concat(words[\"otherParameterizedDefinition\"]);\n\nwords[\"definition\"] =\n  words[\"typeParameterizedDefinition\"]\n  .concat(words[\"otherDefinition\"]);\n\nwords[\"parameterizedDefinition\"] =\n  words[\"typeParameterizedDefinition\"]\n  .concat(words[\"otherParameterizedDefinition\"]);\n\nwords[\"simpleDefinition\"] =\n  words[\"constantSimpleDefinition\"]\n  .concat(words[\"variableSimpleDefinition\"])\n  .concat(words[\"otherSimpleDefinition\"]);\n\nwords[\"keyword\"] =\n  words[\"statement\"]\n  .concat(words[\"separator\"])\n  .concat(words[\"other\"]);\n\n// Patterns\nvar symbolPattern = \"[-_a-zA-Z?!*@<>$%]+\";\nvar symbol = new RegExp(\"^\" + symbolPattern);\nvar patterns = {\n  // Symbols with special syntax\n  symbolKeyword: symbolPattern + \":\",\n  symbolClass: \"<\" + symbolPattern + \">\",\n  symbolGlobal: \"\\\\*\" + symbolPattern + \"\\\\*\",\n  symbolConstant: \"\\\\$\" + symbolPattern\n};\nvar patternStyles = {\n  symbolKeyword: \"atom\",\n  symbolClass: \"tag\",\n  symbolGlobal: \"variableName.standard\",\n  symbolConstant: \"variableName.constant\"\n};\n\n// Compile all patterns to regular expressions\nfor (var patternName in patterns)\n  if (patterns.hasOwnProperty(patternName))\n    patterns[patternName] = new RegExp(\"^\" + patterns[patternName]);\n\n// Names beginning \"with-\" and \"without-\" are commonly\n// used as statement macro\npatterns[\"keyword\"] = [/^with(?:out)?-[-_a-zA-Z?!*@<>$%]+/];\n\nvar styles = {};\nstyles[\"keyword\"] = \"keyword\";\nstyles[\"definition\"] = \"def\";\nstyles[\"simpleDefinition\"] = \"def\";\nstyles[\"signalingCalls\"] = \"builtin\";\n\n// protected words lookup table\nvar wordLookup = {};\nvar styleLookup = {};\n\nforEach([\n  \"keyword\",\n  \"definition\",\n  \"simpleDefinition\",\n  \"signalingCalls\"\n], function(type) {\n  forEach(words[type], function(word) {\n    wordLookup[word] = type;\n    styleLookup[word] = styles[type];\n  });\n});\n\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\nfunction tokenBase(stream, state) {\n  // String\n  var ch = stream.peek();\n  if (ch == \"'\" || ch == '\"') {\n    stream.next();\n    return chain(stream, state, tokenString(ch, \"string\"));\n  }\n  // Comment\n  else if (ch == \"/\") {\n    stream.next();\n    if (stream.eat(\"*\")) {\n      return chain(stream, state, tokenComment);\n    } else if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n    stream.backUp(1);\n  }\n  // Decimal\n  else if (/[+\\-\\d\\.]/.test(ch)) {\n    if (stream.match(/^[+-]?[0-9]*\\.[0-9]*([esdx][+-]?[0-9]+)?/i) ||\n        stream.match(/^[+-]?[0-9]+([esdx][+-]?[0-9]+)/i) ||\n        stream.match(/^[+-]?\\d+/)) {\n      return \"number\";\n    }\n  }\n  // Hash\n  else if (ch == \"#\") {\n    stream.next();\n    // Symbol with string syntax\n    ch = stream.peek();\n    if (ch == '\"') {\n      stream.next();\n      return chain(stream, state, tokenString('\"', \"string\"));\n    }\n    // Binary number\n    else if (ch == \"b\") {\n      stream.next();\n      stream.eatWhile(/[01]/);\n      return \"number\";\n    }\n    // Hex number\n    else if (ch == \"x\") {\n      stream.next();\n      stream.eatWhile(/[\\da-f]/i);\n      return \"number\";\n    }\n    // Octal number\n    else if (ch == \"o\") {\n      stream.next();\n      stream.eatWhile(/[0-7]/);\n      return \"number\";\n    }\n    // Token concatenation in macros\n    else if (ch == '#') {\n      stream.next();\n      return \"punctuation\";\n    }\n    // Sequence literals\n    else if ((ch == '[') || (ch == '(')) {\n      stream.next();\n      return \"bracket\";\n      // Hash symbol\n    } else if (stream.match(/f|t|all-keys|include|key|next|rest/i)) {\n      return \"atom\";\n    } else {\n      stream.eatWhile(/[-a-zA-Z]/);\n      return \"error\";\n    }\n  } else if (ch == \"~\") {\n    stream.next();\n    ch = stream.peek();\n    if (ch == \"=\") {\n      stream.next();\n      ch = stream.peek();\n      if (ch == \"=\") {\n        stream.next();\n        return \"operator\";\n      }\n      return \"operator\";\n    }\n    return \"operator\";\n  } else if (ch == \":\") {\n    stream.next();\n    ch = stream.peek();\n    if (ch == \"=\") {\n      stream.next();\n      return \"operator\";\n    } else if (ch == \":\") {\n      stream.next();\n      return \"punctuation\";\n    }\n  } else if (\"[](){}\".indexOf(ch) != -1) {\n    stream.next();\n    return \"bracket\";\n  } else if (\".,\".indexOf(ch) != -1) {\n    stream.next();\n    return \"punctuation\";\n  } else if (stream.match(\"end\")) {\n    return \"keyword\";\n  }\n  for (var name in patterns) {\n    if (patterns.hasOwnProperty(name)) {\n      var pattern = patterns[name];\n      if ((pattern instanceof Array && some(pattern, function(p) {\n        return stream.match(p);\n      })) || stream.match(pattern))\n        return patternStyles[name];\n    }\n  }\n  if (/[+\\-*\\/^=<>&|]/.test(ch)) {\n    stream.next();\n    return \"operator\";\n  }\n  if (stream.match(\"define\")) {\n    return \"def\";\n  } else {\n    stream.eatWhile(/[\\w\\-]/);\n    // Keyword\n    if (wordLookup.hasOwnProperty(stream.current())) {\n      return styleLookup[stream.current()];\n    } else if (stream.current().match(symbol)) {\n      return \"variable\";\n    } else {\n      stream.next();\n      return \"variableName.standard\";\n    }\n  }\n}\n\nfunction tokenComment(stream, state) {\n  var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;\n  while ((ch = stream.next())) {\n    if (ch == \"/\" && maybeEnd) {\n      if (nestedCount > 0) {\n        nestedCount--;\n      } else {\n        state.tokenize = tokenBase;\n        break;\n      }\n    } else if (ch == \"*\" && maybeNested) {\n      nestedCount++;\n    }\n    maybeEnd = (ch == \"*\");\n    maybeNested = (ch == \"/\");\n  }\n  return \"comment\";\n}\n\nfunction tokenString(quote, style) {\n  return function(stream, state) {\n    var escaped = false, next, end = false;\n    while ((next = stream.next()) != null) {\n      if (next == quote && !escaped) {\n        end = true;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    if (end || !escaped) {\n      state.tokenize = tokenBase;\n    }\n    return style;\n  };\n}\n\n// Interface\nconst dylan = {\n  name: \"dylan\",\n  startState: function() {\n    return {\n      tokenize: tokenBase,\n      currentIndent: 0\n    };\n  },\n  token: function(stream, state) {\n    if (stream.eatSpace())\n      return null;\n    var style = state.tokenize(stream, state);\n    return style;\n  },\n  languageData: {\n    commentTokens: {block: {open: \"/*\", close: \"*/\"}}\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvZHlsYW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9keWxhbi5qcz83MDdkIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGZvckVhY2goYXJyLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBmKGFycltpXSwgaSlcbn1cbmZ1bmN0aW9uIHNvbWUoYXJyLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBpZiAoZihhcnJbaV0sIGkpKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gV29yZHNcbnZhciB3b3JkcyA9IHtcbiAgLy8gV29yZHMgdGhhdCBpbnRyb2R1Y2UgdW5uYW1lZCBkZWZpbml0aW9ucyBsaWtlIFwiZGVmaW5lIGludGVyZmFjZVwiXG4gIHVubmFtZWREZWZpbml0aW9uOiBbXCJpbnRlcmZhY2VcIl0sXG5cbiAgLy8gV29yZHMgdGhhdCBpbnRyb2R1Y2Ugc2ltcGxlIG5hbWVkIGRlZmluaXRpb25zIGxpa2UgXCJkZWZpbmUgbGlicmFyeVwiXG4gIG5hbWVkRGVmaW5pdGlvbjogW1wibW9kdWxlXCIsIFwibGlicmFyeVwiLCBcIm1hY3JvXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQy1zdHJ1Y3RcIiwgXCJDLXVuaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQy1mdW5jdGlvblwiLCBcIkMtY2FsbGFibGUtd3JhcHBlclwiXG4gICAgICAgICAgICAgICAgICAgXSxcblxuICAvLyBXb3JkcyB0aGF0IGludHJvZHVjZSB0eXBlIGRlZmluaXRpb25zIGxpa2UgXCJkZWZpbmUgY2xhc3NcIi5cbiAgLy8gVGhlc2UgYXJlIGFsc28gcGFyYW1ldGVyaXplZCBsaWtlIFwiZGVmaW5lIG1ldGhvZFwiIGFuZCBhcmVcbiAgLy8gYXBwZW5kZWQgdG8gb3RoZXJQYXJhbWV0ZXJpemVkRGVmaW5pdGlvbldvcmRzXG4gIHR5cGVQYXJhbWV0ZXJpemVkRGVmaW5pdGlvbjogW1wiY2xhc3NcIiwgXCJDLXN1YnR5cGVcIiwgXCJDLW1hcHBlZC1zdWJ0eXBlXCJdLFxuXG4gIC8vIFdvcmRzIHRoYXQgaW50cm9kdWNlIHRyaWNraWVyIGRlZmluaXRpb25zIGxpa2UgXCJkZWZpbmUgbWV0aG9kXCIuXG4gIC8vIFRoZXNlIHJlcXVpcmUgc3BlY2lhbCBkZWZpbml0aW9ucyB0byBiZSBhZGRlZCB0byBzdGFydEV4cHJlc3Npb25zXG4gIG90aGVyUGFyYW1ldGVyaXplZERlZmluaXRpb246IFtcIm1ldGhvZFwiLCBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkMtdmFyaWFibGVcIiwgXCJDLWFkZHJlc3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuXG4gIC8vIFdvcmRzIHRoYXQgaW50cm9kdWNlIG1vZHVsZSBjb25zdGFudCBkZWZpbml0aW9ucy5cbiAgLy8gVGhlc2UgbXVzdCBhbHNvIGJlIHNpbXBsZSBkZWZpbml0aW9ucyBhbmQgYXJlXG4gIC8vIGFwcGVuZGVkIHRvIG90aGVyU2ltcGxlRGVmaW5pdGlvbldvcmRzXG4gIGNvbnN0YW50U2ltcGxlRGVmaW5pdGlvbjogW1wiY29uc3RhbnRcIl0sXG5cbiAgLy8gV29yZHMgdGhhdCBpbnRyb2R1Y2UgbW9kdWxlIHZhcmlhYmxlIGRlZmluaXRpb25zLlxuICAvLyBUaGVzZSBtdXN0IGFsc28gYmUgc2ltcGxlIGRlZmluaXRpb25zIGFuZCBhcmVcbiAgLy8gYXBwZW5kZWQgdG8gb3RoZXJTaW1wbGVEZWZpbml0aW9uV29yZHNcbiAgdmFyaWFibGVTaW1wbGVEZWZpbml0aW9uOiBbXCJ2YXJpYWJsZVwiXSxcblxuICAvLyBPdGhlciB3b3JkcyB0aGF0IGludHJvZHVjZSBzaW1wbGUgZGVmaW5pdGlvbnNcbiAgLy8gKHdpdGhvdXQgaW1wbGljaXQgYm9kaWVzKS5cbiAgb3RoZXJTaW1wbGVEZWZpbml0aW9uOiBbXCJnZW5lcmljXCIsIFwiZG9tYWluXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiQy1wb2ludGVyLXR5cGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgXSxcblxuICAvLyBXb3JkcyB0aGF0IGJlZ2luIHN0YXRlbWVudHMgd2l0aCBpbXBsaWNpdCBib2RpZXMuXG4gIHN0YXRlbWVudDogW1wiaWZcIiwgXCJibG9ja1wiLCBcImJlZ2luXCIsIFwibWV0aG9kXCIsIFwiY2FzZVwiLFxuICAgICAgICAgICAgICBcImZvclwiLCBcInNlbGVjdFwiLCBcIndoZW5cIiwgXCJ1bmxlc3NcIiwgXCJ1bnRpbFwiLFxuICAgICAgICAgICAgICBcIndoaWxlXCIsIFwiaXRlcmF0ZVwiLCBcInByb2ZpbGluZ1wiLCBcImR5bmFtaWMtYmluZFwiXG4gICAgICAgICAgICAgXSxcblxuICAvLyBQYXR0ZXJucyB0aGF0IGFjdCBhcyBzZXBhcmF0b3JzIGluIGNvbXBvdW5kIHN0YXRlbWVudHMuXG4gIC8vIFRoaXMgbWF5IGluY2x1ZGUgYW55IGdlbmVyYWwgcGF0dGVybiB0aGF0IG11c3QgYmUgaW5kZW50ZWRcbiAgLy8gc3BlY2lhbGx5LlxuICBzZXBhcmF0b3I6IFtcImZpbmFsbHlcIiwgXCJleGNlcHRpb25cIiwgXCJjbGVhbnVwXCIsIFwiZWxzZVwiLFxuICAgICAgICAgICAgICBcImVsc2VpZlwiLCBcImFmdGVyd2FyZHNcIlxuICAgICAgICAgICAgIF0sXG5cbiAgLy8gS2V5d29yZHMgdGhhdCBkbyBub3QgcmVxdWlyZSBzcGVjaWFsIGluZGVudGF0aW9uIGhhbmRsaW5nLFxuICAvLyBidXQgd2hpY2ggc2hvdWxkIGJlIGhpZ2hsaWdodGVkXG4gIG90aGVyOiBbXCJhYm92ZVwiLCBcImJlbG93XCIsIFwiYnlcIiwgXCJmcm9tXCIsIFwiaGFuZGxlclwiLCBcImluXCIsXG4gICAgICAgICAgXCJpbnN0YW5jZVwiLCBcImxldFwiLCBcImxvY2FsXCIsIFwib3RoZXJ3aXNlXCIsIFwic2xvdFwiLFxuICAgICAgICAgIFwic3ViY2xhc3NcIiwgXCJ0aGVuXCIsIFwidG9cIiwgXCJrZXllZC1ieVwiLCBcInZpcnR1YWxcIlxuICAgICAgICAgXSxcblxuICAvLyBDb25kaXRpb24gc2lnbmFsaW5nIGZ1bmN0aW9uIGNhbGxzXG4gIHNpZ25hbGluZ0NhbGxzOiBbXCJzaWduYWxcIiwgXCJlcnJvclwiLCBcImNlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgIFwiYnJlYWtcIiwgXCJjaGVjay10eXBlXCIsIFwiYWJvcnRcIlxuICAgICAgICAgICAgICAgICAgXVxufTtcblxud29yZHNbXCJvdGhlckRlZmluaXRpb25cIl0gPVxuICB3b3Jkc1tcInVubmFtZWREZWZpbml0aW9uXCJdXG4gIC5jb25jYXQod29yZHNbXCJuYW1lZERlZmluaXRpb25cIl0pXG4gIC5jb25jYXQod29yZHNbXCJvdGhlclBhcmFtZXRlcml6ZWREZWZpbml0aW9uXCJdKTtcblxud29yZHNbXCJkZWZpbml0aW9uXCJdID1cbiAgd29yZHNbXCJ0eXBlUGFyYW1ldGVyaXplZERlZmluaXRpb25cIl1cbiAgLmNvbmNhdCh3b3Jkc1tcIm90aGVyRGVmaW5pdGlvblwiXSk7XG5cbndvcmRzW1wicGFyYW1ldGVyaXplZERlZmluaXRpb25cIl0gPVxuICB3b3Jkc1tcInR5cGVQYXJhbWV0ZXJpemVkRGVmaW5pdGlvblwiXVxuICAuY29uY2F0KHdvcmRzW1wib3RoZXJQYXJhbWV0ZXJpemVkRGVmaW5pdGlvblwiXSk7XG5cbndvcmRzW1wic2ltcGxlRGVmaW5pdGlvblwiXSA9XG4gIHdvcmRzW1wiY29uc3RhbnRTaW1wbGVEZWZpbml0aW9uXCJdXG4gIC5jb25jYXQod29yZHNbXCJ2YXJpYWJsZVNpbXBsZURlZmluaXRpb25cIl0pXG4gIC5jb25jYXQod29yZHNbXCJvdGhlclNpbXBsZURlZmluaXRpb25cIl0pO1xuXG53b3Jkc1tcImtleXdvcmRcIl0gPVxuICB3b3Jkc1tcInN0YXRlbWVudFwiXVxuICAuY29uY2F0KHdvcmRzW1wic2VwYXJhdG9yXCJdKVxuICAuY29uY2F0KHdvcmRzW1wib3RoZXJcIl0pO1xuXG4vLyBQYXR0ZXJuc1xudmFyIHN5bWJvbFBhdHRlcm4gPSBcIlstX2EtekEtWj8hKkA8PiQlXStcIjtcbnZhciBzeW1ib2wgPSBuZXcgUmVnRXhwKFwiXlwiICsgc3ltYm9sUGF0dGVybik7XG52YXIgcGF0dGVybnMgPSB7XG4gIC8vIFN5bWJvbHMgd2l0aCBzcGVjaWFsIHN5bnRheFxuICBzeW1ib2xLZXl3b3JkOiBzeW1ib2xQYXR0ZXJuICsgXCI6XCIsXG4gIHN5bWJvbENsYXNzOiBcIjxcIiArIHN5bWJvbFBhdHRlcm4gKyBcIj5cIixcbiAgc3ltYm9sR2xvYmFsOiBcIlxcXFwqXCIgKyBzeW1ib2xQYXR0ZXJuICsgXCJcXFxcKlwiLFxuICBzeW1ib2xDb25zdGFudDogXCJcXFxcJFwiICsgc3ltYm9sUGF0dGVyblxufTtcbnZhciBwYXR0ZXJuU3R5bGVzID0ge1xuICBzeW1ib2xLZXl3b3JkOiBcImF0b21cIixcbiAgc3ltYm9sQ2xhc3M6IFwidGFnXCIsXG4gIHN5bWJvbEdsb2JhbDogXCJ2YXJpYWJsZU5hbWUuc3RhbmRhcmRcIixcbiAgc3ltYm9sQ29uc3RhbnQ6IFwidmFyaWFibGVOYW1lLmNvbnN0YW50XCJcbn07XG5cbi8vIENvbXBpbGUgYWxsIHBhdHRlcm5zIHRvIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbmZvciAodmFyIHBhdHRlcm5OYW1lIGluIHBhdHRlcm5zKVxuICBpZiAocGF0dGVybnMuaGFzT3duUHJvcGVydHkocGF0dGVybk5hbWUpKVxuICAgIHBhdHRlcm5zW3BhdHRlcm5OYW1lXSA9IG5ldyBSZWdFeHAoXCJeXCIgKyBwYXR0ZXJuc1twYXR0ZXJuTmFtZV0pO1xuXG4vLyBOYW1lcyBiZWdpbm5pbmcgXCJ3aXRoLVwiIGFuZCBcIndpdGhvdXQtXCIgYXJlIGNvbW1vbmx5XG4vLyB1c2VkIGFzIHN0YXRlbWVudCBtYWNyb1xucGF0dGVybnNbXCJrZXl3b3JkXCJdID0gWy9ed2l0aCg/Om91dCk/LVstX2EtekEtWj8hKkA8PiQlXSsvXTtcblxudmFyIHN0eWxlcyA9IHt9O1xuc3R5bGVzW1wia2V5d29yZFwiXSA9IFwia2V5d29yZFwiO1xuc3R5bGVzW1wiZGVmaW5pdGlvblwiXSA9IFwiZGVmXCI7XG5zdHlsZXNbXCJzaW1wbGVEZWZpbml0aW9uXCJdID0gXCJkZWZcIjtcbnN0eWxlc1tcInNpZ25hbGluZ0NhbGxzXCJdID0gXCJidWlsdGluXCI7XG5cbi8vIHByb3RlY3RlZCB3b3JkcyBsb29rdXAgdGFibGVcbnZhciB3b3JkTG9va3VwID0ge307XG52YXIgc3R5bGVMb29rdXAgPSB7fTtcblxuZm9yRWFjaChbXG4gIFwia2V5d29yZFwiLFxuICBcImRlZmluaXRpb25cIixcbiAgXCJzaW1wbGVEZWZpbml0aW9uXCIsXG4gIFwic2lnbmFsaW5nQ2FsbHNcIlxuXSwgZnVuY3Rpb24odHlwZSkge1xuICBmb3JFYWNoKHdvcmRzW3R5cGVdLCBmdW5jdGlvbih3b3JkKSB7XG4gICAgd29yZExvb2t1cFt3b3JkXSA9IHR5cGU7XG4gICAgc3R5bGVMb29rdXBbd29yZF0gPSBzdHlsZXNbdHlwZV07XG4gIH0pO1xufSk7XG5cblxuZnVuY3Rpb24gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgZikge1xuICBzdGF0ZS50b2tlbml6ZSA9IGY7XG4gIHJldHVybiBmKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBTdHJpbmdcbiAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcbiAgaWYgKGNoID09IFwiJ1wiIHx8IGNoID09ICdcIicpIHtcbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblN0cmluZyhjaCwgXCJzdHJpbmdcIikpO1xuICB9XG4gIC8vIENvbW1lbnRcbiAgZWxzZSBpZiAoY2ggPT0gXCIvXCIpIHtcbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuQ29tbWVudCk7XG4gICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cbiAgICBzdHJlYW0uYmFja1VwKDEpO1xuICB9XG4gIC8vIERlY2ltYWxcbiAgZWxzZSBpZiAoL1srXFwtXFxkXFwuXS8udGVzdChjaCkpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eWystXT9bMC05XSpcXC5bMC05XSooW2VzZHhdWystXT9bMC05XSspPy9pKSB8fFxuICAgICAgICBzdHJlYW0ubWF0Y2goL15bKy1dP1swLTldKyhbZXNkeF1bKy1dP1swLTldKykvaSkgfHxcbiAgICAgICAgc3RyZWFtLm1hdGNoKC9eWystXT9cXGQrLykpIHtcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH1cbiAgfVxuICAvLyBIYXNoXG4gIGVsc2UgaWYgKGNoID09IFwiI1wiKSB7XG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICAvLyBTeW1ib2wgd2l0aCBzdHJpbmcgc3ludGF4XG4gICAgY2ggPSBzdHJlYW0ucGVlaygpO1xuICAgIGlmIChjaCA9PSAnXCInKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuU3RyaW5nKCdcIicsIFwic3RyaW5nXCIpKTtcbiAgICB9XG4gICAgLy8gQmluYXJ5IG51bWJlclxuICAgIGVsc2UgaWYgKGNoID09IFwiYlwiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bMDFdLyk7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG4gICAgLy8gSGV4IG51bWJlclxuICAgIGVsc2UgaWYgKGNoID09IFwieFwiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFxkYS1mXS9pKTtcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH1cbiAgICAvLyBPY3RhbCBudW1iZXJcbiAgICBlbHNlIGlmIChjaCA9PSBcIm9cIikge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvWzAtN10vKTtcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH1cbiAgICAvLyBUb2tlbiBjb25jYXRlbmF0aW9uIGluIG1hY3Jvc1xuICAgIGVsc2UgaWYgKGNoID09ICcjJykge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcInB1bmN0dWF0aW9uXCI7XG4gICAgfVxuICAgIC8vIFNlcXVlbmNlIGxpdGVyYWxzXG4gICAgZWxzZSBpZiAoKGNoID09ICdbJykgfHwgKGNoID09ICcoJykpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gICAgICAvLyBIYXNoIHN5bWJvbFxuICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9mfHR8YWxsLWtleXN8aW5jbHVkZXxrZXl8bmV4dHxyZXN0L2kpKSB7XG4gICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvWy1hLXpBLVpdLyk7XG4gICAgICByZXR1cm4gXCJlcnJvclwiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjaCA9PSBcIn5cIikge1xuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgY2ggPSBzdHJlYW0ucGVlaygpO1xuICAgIGlmIChjaCA9PSBcIj1cIikge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIGNoID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgIGlmIChjaCA9PSBcIj1cIikge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgfSBlbHNlIGlmIChjaCA9PSBcIjpcIikge1xuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgY2ggPSBzdHJlYW0ucGVlaygpO1xuICAgIGlmIChjaCA9PSBcIj1cIikge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIjpcIikge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcInB1bmN0dWF0aW9uXCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKFwiW10oKXt9XCIuaW5kZXhPZihjaCkgIT0gLTEpIHtcbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgfSBlbHNlIGlmIChcIi4sXCIuaW5kZXhPZihjaCkgIT0gLTEpIHtcbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIHJldHVybiBcInB1bmN0dWF0aW9uXCI7XG4gIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKFwiZW5kXCIpKSB7XG4gICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICB9XG4gIGZvciAodmFyIG5hbWUgaW4gcGF0dGVybnMpIHtcbiAgICBpZiAocGF0dGVybnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHZhciBwYXR0ZXJuID0gcGF0dGVybnNbbmFtZV07XG4gICAgICBpZiAoKHBhdHRlcm4gaW5zdGFuY2VvZiBBcnJheSAmJiBzb21lKHBhdHRlcm4sIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5tYXRjaChwKTtcbiAgICAgIH0pKSB8fCBzdHJlYW0ubWF0Y2gocGF0dGVybikpXG4gICAgICAgIHJldHVybiBwYXR0ZXJuU3R5bGVzW25hbWVdO1xuICAgIH1cbiAgfVxuICBpZiAoL1srXFwtKlxcL149PD4mfF0vLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICB9XG4gIGlmIChzdHJlYW0ubWF0Y2goXCJkZWZpbmVcIikpIHtcbiAgICByZXR1cm4gXCJkZWZcIjtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC1dLyk7XG4gICAgLy8gS2V5d29yZFxuICAgIGlmICh3b3JkTG9va3VwLmhhc093blByb3BlcnR5KHN0cmVhbS5jdXJyZW50KCkpKSB7XG4gICAgICByZXR1cm4gc3R5bGVMb29rdXBbc3RyZWFtLmN1cnJlbnQoKV07XG4gICAgfSBlbHNlIGlmIChzdHJlYW0uY3VycmVudCgpLm1hdGNoKHN5bWJvbCkpIHtcbiAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZU5hbWUuc3RhbmRhcmRcIjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG1heWJlRW5kID0gZmFsc2UsIG1heWJlTmVzdGVkID0gZmFsc2UsIG5lc3RlZENvdW50ID0gMCwgY2g7XG4gIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSkge1xuICAgIGlmIChjaCA9PSBcIi9cIiAmJiBtYXliZUVuZCkge1xuICAgICAgaWYgKG5lc3RlZENvdW50ID4gMCkge1xuICAgICAgICBuZXN0ZWRDb3VudC0tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIqXCIgJiYgbWF5YmVOZXN0ZWQpIHtcbiAgICAgIG5lc3RlZENvdW50Kys7XG4gICAgfVxuICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgICBtYXliZU5lc3RlZCA9IChjaCA9PSBcIi9cIik7XG4gIH1cbiAgcmV0dXJuIFwiY29tbWVudFwiO1xufVxuXG5mdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSwgc3R5bGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0LCBlbmQgPSBmYWxzZTtcbiAgICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICBpZiAobmV4dCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkge1xuICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgIH1cbiAgICBpZiAoZW5kIHx8ICFlc2NhcGVkKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xufVxuXG4vLyBJbnRlcmZhY2VcbmV4cG9ydCBjb25zdCBkeWxhbiA9IHtcbiAgbmFtZTogXCJkeWxhblwiLFxuICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgIGN1cnJlbnRJbmRlbnQ6IDBcbiAgICB9O1xuICB9LFxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2Jsb2NrOiB7b3BlbjogXCIvKlwiLCBjbG9zZTogXCIqL1wifX1cbiAgfVxufTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/legacy-modes/mode/dylan.js\n"));

/***/ })

}]);