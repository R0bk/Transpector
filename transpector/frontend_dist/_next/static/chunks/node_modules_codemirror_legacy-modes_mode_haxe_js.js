"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_codemirror_legacy-modes_mode_haxe_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/haxe.js":
/*!************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/haxe.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"haxe\": function() { return /* binding */ haxe; },\n/* harmony export */   \"hxml\": function() { return /* binding */ hxml; }\n/* harmony export */ });\n// Tokenizer\n\nfunction kw(type) {return {type: type, style: \"keyword\"};}\nvar A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\nvar operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"}, attribute = {type:\"attribute\", style: \"attribute\"};\nvar type = kw(\"typedef\");\nvar keywords = {\n  \"if\": A, \"while\": A, \"else\": B, \"do\": B, \"try\": B,\n  \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"throw\": C,\n  \"var\": kw(\"var\"), \"inline\":attribute, \"static\": attribute, \"using\":kw(\"import\"),\n  \"public\": attribute, \"private\": attribute, \"cast\": kw(\"cast\"), \"import\": kw(\"import\"), \"macro\": kw(\"macro\"),\n  \"function\": kw(\"function\"), \"catch\": kw(\"catch\"), \"untyped\": kw(\"untyped\"), \"callback\": kw(\"cb\"),\n  \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n  \"in\": operator, \"never\": kw(\"property_access\"), \"trace\":kw(\"trace\"),\n  \"class\": type, \"abstract\":type, \"enum\":type, \"interface\":type, \"typedef\":type, \"extends\":type, \"implements\":type, \"dynamic\":type,\n  \"true\": atom, \"false\": atom, \"null\": atom\n};\n\nvar isOperatorChar = /[+\\-*&%=<>!?|]/;\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\nfunction toUnescaped(stream, end) {\n  var escaped = false, next;\n  while ((next = stream.next()) != null) {\n    if (next == end && !escaped)\n      return true;\n    escaped = !escaped && next == \"\\\\\";\n  }\n}\n\n// Used as scratch variables to communicate multiple values without\n// consing up tons of objects.\nvar type, content;\nfunction ret(tp, style, cont) {\n  type = tp; content = cont;\n  return style;\n}\n\nfunction haxeTokenBase(stream, state) {\n  var ch = stream.next();\n  if (ch == '\"' || ch == \"'\") {\n    return chain(stream, state, haxeTokenString(ch));\n  } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n    return ret(ch);\n  } else if (ch == \"0\" && stream.eat(/x/i)) {\n    stream.eatWhile(/[\\da-f]/i);\n    return ret(\"number\", \"number\");\n  } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n    stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n    return ret(\"number\", \"number\");\n  } else if (state.reAllowed && (ch == \"~\" && stream.eat(/\\//))) {\n    toUnescaped(stream, \"/\");\n    stream.eatWhile(/[gimsu]/);\n    return ret(\"regexp\", \"string.special\");\n  } else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      return chain(stream, state, haxeTokenComment);\n    } else if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return ret(\"comment\", \"comment\");\n    } else {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    }\n  } else if (ch == \"#\") {\n    stream.skipToEnd();\n    return ret(\"conditional\", \"meta\");\n  } else if (ch == \"@\") {\n    stream.eat(/:/);\n    stream.eatWhile(/[\\w_]/);\n    return ret (\"metadata\", \"meta\");\n  } else if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return ret(\"operator\", null, stream.current());\n  } else {\n    var word;\n    if(/[A-Z]/.test(ch)) {\n      stream.eatWhile(/[\\w_<>]/);\n      word = stream.current();\n      return ret(\"type\", \"type\", word);\n    } else {\n      stream.eatWhile(/[\\w_]/);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.kwAllowed) ? ret(known.type, known.style, word) :\n        ret(\"variable\", \"variable\", word);\n    }\n  }\n}\n\nfunction haxeTokenString(quote) {\n  return function(stream, state) {\n    if (toUnescaped(stream, quote))\n      state.tokenize = haxeTokenBase;\n    return ret(\"string\", \"string\");\n  };\n}\n\nfunction haxeTokenComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = haxeTokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return ret(\"comment\", \"comment\");\n}\n\n// Parser\n\nvar atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true};\n\nfunction HaxeLexical(indented, column, type, align, prev, info) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.prev = prev;\n  this.info = info;\n  if (align != null) this.align = align;\n}\n\nfunction inScope(state, varname) {\n  for (var v = state.localVars; v; v = v.next)\n    if (v.name == varname) return true;\n}\n\nfunction parseHaxe(state, style, type, content, stream) {\n  var cc = state.cc;\n  // Communicate our context to the combinators.\n  // (Less wasteful than consing up a hundred closures on every call.)\n  cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n  if (!state.lexical.hasOwnProperty(\"align\"))\n    state.lexical.align = true;\n\n  while(true) {\n    var combinator = cc.length ? cc.pop() : statement;\n    if (combinator(type, content)) {\n      while(cc.length && cc[cc.length - 1].lex)\n        cc.pop()();\n      if (cx.marked) return cx.marked;\n      if (type == \"variable\" && inScope(state, content)) return \"variableName.local\";\n      if (type == \"variable\" && imported(state, content)) return \"variableName.special\";\n      return style;\n    }\n  }\n}\n\nfunction imported(state, typename) {\n  if (/[a-z]/.test(typename.charAt(0)))\n    return false;\n  var len = state.importedtypes.length;\n  for (var i = 0; i<len; i++)\n    if(state.importedtypes[i]==typename) return true;\n}\n\nfunction registerimport(importname) {\n  var state = cx.state;\n  for (var t = state.importedtypes; t; t = t.next)\n    if(t.name == importname) return;\n  state.importedtypes = { name: importname, next: state.importedtypes };\n}\n// Combinator utils\n\nvar cx = {state: null, column: null, marked: null, cc: null};\nfunction pass() {\n  for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n}\nfunction cont() {\n  pass.apply(null, arguments);\n  return true;\n}\nfunction inList(name, list) {\n  for (var v = list; v; v = v.next)\n    if (v.name == name) return true;\n  return false;\n}\nfunction register(varname) {\n  var state = cx.state;\n  if (state.context) {\n    cx.marked = \"def\";\n    if (inList(varname, state.localVars)) return;\n    state.localVars = {name: varname, next: state.localVars};\n  } else if (state.globalVars) {\n    if (inList(varname, state.globalVars)) return;\n    state.globalVars = {name: varname, next: state.globalVars};\n  }\n}\n\n// Combinators\n\nvar defaultVars = {name: \"this\", next: null};\nfunction pushcontext() {\n  if (!cx.state.context) cx.state.localVars = defaultVars;\n  cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n}\nfunction popcontext() {\n  cx.state.localVars = cx.state.context.vars;\n  cx.state.context = cx.state.context.prev;\n}\npopcontext.lex = true;\nfunction pushlex(type, info) {\n  var result = function() {\n    var state = cx.state;\n    state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n  };\n  result.lex = true;\n  return result;\n}\nfunction poplex() {\n  var state = cx.state;\n  if (state.lexical.prev) {\n    if (state.lexical.type == \")\")\n      state.indented = state.lexical.indented;\n    state.lexical = state.lexical.prev;\n  }\n}\npoplex.lex = true;\n\nfunction expect(wanted) {\n  function f(type) {\n    if (type == wanted) return cont();\n    else if (wanted == \";\") return pass();\n    else return cont(f);\n  }\n  return f;\n}\n\nfunction statement(type) {\n  if (type == \"@\") return cont(metadef);\n  if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n  if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n  if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n  if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n  if (type == \";\") return cont();\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"),\n                                 poplex, statement, poplex);\n  if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n  if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                    block, poplex, poplex);\n  if (type == \"case\") return cont(expression, expect(\":\"));\n  if (type == \"default\") return cont(expect(\":\"));\n  if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                   statement, poplex, popcontext);\n  if (type == \"import\") return cont(importdef, expect(\";\"));\n  if (type == \"typedef\") return cont(typedef);\n  return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n}\nfunction expression(type) {\n  if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n  if (type == \"type\" ) return cont(maybeoperator);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"keyword c\") return cont(maybeexpression);\n  if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n  if (type == \"operator\") return cont(expression);\n  if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n  return cont();\n}\nfunction maybeexpression(type) {\n  if (type.match(/[;\\}\\)\\],]/)) return pass();\n  return pass(expression);\n}\n\nfunction maybeoperator(type, value) {\n  if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n  if (type == \"operator\" || type == \":\") return cont(expression);\n  if (type == \";\") return;\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n  if (type == \".\") return cont(property, maybeoperator);\n  if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n}\n\nfunction maybeattribute(type) {\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"var\") return cont(vardef1);\n}\n\nfunction metadef(type) {\n  if(type == \":\") return cont(metadef);\n  if(type == \"variable\") return cont(metadef);\n  if(type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n}\nfunction metaargs(type) {\n  if(type == \"variable\") return cont();\n}\n\nfunction importdef (type, value) {\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n  else if(type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n}\n\nfunction typedef (type, value)\n{\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n  else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) { return cont(); }\n}\n\nfunction maybelabel(type) {\n  if (type == \":\") return cont(poplex, statement);\n  return pass(maybeoperator, expect(\";\"), poplex);\n}\nfunction property(type) {\n  if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n}\nfunction objprop(type) {\n  if (type == \"variable\") cx.marked = \"property\";\n  if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n}\nfunction commasep(what, end) {\n  function proceed(type) {\n    if (type == \",\") return cont(what, proceed);\n    if (type == end) return cont();\n    return cont(expect(end));\n  }\n  return function(type) {\n    if (type == end) return cont();\n    else return pass(what, proceed);\n  };\n}\nfunction block(type) {\n  if (type == \"}\") return cont();\n  return pass(statement, block);\n}\nfunction vardef1(type, value) {\n  if (type == \"variable\"){register(value); return cont(typeuse, vardef2);}\n  return cont();\n}\nfunction vardef2(type, value) {\n  if (value == \"=\") return cont(expression, vardef2);\n  if (type == \",\") return cont(vardef1);\n}\nfunction forspec1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(forin, expression)\n  } else {\n    return pass()\n  }\n}\nfunction forin(_type, value) {\n  if (value == \"in\") return cont();\n}\nfunction functiondef(type, value) {\n  //function names starting with upper-case letters are recognised as types, so cludging them together here.\n  if (type == \"variable\" || type == \"type\") {register(value); return cont(functiondef);}\n  if (value == \"new\") return cont(functiondef);\n  if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n}\nfunction typeuse(type) {\n  if(type == \":\") return cont(typestring);\n}\nfunction typestring(type) {\n  if(type == \"type\") return cont();\n  if(type == \"variable\") return cont();\n  if(type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n}\nfunction typeprop(type) {\n  if(type == \"variable\") return cont(typeuse);\n}\nfunction funarg(type, value) {\n  if (type == \"variable\") {register(value); return cont(typeuse);}\n}\n\n// Interface\nconst haxe = {\n  name: \"haxe\",\n  startState: function(indentUnit) {\n    var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n    var state = {\n      tokenize: haxeTokenBase,\n      reAllowed: true,\n      kwAllowed: true,\n      cc: [],\n      lexical: new HaxeLexical(-indentUnit, 0, \"block\", false),\n      importedtypes: defaulttypes,\n      context: null,\n      indented: 0\n    };\n    return state;\n  },\n\n  token: function(stream, state) {\n    if (stream.sol()) {\n      if (!state.lexical.hasOwnProperty(\"align\"))\n        state.lexical.align = false;\n      state.indented = stream.indentation();\n    }\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    if (type == \"comment\") return style;\n    state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n    state.kwAllowed = type != '.';\n    return parseHaxe(state, style, type, content, stream);\n  },\n\n  indent: function(state, textAfter, cx) {\n    if (state.tokenize != haxeTokenBase) return 0;\n    var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n    if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n    var type = lexical.type, closing = firstChar == type;\n    if (type == \"vardef\") return lexical.indented + 4;\n    else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n    else if (type == \"stat\" || type == \"form\") return lexical.indented + cx.unit;\n    else if (lexical.info == \"switch\" && !closing)\n      return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? cx.unit : 2 * cx.unit);\n    else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n    else return lexical.indented + (closing ? 0 : cx.unit);\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}}\n  }\n};\n\nconst hxml = {\n  name: \"hxml\",\n  startState: function () {\n    return {\n      define: false,\n      inString: false\n    };\n  },\n  token: function (stream, state) {\n    var ch = stream.peek();\n    var sol = stream.sol();\n\n    ///* comments */\n    if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n    if (sol && ch == \"-\") {\n      var style = \"variable-2\";\n\n      stream.eat(/-/);\n\n      if (stream.peek() == \"-\") {\n        stream.eat(/-/);\n        style = \"keyword a\";\n      }\n\n      if (stream.peek() == \"D\") {\n        stream.eat(/[D]/);\n        style = \"keyword c\";\n        state.define = true;\n      }\n\n      stream.eatWhile(/[A-Z]/i);\n      return style;\n    }\n\n    var ch = stream.peek();\n\n    if (state.inString == false && ch == \"'\") {\n      state.inString = true;\n      stream.next();\n    }\n\n    if (state.inString == true) {\n      if (stream.skipTo(\"'\")) {\n\n      } else {\n        stream.skipToEnd();\n      }\n\n      if (stream.peek() == \"'\") {\n        stream.next();\n        state.inString = false;\n      }\n\n      return \"string\";\n    }\n\n    stream.next();\n    return null;\n  },\n  languageData: {\n    commentTokens: {line: \"#\"}\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvaGF4ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0EsdUNBQXVDLDRCQUE0QixlQUFlO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlCQUFpQixNQUFNO0FBQzNCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsR0FBRztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsR0FBRztBQUN2QztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixHQUFHO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsSUFBSTtBQUNKO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSx1QkFBdUI7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCLHdCQUF3QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsRUFBRTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsdUJBQXVCO0FBQ25GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RCx1QkFBdUI7QUFDbkYsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1Qzs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLElBQUk7QUFDNUY7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0Isb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9oYXhlLmpzPzg1ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVG9rZW5pemVyXG5cbmZ1bmN0aW9uIGt3KHR5cGUpIHtyZXR1cm4ge3R5cGU6IHR5cGUsIHN0eWxlOiBcImtleXdvcmRcIn07fVxudmFyIEEgPSBrdyhcImtleXdvcmQgYVwiKSwgQiA9IGt3KFwia2V5d29yZCBiXCIpLCBDID0ga3coXCJrZXl3b3JkIGNcIik7XG52YXIgb3BlcmF0b3IgPSBrdyhcIm9wZXJhdG9yXCIpLCBhdG9tID0ge3R5cGU6IFwiYXRvbVwiLCBzdHlsZTogXCJhdG9tXCJ9LCBhdHRyaWJ1dGUgPSB7dHlwZTpcImF0dHJpYnV0ZVwiLCBzdHlsZTogXCJhdHRyaWJ1dGVcIn07XG52YXIgdHlwZSA9IGt3KFwidHlwZWRlZlwiKTtcbnZhciBrZXl3b3JkcyA9IHtcbiAgXCJpZlwiOiBBLCBcIndoaWxlXCI6IEEsIFwiZWxzZVwiOiBCLCBcImRvXCI6IEIsIFwidHJ5XCI6IEIsXG4gIFwicmV0dXJuXCI6IEMsIFwiYnJlYWtcIjogQywgXCJjb250aW51ZVwiOiBDLCBcIm5ld1wiOiBDLCBcInRocm93XCI6IEMsXG4gIFwidmFyXCI6IGt3KFwidmFyXCIpLCBcImlubGluZVwiOmF0dHJpYnV0ZSwgXCJzdGF0aWNcIjogYXR0cmlidXRlLCBcInVzaW5nXCI6a3coXCJpbXBvcnRcIiksXG4gIFwicHVibGljXCI6IGF0dHJpYnV0ZSwgXCJwcml2YXRlXCI6IGF0dHJpYnV0ZSwgXCJjYXN0XCI6IGt3KFwiY2FzdFwiKSwgXCJpbXBvcnRcIjoga3coXCJpbXBvcnRcIiksIFwibWFjcm9cIjoga3coXCJtYWNyb1wiKSxcbiAgXCJmdW5jdGlvblwiOiBrdyhcImZ1bmN0aW9uXCIpLCBcImNhdGNoXCI6IGt3KFwiY2F0Y2hcIiksIFwidW50eXBlZFwiOiBrdyhcInVudHlwZWRcIiksIFwiY2FsbGJhY2tcIjoga3coXCJjYlwiKSxcbiAgXCJmb3JcIjoga3coXCJmb3JcIiksIFwic3dpdGNoXCI6IGt3KFwic3dpdGNoXCIpLCBcImNhc2VcIjoga3coXCJjYXNlXCIpLCBcImRlZmF1bHRcIjoga3coXCJkZWZhdWx0XCIpLFxuICBcImluXCI6IG9wZXJhdG9yLCBcIm5ldmVyXCI6IGt3KFwicHJvcGVydHlfYWNjZXNzXCIpLCBcInRyYWNlXCI6a3coXCJ0cmFjZVwiKSxcbiAgXCJjbGFzc1wiOiB0eXBlLCBcImFic3RyYWN0XCI6dHlwZSwgXCJlbnVtXCI6dHlwZSwgXCJpbnRlcmZhY2VcIjp0eXBlLCBcInR5cGVkZWZcIjp0eXBlLCBcImV4dGVuZHNcIjp0eXBlLCBcImltcGxlbWVudHNcIjp0eXBlLCBcImR5bmFtaWNcIjp0eXBlLFxuICBcInRydWVcIjogYXRvbSwgXCJmYWxzZVwiOiBhdG9tLCBcIm51bGxcIjogYXRvbVxufTtcblxudmFyIGlzT3BlcmF0b3JDaGFyID0gL1srXFwtKiYlPTw+IT98XS87XG5cbmZ1bmN0aW9uIGNoYWluKHN0cmVhbSwgc3RhdGUsIGYpIHtcbiAgc3RhdGUudG9rZW5pemUgPSBmO1xuICByZXR1cm4gZihzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gdG9VbmVzY2FwZWQoc3RyZWFtLCBlbmQpIHtcbiAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dDtcbiAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgIGlmIChuZXh0ID09IGVuZCAmJiAhZXNjYXBlZClcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICB9XG59XG5cbi8vIFVzZWQgYXMgc2NyYXRjaCB2YXJpYWJsZXMgdG8gY29tbXVuaWNhdGUgbXVsdGlwbGUgdmFsdWVzIHdpdGhvdXRcbi8vIGNvbnNpbmcgdXAgdG9ucyBvZiBvYmplY3RzLlxudmFyIHR5cGUsIGNvbnRlbnQ7XG5mdW5jdGlvbiByZXQodHAsIHN0eWxlLCBjb250KSB7XG4gIHR5cGUgPSB0cDsgY29udGVudCA9IGNvbnQ7XG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gaGF4ZVRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gIGlmIChjaCA9PSAnXCInIHx8IGNoID09IFwiJ1wiKSB7XG4gICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIGhheGVUb2tlblN0cmluZyhjaCkpO1xuICB9IGVsc2UgaWYgKC9bXFxbXFxde31cXChcXCksO1xcOlxcLl0vLnRlc3QoY2gpKSB7XG4gICAgcmV0dXJuIHJldChjaCk7XG4gIH0gZWxzZSBpZiAoY2ggPT0gXCIwXCIgJiYgc3RyZWFtLmVhdCgveC9pKSkge1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcZGEtZl0vaSk7XG4gICAgcmV0dXJuIHJldChcIm51bWJlclwiLCBcIm51bWJlclwiKTtcbiAgfSBlbHNlIGlmICgvXFxkLy50ZXN0KGNoKSB8fCBjaCA9PSBcIi1cIiAmJiBzdHJlYW0uZWF0KC9cXGQvKSkge1xuICAgIHN0cmVhbS5tYXRjaCgvXlxcZCooPzpcXC5cXGQqKD8hXFwuKSk/KD86W2VFXVsrXFwtXT9cXGQrKT8vKTtcbiAgICByZXR1cm4gcmV0KFwibnVtYmVyXCIsIFwibnVtYmVyXCIpO1xuICB9IGVsc2UgaWYgKHN0YXRlLnJlQWxsb3dlZCAmJiAoY2ggPT0gXCJ+XCIgJiYgc3RyZWFtLmVhdCgvXFwvLykpKSB7XG4gICAgdG9VbmVzY2FwZWQoc3RyZWFtLCBcIi9cIik7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bZ2ltc3VdLyk7XG4gICAgcmV0dXJuIHJldChcInJlZ2V4cFwiLCBcInN0cmluZy5zcGVjaWFsXCIpO1xuICB9IGVsc2UgaWYgKGNoID09IFwiL1wiKSB7XG4gICAgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKSB7XG4gICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgaGF4ZVRva2VuQ29tbWVudCk7XG4gICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIHJldChcImNvbW1lbnRcIiwgXCJjb21tZW50XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoaXNPcGVyYXRvckNoYXIpO1xuICAgICAgcmV0dXJuIHJldChcIm9wZXJhdG9yXCIsIG51bGwsIHN0cmVhbS5jdXJyZW50KCkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjaCA9PSBcIiNcIikge1xuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICByZXR1cm4gcmV0KFwiY29uZGl0aW9uYWxcIiwgXCJtZXRhXCIpO1xuICB9IGVsc2UgaWYgKGNoID09IFwiQFwiKSB7XG4gICAgc3RyZWFtLmVhdCgvOi8pO1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd19dLyk7XG4gICAgcmV0dXJuIHJldCAoXCJtZXRhZGF0YVwiLCBcIm1ldGFcIik7XG4gIH0gZWxzZSBpZiAoaXNPcGVyYXRvckNoYXIudGVzdChjaCkpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoaXNPcGVyYXRvckNoYXIpO1xuICAgIHJldHVybiByZXQoXCJvcGVyYXRvclwiLCBudWxsLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgd29yZDtcbiAgICBpZigvW0EtWl0vLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdfPD5dLyk7XG4gICAgICB3b3JkID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgIHJldHVybiByZXQoXCJ0eXBlXCIsIFwidHlwZVwiLCB3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3X10vKTtcbiAgICAgIHZhciB3b3JkID0gc3RyZWFtLmN1cnJlbnQoKSwga25vd24gPSBrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZSh3b3JkKSAmJiBrZXl3b3Jkc1t3b3JkXTtcbiAgICAgIHJldHVybiAoa25vd24gJiYgc3RhdGUua3dBbGxvd2VkKSA/IHJldChrbm93bi50eXBlLCBrbm93bi5zdHlsZSwgd29yZCkgOlxuICAgICAgICByZXQoXCJ2YXJpYWJsZVwiLCBcInZhcmlhYmxlXCIsIHdvcmQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoYXhlVG9rZW5TdHJpbmcocXVvdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodG9VbmVzY2FwZWQoc3RyZWFtLCBxdW90ZSkpXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IGhheGVUb2tlbkJhc2U7XG4gICAgcmV0dXJuIHJldChcInN0cmluZ1wiLCBcInN0cmluZ1wiKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaGF4ZVRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgIGlmIChjaCA9PSBcIi9cIiAmJiBtYXliZUVuZCkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBoYXhlVG9rZW5CYXNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgfVxuICByZXR1cm4gcmV0KFwiY29tbWVudFwiLCBcImNvbW1lbnRcIik7XG59XG5cbi8vIFBhcnNlclxuXG52YXIgYXRvbWljVHlwZXMgPSB7XCJhdG9tXCI6IHRydWUsIFwibnVtYmVyXCI6IHRydWUsIFwidmFyaWFibGVcIjogdHJ1ZSwgXCJzdHJpbmdcIjogdHJ1ZSwgXCJyZWdleHBcIjogdHJ1ZX07XG5cbmZ1bmN0aW9uIEhheGVMZXhpY2FsKGluZGVudGVkLCBjb2x1bW4sIHR5cGUsIGFsaWduLCBwcmV2LCBpbmZvKSB7XG4gIHRoaXMuaW5kZW50ZWQgPSBpbmRlbnRlZDtcbiAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMucHJldiA9IHByZXY7XG4gIHRoaXMuaW5mbyA9IGluZm87XG4gIGlmIChhbGlnbiAhPSBudWxsKSB0aGlzLmFsaWduID0gYWxpZ247XG59XG5cbmZ1bmN0aW9uIGluU2NvcGUoc3RhdGUsIHZhcm5hbWUpIHtcbiAgZm9yICh2YXIgdiA9IHN0YXRlLmxvY2FsVmFyczsgdjsgdiA9IHYubmV4dClcbiAgICBpZiAodi5uYW1lID09IHZhcm5hbWUpIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBwYXJzZUhheGUoc3RhdGUsIHN0eWxlLCB0eXBlLCBjb250ZW50LCBzdHJlYW0pIHtcbiAgdmFyIGNjID0gc3RhdGUuY2M7XG4gIC8vIENvbW11bmljYXRlIG91ciBjb250ZXh0IHRvIHRoZSBjb21iaW5hdG9ycy5cbiAgLy8gKExlc3Mgd2FzdGVmdWwgdGhhbiBjb25zaW5nIHVwIGEgaHVuZHJlZCBjbG9zdXJlcyBvbiBldmVyeSBjYWxsLilcbiAgY3guc3RhdGUgPSBzdGF0ZTsgY3guc3RyZWFtID0gc3RyZWFtOyBjeC5tYXJrZWQgPSBudWxsLCBjeC5jYyA9IGNjO1xuXG4gIGlmICghc3RhdGUubGV4aWNhbC5oYXNPd25Qcm9wZXJ0eShcImFsaWduXCIpKVxuICAgIHN0YXRlLmxleGljYWwuYWxpZ24gPSB0cnVlO1xuXG4gIHdoaWxlKHRydWUpIHtcbiAgICB2YXIgY29tYmluYXRvciA9IGNjLmxlbmd0aCA/IGNjLnBvcCgpIDogc3RhdGVtZW50O1xuICAgIGlmIChjb21iaW5hdG9yKHR5cGUsIGNvbnRlbnQpKSB7XG4gICAgICB3aGlsZShjYy5sZW5ndGggJiYgY2NbY2MubGVuZ3RoIC0gMV0ubGV4KVxuICAgICAgICBjYy5wb3AoKSgpO1xuICAgICAgaWYgKGN4Lm1hcmtlZCkgcmV0dXJuIGN4Lm1hcmtlZDtcbiAgICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIiAmJiBpblNjb3BlKHN0YXRlLCBjb250ZW50KSkgcmV0dXJuIFwidmFyaWFibGVOYW1lLmxvY2FsXCI7XG4gICAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgJiYgaW1wb3J0ZWQoc3RhdGUsIGNvbnRlbnQpKSByZXR1cm4gXCJ2YXJpYWJsZU5hbWUuc3BlY2lhbFwiO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbXBvcnRlZChzdGF0ZSwgdHlwZW5hbWUpIHtcbiAgaWYgKC9bYS16XS8udGVzdCh0eXBlbmFtZS5jaGFyQXQoMCkpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgdmFyIGxlbiA9IHN0YXRlLmltcG9ydGVkdHlwZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaTxsZW47IGkrKylcbiAgICBpZihzdGF0ZS5pbXBvcnRlZHR5cGVzW2ldPT10eXBlbmFtZSkgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyaW1wb3J0KGltcG9ydG5hbWUpIHtcbiAgdmFyIHN0YXRlID0gY3guc3RhdGU7XG4gIGZvciAodmFyIHQgPSBzdGF0ZS5pbXBvcnRlZHR5cGVzOyB0OyB0ID0gdC5uZXh0KVxuICAgIGlmKHQubmFtZSA9PSBpbXBvcnRuYW1lKSByZXR1cm47XG4gIHN0YXRlLmltcG9ydGVkdHlwZXMgPSB7IG5hbWU6IGltcG9ydG5hbWUsIG5leHQ6IHN0YXRlLmltcG9ydGVkdHlwZXMgfTtcbn1cbi8vIENvbWJpbmF0b3IgdXRpbHNcblxudmFyIGN4ID0ge3N0YXRlOiBudWxsLCBjb2x1bW46IG51bGwsIG1hcmtlZDogbnVsbCwgY2M6IG51bGx9O1xuZnVuY3Rpb24gcGFzcygpIHtcbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgY3guY2MucHVzaChhcmd1bWVudHNbaV0pO1xufVxuZnVuY3Rpb24gY29udCgpIHtcbiAgcGFzcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGluTGlzdChuYW1lLCBsaXN0KSB7XG4gIGZvciAodmFyIHYgPSBsaXN0OyB2OyB2ID0gdi5uZXh0KVxuICAgIGlmICh2Lm5hbWUgPT0gbmFtZSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyKHZhcm5hbWUpIHtcbiAgdmFyIHN0YXRlID0gY3guc3RhdGU7XG4gIGlmIChzdGF0ZS5jb250ZXh0KSB7XG4gICAgY3gubWFya2VkID0gXCJkZWZcIjtcbiAgICBpZiAoaW5MaXN0KHZhcm5hbWUsIHN0YXRlLmxvY2FsVmFycykpIHJldHVybjtcbiAgICBzdGF0ZS5sb2NhbFZhcnMgPSB7bmFtZTogdmFybmFtZSwgbmV4dDogc3RhdGUubG9jYWxWYXJzfTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5nbG9iYWxWYXJzKSB7XG4gICAgaWYgKGluTGlzdCh2YXJuYW1lLCBzdGF0ZS5nbG9iYWxWYXJzKSkgcmV0dXJuO1xuICAgIHN0YXRlLmdsb2JhbFZhcnMgPSB7bmFtZTogdmFybmFtZSwgbmV4dDogc3RhdGUuZ2xvYmFsVmFyc307XG4gIH1cbn1cblxuLy8gQ29tYmluYXRvcnNcblxudmFyIGRlZmF1bHRWYXJzID0ge25hbWU6IFwidGhpc1wiLCBuZXh0OiBudWxsfTtcbmZ1bmN0aW9uIHB1c2hjb250ZXh0KCkge1xuICBpZiAoIWN4LnN0YXRlLmNvbnRleHQpIGN4LnN0YXRlLmxvY2FsVmFycyA9IGRlZmF1bHRWYXJzO1xuICBjeC5zdGF0ZS5jb250ZXh0ID0ge3ByZXY6IGN4LnN0YXRlLmNvbnRleHQsIHZhcnM6IGN4LnN0YXRlLmxvY2FsVmFyc307XG59XG5mdW5jdGlvbiBwb3Bjb250ZXh0KCkge1xuICBjeC5zdGF0ZS5sb2NhbFZhcnMgPSBjeC5zdGF0ZS5jb250ZXh0LnZhcnM7XG4gIGN4LnN0YXRlLmNvbnRleHQgPSBjeC5zdGF0ZS5jb250ZXh0LnByZXY7XG59XG5wb3Bjb250ZXh0LmxleCA9IHRydWU7XG5mdW5jdGlvbiBwdXNobGV4KHR5cGUsIGluZm8pIHtcbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGF0ZSA9IGN4LnN0YXRlO1xuICAgIHN0YXRlLmxleGljYWwgPSBuZXcgSGF4ZUxleGljYWwoc3RhdGUuaW5kZW50ZWQsIGN4LnN0cmVhbS5jb2x1bW4oKSwgdHlwZSwgbnVsbCwgc3RhdGUubGV4aWNhbCwgaW5mbyk7XG4gIH07XG4gIHJlc3VsdC5sZXggPSB0cnVlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcG9wbGV4KCkge1xuICB2YXIgc3RhdGUgPSBjeC5zdGF0ZTtcbiAgaWYgKHN0YXRlLmxleGljYWwucHJldikge1xuICAgIGlmIChzdGF0ZS5sZXhpY2FsLnR5cGUgPT0gXCIpXCIpXG4gICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmxleGljYWwuaW5kZW50ZWQ7XG4gICAgc3RhdGUubGV4aWNhbCA9IHN0YXRlLmxleGljYWwucHJldjtcbiAgfVxufVxucG9wbGV4LmxleCA9IHRydWU7XG5cbmZ1bmN0aW9uIGV4cGVjdCh3YW50ZWQpIHtcbiAgZnVuY3Rpb24gZih0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gd2FudGVkKSByZXR1cm4gY29udCgpO1xuICAgIGVsc2UgaWYgKHdhbnRlZCA9PSBcIjtcIikgcmV0dXJuIHBhc3MoKTtcbiAgICBlbHNlIHJldHVybiBjb250KGYpO1xuICB9XG4gIHJldHVybiBmO1xufVxuXG5mdW5jdGlvbiBzdGF0ZW1lbnQodHlwZSkge1xuICBpZiAodHlwZSA9PSBcIkBcIikgcmV0dXJuIGNvbnQobWV0YWRlZik7XG4gIGlmICh0eXBlID09IFwidmFyXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJ2YXJkZWZcIiksIHZhcmRlZjEsIGV4cGVjdChcIjtcIiksIHBvcGxleCk7XG4gIGlmICh0eXBlID09IFwia2V5d29yZCBhXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBleHByZXNzaW9uLCBzdGF0ZW1lbnQsIHBvcGxleCk7XG4gIGlmICh0eXBlID09IFwia2V5d29yZCBiXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBzdGF0ZW1lbnQsIHBvcGxleCk7XG4gIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gY29udChwdXNobGV4KFwifVwiKSwgcHVzaGNvbnRleHQsIGJsb2NrLCBwb3BsZXgsIHBvcGNvbnRleHQpO1xuICBpZiAodHlwZSA9PSBcIjtcIikgcmV0dXJuIGNvbnQoKTtcbiAgaWYgKHR5cGUgPT0gXCJhdHRyaWJ1dGVcIikgcmV0dXJuIGNvbnQobWF5YmVhdHRyaWJ1dGUpO1xuICBpZiAodHlwZSA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTtcbiAgaWYgKHR5cGUgPT0gXCJmb3JcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIGV4cGVjdChcIihcIiksIHB1c2hsZXgoXCIpXCIpLCBmb3JzcGVjMSwgZXhwZWN0KFwiKVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcGxleCwgc3RhdGVtZW50LCBwb3BsZXgpO1xuICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJzdGF0XCIpLCBtYXliZWxhYmVsKTtcbiAgaWYgKHR5cGUgPT0gXCJzd2l0Y2hcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIGV4cHJlc3Npb24sIHB1c2hsZXgoXCJ9XCIsIFwic3dpdGNoXCIpLCBleHBlY3QoXCJ7XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2ssIHBvcGxleCwgcG9wbGV4KTtcbiAgaWYgKHR5cGUgPT0gXCJjYXNlXCIpIHJldHVybiBjb250KGV4cHJlc3Npb24sIGV4cGVjdChcIjpcIikpO1xuICBpZiAodHlwZSA9PSBcImRlZmF1bHRcIikgcmV0dXJuIGNvbnQoZXhwZWN0KFwiOlwiKSk7XG4gIGlmICh0eXBlID09IFwiY2F0Y2hcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIHB1c2hjb250ZXh0LCBleHBlY3QoXCIoXCIpLCBmdW5hcmcsIGV4cGVjdChcIilcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCwgcG9wbGV4LCBwb3Bjb250ZXh0KTtcbiAgaWYgKHR5cGUgPT0gXCJpbXBvcnRcIikgcmV0dXJuIGNvbnQoaW1wb3J0ZGVmLCBleHBlY3QoXCI7XCIpKTtcbiAgaWYgKHR5cGUgPT0gXCJ0eXBlZGVmXCIpIHJldHVybiBjb250KHR5cGVkZWYpO1xuICByZXR1cm4gcGFzcyhwdXNobGV4KFwic3RhdFwiKSwgZXhwcmVzc2lvbiwgZXhwZWN0KFwiO1wiKSwgcG9wbGV4KTtcbn1cbmZ1bmN0aW9uIGV4cHJlc3Npb24odHlwZSkge1xuICBpZiAoYXRvbWljVHlwZXMuaGFzT3duUHJvcGVydHkodHlwZSkpIHJldHVybiBjb250KG1heWJlb3BlcmF0b3IpO1xuICBpZiAodHlwZSA9PSBcInR5cGVcIiApIHJldHVybiBjb250KG1heWJlb3BlcmF0b3IpO1xuICBpZiAodHlwZSA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTtcbiAgaWYgKHR5cGUgPT0gXCJrZXl3b3JkIGNcIikgcmV0dXJuIGNvbnQobWF5YmVleHByZXNzaW9uKTtcbiAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCIpXCIpLCBtYXliZWV4cHJlc3Npb24sIGV4cGVjdChcIilcIiksIHBvcGxleCwgbWF5YmVvcGVyYXRvcik7XG4gIGlmICh0eXBlID09IFwib3BlcmF0b3JcIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbik7XG4gIGlmICh0eXBlID09IFwiW1wiKSByZXR1cm4gY29udChwdXNobGV4KFwiXVwiKSwgY29tbWFzZXAobWF5YmVleHByZXNzaW9uLCBcIl1cIiksIHBvcGxleCwgbWF5YmVvcGVyYXRvcik7XG4gIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gY29udChwdXNobGV4KFwifVwiKSwgY29tbWFzZXAob2JqcHJvcCwgXCJ9XCIpLCBwb3BsZXgsIG1heWJlb3BlcmF0b3IpO1xuICByZXR1cm4gY29udCgpO1xufVxuZnVuY3Rpb24gbWF5YmVleHByZXNzaW9uKHR5cGUpIHtcbiAgaWYgKHR5cGUubWF0Y2goL1s7XFx9XFwpXFxdLF0vKSkgcmV0dXJuIHBhc3MoKTtcbiAgcmV0dXJuIHBhc3MoZXhwcmVzc2lvbik7XG59XG5cbmZ1bmN0aW9uIG1heWJlb3BlcmF0b3IodHlwZSwgdmFsdWUpIHtcbiAgaWYgKHR5cGUgPT0gXCJvcGVyYXRvclwiICYmIC9cXCtcXCt8LS0vLnRlc3QodmFsdWUpKSByZXR1cm4gY29udChtYXliZW9wZXJhdG9yKTtcbiAgaWYgKHR5cGUgPT0gXCJvcGVyYXRvclwiIHx8IHR5cGUgPT0gXCI6XCIpIHJldHVybiBjb250KGV4cHJlc3Npb24pO1xuICBpZiAodHlwZSA9PSBcIjtcIikgcmV0dXJuO1xuICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIilcIiksIGNvbW1hc2VwKGV4cHJlc3Npb24sIFwiKVwiKSwgcG9wbGV4LCBtYXliZW9wZXJhdG9yKTtcbiAgaWYgKHR5cGUgPT0gXCIuXCIpIHJldHVybiBjb250KHByb3BlcnR5LCBtYXliZW9wZXJhdG9yKTtcbiAgaWYgKHR5cGUgPT0gXCJbXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJdXCIpLCBleHByZXNzaW9uLCBleHBlY3QoXCJdXCIpLCBwb3BsZXgsIG1heWJlb3BlcmF0b3IpO1xufVxuXG5mdW5jdGlvbiBtYXliZWF0dHJpYnV0ZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IFwiYXR0cmlidXRlXCIpIHJldHVybiBjb250KG1heWJlYXR0cmlidXRlKTtcbiAgaWYgKHR5cGUgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gY29udChmdW5jdGlvbmRlZik7XG4gIGlmICh0eXBlID09IFwidmFyXCIpIHJldHVybiBjb250KHZhcmRlZjEpO1xufVxuXG5mdW5jdGlvbiBtZXRhZGVmKHR5cGUpIHtcbiAgaWYodHlwZSA9PSBcIjpcIikgcmV0dXJuIGNvbnQobWV0YWRlZik7XG4gIGlmKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gY29udChtZXRhZGVmKTtcbiAgaWYodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIilcIiksIGNvbW1hc2VwKG1ldGFhcmdzLCBcIilcIiksIHBvcGxleCwgc3RhdGVtZW50KTtcbn1cbmZ1bmN0aW9uIG1ldGFhcmdzKHR5cGUpIHtcbiAgaWYodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBjb250KCk7XG59XG5cbmZ1bmN0aW9uIGltcG9ydGRlZiAodHlwZSwgdmFsdWUpIHtcbiAgaWYodHlwZSA9PSBcInZhcmlhYmxlXCIgJiYgL1tBLVpdLy50ZXN0KHZhbHVlLmNoYXJBdCgwKSkpIHsgcmVnaXN0ZXJpbXBvcnQodmFsdWUpOyByZXR1cm4gY29udCgpOyB9XG4gIGVsc2UgaWYodHlwZSA9PSBcInZhcmlhYmxlXCIgfHwgdHlwZSA9PSBcInByb3BlcnR5XCIgfHwgdHlwZSA9PSBcIi5cIiB8fCB2YWx1ZSA9PSBcIipcIikgcmV0dXJuIGNvbnQoaW1wb3J0ZGVmKTtcbn1cblxuZnVuY3Rpb24gdHlwZWRlZiAodHlwZSwgdmFsdWUpXG57XG4gIGlmKHR5cGUgPT0gXCJ2YXJpYWJsZVwiICYmIC9bQS1aXS8udGVzdCh2YWx1ZS5jaGFyQXQoMCkpKSB7IHJlZ2lzdGVyaW1wb3J0KHZhbHVlKTsgcmV0dXJuIGNvbnQoKTsgfVxuICBlbHNlIGlmICh0eXBlID09IFwidHlwZVwiICYmIC9bQS1aXS8udGVzdCh2YWx1ZS5jaGFyQXQoMCkpKSB7IHJldHVybiBjb250KCk7IH1cbn1cblxuZnVuY3Rpb24gbWF5YmVsYWJlbCh0eXBlKSB7XG4gIGlmICh0eXBlID09IFwiOlwiKSByZXR1cm4gY29udChwb3BsZXgsIHN0YXRlbWVudCk7XG4gIHJldHVybiBwYXNzKG1heWJlb3BlcmF0b3IsIGV4cGVjdChcIjtcIiksIHBvcGxleCk7XG59XG5mdW5jdGlvbiBwcm9wZXJ0eSh0eXBlKSB7XG4gIGlmICh0eXBlID09IFwidmFyaWFibGVcIikge2N4Lm1hcmtlZCA9IFwicHJvcGVydHlcIjsgcmV0dXJuIGNvbnQoKTt9XG59XG5mdW5jdGlvbiBvYmpwcm9wKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSBjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7XG4gIGlmIChhdG9taWNUeXBlcy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgcmV0dXJuIGNvbnQoZXhwZWN0KFwiOlwiKSwgZXhwcmVzc2lvbik7XG59XG5mdW5jdGlvbiBjb21tYXNlcCh3aGF0LCBlbmQpIHtcbiAgZnVuY3Rpb24gcHJvY2VlZCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCIsXCIpIHJldHVybiBjb250KHdoYXQsIHByb2NlZWQpO1xuICAgIGlmICh0eXBlID09IGVuZCkgcmV0dXJuIGNvbnQoKTtcbiAgICByZXR1cm4gY29udChleHBlY3QoZW5kKSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBlbmQpIHJldHVybiBjb250KCk7XG4gICAgZWxzZSByZXR1cm4gcGFzcyh3aGF0LCBwcm9jZWVkKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJsb2NrKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gXCJ9XCIpIHJldHVybiBjb250KCk7XG4gIHJldHVybiBwYXNzKHN0YXRlbWVudCwgYmxvY2spO1xufVxuZnVuY3Rpb24gdmFyZGVmMSh0eXBlLCB2YWx1ZSkge1xuICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpe3JlZ2lzdGVyKHZhbHVlKTsgcmV0dXJuIGNvbnQodHlwZXVzZSwgdmFyZGVmMik7fVxuICByZXR1cm4gY29udCgpO1xufVxuZnVuY3Rpb24gdmFyZGVmMih0eXBlLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gXCI9XCIpIHJldHVybiBjb250KGV4cHJlc3Npb24sIHZhcmRlZjIpO1xuICBpZiAodHlwZSA9PSBcIixcIikgcmV0dXJuIGNvbnQodmFyZGVmMSk7XG59XG5mdW5jdGlvbiBmb3JzcGVjMSh0eXBlLCB2YWx1ZSkge1xuICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICByZWdpc3Rlcih2YWx1ZSk7XG4gICAgcmV0dXJuIGNvbnQoZm9yaW4sIGV4cHJlc3Npb24pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhc3MoKVxuICB9XG59XG5mdW5jdGlvbiBmb3JpbihfdHlwZSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IFwiaW5cIikgcmV0dXJuIGNvbnQoKTtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uZGVmKHR5cGUsIHZhbHVlKSB7XG4gIC8vZnVuY3Rpb24gbmFtZXMgc3RhcnRpbmcgd2l0aCB1cHBlci1jYXNlIGxldHRlcnMgYXJlIHJlY29nbmlzZWQgYXMgdHlwZXMsIHNvIGNsdWRnaW5nIHRoZW0gdG9nZXRoZXIgaGVyZS5cbiAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiIHx8IHR5cGUgPT0gXCJ0eXBlXCIpIHtyZWdpc3Rlcih2YWx1ZSk7IHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTt9XG4gIGlmICh2YWx1ZSA9PSBcIm5ld1wiKSByZXR1cm4gY29udChmdW5jdGlvbmRlZik7XG4gIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiKVwiKSwgcHVzaGNvbnRleHQsIGNvbW1hc2VwKGZ1bmFyZywgXCIpXCIpLCBwb3BsZXgsIHR5cGV1c2UsIHN0YXRlbWVudCwgcG9wY29udGV4dCk7XG59XG5mdW5jdGlvbiB0eXBldXNlKHR5cGUpIHtcbiAgaWYodHlwZSA9PSBcIjpcIikgcmV0dXJuIGNvbnQodHlwZXN0cmluZyk7XG59XG5mdW5jdGlvbiB0eXBlc3RyaW5nKHR5cGUpIHtcbiAgaWYodHlwZSA9PSBcInR5cGVcIikgcmV0dXJuIGNvbnQoKTtcbiAgaWYodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBjb250KCk7XG4gIGlmKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJ9XCIpLCBjb21tYXNlcCh0eXBlcHJvcCwgXCJ9XCIpLCBwb3BsZXgpO1xufVxuZnVuY3Rpb24gdHlwZXByb3AodHlwZSkge1xuICBpZih0eXBlID09IFwidmFyaWFibGVcIikgcmV0dXJuIGNvbnQodHlwZXVzZSk7XG59XG5mdW5jdGlvbiBmdW5hcmcodHlwZSwgdmFsdWUpIHtcbiAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSB7cmVnaXN0ZXIodmFsdWUpOyByZXR1cm4gY29udCh0eXBldXNlKTt9XG59XG5cbi8vIEludGVyZmFjZVxuZXhwb3J0IGNvbnN0IGhheGUgPSB7XG4gIG5hbWU6IFwiaGF4ZVwiLFxuICBzdGFydFN0YXRlOiBmdW5jdGlvbihpbmRlbnRVbml0KSB7XG4gICAgdmFyIGRlZmF1bHR0eXBlcyA9IFtcIkludFwiLCBcIkZsb2F0XCIsIFwiU3RyaW5nXCIsIFwiVm9pZFwiLCBcIlN0ZFwiLCBcIkJvb2xcIiwgXCJEeW5hbWljXCIsIFwiQXJyYXlcIl07XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgdG9rZW5pemU6IGhheGVUb2tlbkJhc2UsXG4gICAgICByZUFsbG93ZWQ6IHRydWUsXG4gICAgICBrd0FsbG93ZWQ6IHRydWUsXG4gICAgICBjYzogW10sXG4gICAgICBsZXhpY2FsOiBuZXcgSGF4ZUxleGljYWwoLWluZGVudFVuaXQsIDAsIFwiYmxvY2tcIiwgZmFsc2UpLFxuICAgICAgaW1wb3J0ZWR0eXBlczogZGVmYXVsdHR5cGVzLFxuICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgIGluZGVudGVkOiAwXG4gICAgfTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH0sXG5cbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICBpZiAoIXN0YXRlLmxleGljYWwuaGFzT3duUHJvcGVydHkoXCJhbGlnblwiKSlcbiAgICAgICAgc3RhdGUubGV4aWNhbC5hbGlnbiA9IGZhbHNlO1xuICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAodHlwZSA9PSBcImNvbW1lbnRcIikgcmV0dXJuIHN0eWxlO1xuICAgIHN0YXRlLnJlQWxsb3dlZCA9ICEhKHR5cGUgPT0gXCJvcGVyYXRvclwiIHx8IHR5cGUgPT0gXCJrZXl3b3JkIGNcIiB8fCB0eXBlLm1hdGNoKC9eW1xcW3t9XFwoLDs6XSQvKSk7XG4gICAgc3RhdGUua3dBbGxvd2VkID0gdHlwZSAhPSAnLic7XG4gICAgcmV0dXJuIHBhcnNlSGF4ZShzdGF0ZSwgc3R5bGUsIHR5cGUsIGNvbnRlbnQsIHN0cmVhbSk7XG4gIH0sXG5cbiAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBjeCkge1xuICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSBoYXhlVG9rZW5CYXNlKSByZXR1cm4gMDtcbiAgICB2YXIgZmlyc3RDaGFyID0gdGV4dEFmdGVyICYmIHRleHRBZnRlci5jaGFyQXQoMCksIGxleGljYWwgPSBzdGF0ZS5sZXhpY2FsO1xuICAgIGlmIChsZXhpY2FsLnR5cGUgPT0gXCJzdGF0XCIgJiYgZmlyc3RDaGFyID09IFwifVwiKSBsZXhpY2FsID0gbGV4aWNhbC5wcmV2O1xuICAgIHZhciB0eXBlID0gbGV4aWNhbC50eXBlLCBjbG9zaW5nID0gZmlyc3RDaGFyID09IHR5cGU7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJkZWZcIikgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyA0O1xuICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJmb3JtXCIgJiYgZmlyc3RDaGFyID09IFwie1wiKSByZXR1cm4gbGV4aWNhbC5pbmRlbnRlZDtcbiAgICBlbHNlIGlmICh0eXBlID09IFwic3RhdFwiIHx8IHR5cGUgPT0gXCJmb3JtXCIpIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgY3gudW5pdDtcbiAgICBlbHNlIGlmIChsZXhpY2FsLmluZm8gPT0gXCJzd2l0Y2hcIiAmJiAhY2xvc2luZylcbiAgICAgIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgKC9eKD86Y2FzZXxkZWZhdWx0KVxcYi8udGVzdCh0ZXh0QWZ0ZXIpID8gY3gudW5pdCA6IDIgKiBjeC51bml0KTtcbiAgICBlbHNlIGlmIChsZXhpY2FsLmFsaWduKSByZXR1cm4gbGV4aWNhbC5jb2x1bW4gKyAoY2xvc2luZyA/IDAgOiAxKTtcbiAgICBlbHNlIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgKGNsb3NpbmcgPyAwIDogY3gudW5pdCk7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgaW5kZW50T25JbnB1dDogL15cXHMqW3t9XSQvLFxuICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIi8vXCIsIGJsb2NrOiB7b3BlbjogXCIvKlwiLCBjbG9zZTogXCIqL1wifX1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGh4bWwgPSB7XG4gIG5hbWU6IFwiaHhtbFwiLFxuICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlZmluZTogZmFsc2UsXG4gICAgICBpblN0cmluZzogZmFsc2VcbiAgICB9O1xuICB9LFxuICB0b2tlbjogZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ucGVlaygpO1xuICAgIHZhciBzb2wgPSBzdHJlYW0uc29sKCk7XG5cbiAgICAvLy8qIGNvbW1lbnRzICovXG4gICAgaWYgKGNoID09IFwiI1wiKSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgfVxuICAgIGlmIChzb2wgJiYgY2ggPT0gXCItXCIpIHtcbiAgICAgIHZhciBzdHlsZSA9IFwidmFyaWFibGUtMlwiO1xuXG4gICAgICBzdHJlYW0uZWF0KC8tLyk7XG5cbiAgICAgIGlmIChzdHJlYW0ucGVlaygpID09IFwiLVwiKSB7XG4gICAgICAgIHN0cmVhbS5lYXQoLy0vKTtcbiAgICAgICAgc3R5bGUgPSBcImtleXdvcmQgYVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PSBcIkRcIikge1xuICAgICAgICBzdHJlYW0uZWF0KC9bRF0vKTtcbiAgICAgICAgc3R5bGUgPSBcImtleXdvcmQgY1wiO1xuICAgICAgICBzdGF0ZS5kZWZpbmUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tBLVpdL2kpO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cblxuICAgIHZhciBjaCA9IHN0cmVhbS5wZWVrKCk7XG5cbiAgICBpZiAoc3RhdGUuaW5TdHJpbmcgPT0gZmFsc2UgJiYgY2ggPT0gXCInXCIpIHtcbiAgICAgIHN0YXRlLmluU3RyaW5nID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmluU3RyaW5nID09IHRydWUpIHtcbiAgICAgIGlmIChzdHJlYW0uc2tpcFRvKFwiJ1wiKSkge1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJlYW0ucGVlaygpID09IFwiJ1wiKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHN0YXRlLmluU3RyaW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cblxuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIiNcIn1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/legacy-modes/mode/haxe.js\n"));

/***/ })

}]);