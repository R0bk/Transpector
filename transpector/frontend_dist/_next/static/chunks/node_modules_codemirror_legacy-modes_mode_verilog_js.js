"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_codemirror_legacy-modes_mode_verilog_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/verilog.js":
/*!***************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/verilog.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"tlv\": function() { return /* binding */ tlv; },\n/* harmony export */   \"verilog\": function() { return /* binding */ verilog; }\n/* harmony export */ });\nfunction mkVerilog(parserConfig) {\n\n  var statementIndentUnit = parserConfig.statementIndentUnit,\n      dontAlignCalls = parserConfig.dontAlignCalls,\n      noIndentKeywords = parserConfig.noIndentKeywords || [],\n      multiLineStrings = parserConfig.multiLineStrings,\n      hooks = parserConfig.hooks || {};\n\n  function words(str) {\n    var obj = {}, words = str.split(\" \");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n\n  /**\n   * Keywords from IEEE 1800-2012\n   */\n  var keywords = words(\n    \"accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind \" +\n      \"bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config \" +\n      \"const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable \" +\n      \"dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup \" +\n      \"endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask \" +\n      \"enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin \" +\n      \"function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import \" +\n      \"incdir include initial inout input inside instance int integer interconnect interface intersect join join_any \" +\n      \"join_none large let liblist library local localparam logic longint macromodule matches medium modport module \" +\n      \"nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed \" +\n      \"parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup \" +\n      \"pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg \" +\n      \"reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime \" +\n      \"s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify \" +\n      \"specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on \" +\n      \"table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior \" +\n      \"trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void \" +\n      \"wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor\");\n\n  /** Operators from IEEE 1800-2012\n      unary_operator ::=\n      + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n      binary_operator ::=\n      + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **\n      | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<\n      | -> | <->\n      inc_or_dec_operator ::= ++ | --\n      unary_module_path_operator ::=\n      ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n      binary_module_path_operator ::=\n      == | != | && | || | & | | | ^ | ^~ | ~^\n  */\n  var isOperatorChar = /[\\+\\-\\*\\/!~&|^%=?:]/;\n  var isBracketChar = /[\\[\\]{}()]/;\n\n  var unsignedNumber = /\\d[0-9_]*/;\n  var decimalLiteral = /\\d*\\s*'s?d\\s*\\d[0-9_]*/i;\n  var binaryLiteral = /\\d*\\s*'s?b\\s*[xz01][xz01_]*/i;\n  var octLiteral = /\\d*\\s*'s?o\\s*[xz0-7][xz0-7_]*/i;\n  var hexLiteral = /\\d*\\s*'s?h\\s*[0-9a-fxz?][0-9a-fxz?_]*/i;\n  var realLiteral = /(\\d[\\d_]*(\\.\\d[\\d_]*)?E-?[\\d_]+)|(\\d[\\d_]*\\.\\d[\\d_]*)/i;\n\n  var closingBracketOrWord = /^((\\w+)|[)}\\]])/;\n  var closingBracket = /[)}\\]]/;\n\n  var curPunc;\n  var curKeyword;\n\n  // Block openings which are closed by a matching keyword in the form of (\"end\" + keyword)\n  // E.g. \"task\" => \"endtask\"\n  var blockKeywords = words(\n    \"case checker class clocking config function generate interface module package \" +\n      \"primitive program property specify sequence table task\"\n  );\n\n  // Opening/closing pairs\n  var openClose = {};\n  for (var keyword in blockKeywords) {\n    openClose[keyword] = \"end\" + keyword;\n  }\n  openClose[\"begin\"] = \"end\";\n  openClose[\"casex\"] = \"endcase\";\n  openClose[\"casez\"] = \"endcase\";\n  openClose[\"do\"   ] = \"while\";\n  openClose[\"fork\" ] = \"join;join_any;join_none\";\n  openClose[\"covergroup\"] = \"endgroup\";\n\n  for (var i in noIndentKeywords) {\n    var keyword = noIndentKeywords[i];\n    if (openClose[keyword]) {\n      openClose[keyword] = undefined;\n    }\n  }\n\n  // Keywords which open statements that are ended with a semi-colon\n  var statementKeywords = words(\"always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while\");\n\n  function tokenBase(stream, state) {\n    var ch = stream.peek(), style;\n    if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;\n    if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false)\n      return style;\n\n    if (/[,;:\\.]/.test(ch)) {\n      curPunc = stream.next();\n      return null;\n    }\n    if (isBracketChar.test(ch)) {\n      curPunc = stream.next();\n      return \"bracket\";\n    }\n    // Macros (tick-defines)\n    if (ch == '`') {\n      stream.next();\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"def\";\n      } else {\n        return null;\n      }\n    }\n    // System calls\n    if (ch == '$') {\n      stream.next();\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"meta\";\n      } else {\n        return null;\n      }\n    }\n    // Time literals\n    if (ch == '#') {\n      stream.next();\n      stream.eatWhile(/[\\d_.]/);\n      return \"def\";\n    }\n    // Strings\n    if (ch == '\"') {\n      stream.next();\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n    // Comments\n    if (ch == \"/\") {\n      stream.next();\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n      if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      stream.backUp(1);\n    }\n\n    // Numeric literals\n    if (stream.match(realLiteral) ||\n        stream.match(decimalLiteral) ||\n        stream.match(binaryLiteral) ||\n        stream.match(octLiteral) ||\n        stream.match(hexLiteral) ||\n        stream.match(unsignedNumber) ||\n        stream.match(realLiteral)) {\n      return \"number\";\n    }\n\n    // Operators\n    if (stream.eatWhile(isOperatorChar)) {\n      return \"meta\";\n    }\n\n    // Keywords / plain variables\n    if (stream.eatWhile(/[\\w\\$_]/)) {\n      var cur = stream.current();\n      if (keywords[cur]) {\n        if (openClose[cur]) {\n          curPunc = \"newblock\";\n        }\n        if (statementKeywords[cur]) {\n          curPunc = \"newstatement\";\n        }\n        curKeyword = cur;\n        return \"keyword\";\n      }\n      return \"variable\";\n    }\n\n    stream.next();\n    return null;\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next, end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {end = true; break;}\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (end || !(escaped || multiLineStrings))\n        state.tokenize = tokenBase;\n      return \"string\";\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return \"comment\";\n  }\n\n  function Context(indented, column, type, align, prev) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.align = align;\n    this.prev = prev;\n  }\n  function pushContext(state, col, type) {\n    var indent = state.indented;\n    var c = new Context(indent, col, type, null, state.context);\n    return state.context = c;\n  }\n  function popContext(state) {\n    var t = state.context.type;\n    if (t == \")\" || t == \"]\" || t == \"}\") {\n      state.indented = state.context.indented;\n    }\n    return state.context = state.context.prev;\n  }\n\n  function isClosing(text, contextClosing) {\n    if (text == contextClosing) {\n      return true;\n    } else {\n      // contextClosing may be multiple keywords separated by ;\n      var closingKeywords = contextClosing.split(\";\");\n      for (var i in closingKeywords) {\n        if (text == closingKeywords[i]) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  function buildElectricInputRegEx() {\n    // Reindentation should occur on any bracket char: {}()[]\n    // or on a match of any of the block closing keywords, at\n    // the end of a line\n    var allClosings = [];\n    for (var i in openClose) {\n      if (openClose[i]) {\n        var closings = openClose[i].split(\";\");\n        for (var j in closings) {\n          allClosings.push(closings[j]);\n        }\n      }\n    }\n    var re = new RegExp(\"[{}()\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n    return re;\n  }\n\n  // Interface\n  return {\n    name: \"verilog\",\n\n    startState: function(indentUnit) {\n      var state = {\n        tokenize: null,\n        context: new Context(-indentUnit, 0, \"top\", false),\n        indented: 0,\n        startOfLine: true\n      };\n      if (hooks.startState) hooks.startState(state);\n      return state;\n    },\n\n    token: function(stream, state) {\n      var ctx = state.context;\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n      }\n      if (hooks.token) {\n        // Call hook, with an optional return value of a style to override verilog styling.\n        var style = hooks.token(stream, state);\n        if (style !== undefined) {\n          return style;\n        }\n      }\n      if (stream.eatSpace()) return null;\n      curPunc = null;\n      curKeyword = null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style == \"comment\" || style == \"meta\" || style == \"variable\") return style;\n      if (ctx.align == null) ctx.align = true;\n\n      if (curPunc == ctx.type) {\n        popContext(state);\n      } else if ((curPunc == \";\" && ctx.type == \"statement\") ||\n                 (ctx.type && isClosing(curKeyword, ctx.type))) {\n        ctx = popContext(state);\n        while (ctx && ctx.type == \"statement\") ctx = popContext(state);\n      } else if (curPunc == \"{\") {\n        pushContext(state, stream.column(), \"}\");\n      } else if (curPunc == \"[\") {\n        pushContext(state, stream.column(), \"]\");\n      } else if (curPunc == \"(\") {\n        pushContext(state, stream.column(), \")\");\n      } else if (ctx && ctx.type == \"endcase\" && curPunc == \":\") {\n        pushContext(state, stream.column(), \"statement\");\n      } else if (curPunc == \"newstatement\") {\n        pushContext(state, stream.column(), \"statement\");\n      } else if (curPunc == \"newblock\") {\n        if (curKeyword == \"function\" && ctx && (ctx.type == \"statement\" || ctx.type == \"endgroup\")) {\n          // The 'function' keyword can appear in some other contexts where it actually does not\n          // indicate a function (import/export DPI and covergroup definitions).\n          // Do nothing in this case\n        } else if (curKeyword == \"task\" && ctx && ctx.type == \"statement\") {\n          // Same thing for task\n        } else {\n          var close = openClose[curKeyword];\n          pushContext(state, stream.column(), close);\n        }\n      }\n\n      state.startOfLine = false;\n      return style;\n    },\n\n    indent: function(state, textAfter, cx) {\n      if (state.tokenize != tokenBase && state.tokenize != null) return null;\n      if (hooks.indent) {\n        var fromHook = hooks.indent(state);\n        if (fromHook >= 0) return fromHook;\n      }\n      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\n      if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n      var closing = false;\n      var possibleClosing = textAfter.match(closingBracketOrWord);\n      if (possibleClosing)\n        closing = isClosing(possibleClosing[0], ctx.type);\n      if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit || cx.unit);\n      else if (closingBracket.test(ctx.type) && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);\n      else if (ctx.type == \")\" && !closing) return ctx.indented + (statementIndentUnit || cx.unit);\n      else return ctx.indented + (closing ? 0 : cx.unit);\n    },\n\n    languageData: {\n      indentOnInput: buildElectricInputRegEx(),\n      commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}}\n    }\n  };\n};\n\nconst verilog = mkVerilog({})\n\n// TL-Verilog mode.\n// See tl-x.org for language spec.\n// See the mode in action at makerchip.com.\n// Contact: steve.hoover@redwoodeda.com\n\n// TLV Identifier prefixes.\n// Note that sign is not treated separately, so \"+/-\" versions of numeric identifiers\n// are included.\nvar tlvIdentifierStyle = {\n  \"|\": \"link\",\n  \">\": \"property\",  // Should condition this off for > TLV 1c.\n  \"$\": \"variable\",\n  \"$$\": \"variable\",\n  \"?$\": \"qualifier\",\n  \"?*\": \"qualifier\",\n  \"-\": \"contentSeparator\",\n  \"/\": \"property\",\n  \"/-\": \"property\",\n  \"@\": \"variableName.special\",\n  \"@-\": \"variableName.special\",\n  \"@++\": \"variableName.special\",\n  \"@+=\": \"variableName.special\",\n  \"@+=-\": \"variableName.special\",\n  \"@--\": \"variableName.special\",\n  \"@-=\": \"variableName.special\",\n  \"%+\": \"tag\",\n  \"%-\": \"tag\",\n  \"%\": \"tag\",\n  \">>\": \"tag\",\n  \"<<\": \"tag\",\n  \"<>\": \"tag\",\n  \"#\": \"tag\",  // Need to choose a style for this.\n  \"^\": \"attribute\",\n  \"^^\": \"attribute\",\n  \"^!\": \"attribute\",\n  \"*\": \"variable\",\n  \"**\": \"variable\",\n  \"\\\\\": \"keyword\",\n  \"\\\"\": \"comment\"\n};\n\n// Lines starting with these characters define scope (result in indentation).\nvar tlvScopePrefixChars = {\n  \"/\": \"beh-hier\",\n  \">\": \"beh-hier\",\n  \"-\": \"phys-hier\",\n  \"|\": \"pipe\",\n  \"?\": \"when\",\n  \"@\": \"stage\",\n  \"\\\\\": \"keyword\"\n};\nvar tlvIndentUnit = 3;\nvar tlvTrackStatements = false;\nvar tlvIdentMatch = /^([~!@#\\$%\\^&\\*-\\+=\\?\\/\\\\\\|'\"<>]+)([\\d\\w_]*)/;  // Matches an identifier.\n// Note that ':' is excluded, because of it's use in [:].\nvar tlvLineIndentationMatch = /^[! ] */;\nvar tlvCommentMatch = /^\\/[\\/\\*]/;\n\nconst tlv = mkVerilog({\n  hooks: {\n    electricInput: false,\n\n    // Return undefined for verilog tokenizing, or style for TLV token (null not used).\n    // Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting\n    // can be enabled with the definition of cm-tlv-* styles, including highlighting for:\n    //   - M4 tokens\n    //   - TLV scope indentation\n    //   - Statement delimitation (enabled by tlvTrackStatements)\n    token: function(stream, state) {\n      var style = undefined;\n      var match;  // Return value of pattern matches.\n\n      // Set highlighting mode based on code region (TLV or SV).\n      if (stream.sol() && ! state.tlvInBlockComment) {\n        // Process region.\n        if (stream.peek() == '\\\\') {\n          style = \"def\";\n          stream.skipToEnd();\n          if (stream.string.match(/\\\\SV/)) {\n            state.tlvCodeActive = false;\n          } else if (stream.string.match(/\\\\TLV/)){\n            state.tlvCodeActive = true;\n          }\n        }\n        // Correct indentation in the face of a line prefix char.\n        if (state.tlvCodeActive && stream.pos == 0 &&\n            (state.indented == 0) && (match = stream.match(tlvLineIndentationMatch, false))) {\n          state.indented = match[0].length;\n        }\n\n        // Compute indentation state:\n        //   o Auto indentation on next line\n        //   o Indentation scope styles\n        var indented = state.indented;\n        var depth = indented / tlvIndentUnit;\n        if (depth <= state.tlvIndentationStyle.length) {\n          // not deeper than current scope\n\n          var blankline = stream.string.length == indented;\n          var chPos = depth * tlvIndentUnit;\n          if (chPos < stream.string.length) {\n            var bodyString = stream.string.slice(chPos);\n            var ch = bodyString[0];\n            if (tlvScopePrefixChars[ch] && ((match = bodyString.match(tlvIdentMatch)) &&\n                                            tlvIdentifierStyle[match[1]])) {\n              // This line begins scope.\n              // Next line gets indented one level.\n              indented += tlvIndentUnit;\n              // Style the next level of indentation (except non-region keyword identifiers,\n              //   which are statements themselves)\n              if (!(ch == \"\\\\\" && chPos > 0)) {\n                state.tlvIndentationStyle[depth] = tlvScopePrefixChars[ch];\n                if (tlvTrackStatements) {state.statementComment = false;}\n                depth++;\n              }\n            }\n          }\n          // Clear out deeper indentation levels unless line is blank.\n          if (!blankline) {\n            while (state.tlvIndentationStyle.length > depth) {\n              state.tlvIndentationStyle.pop();\n            }\n          }\n        }\n        // Set next level of indentation.\n        state.tlvNextIndent = indented;\n      }\n\n      if (state.tlvCodeActive) {\n        // Highlight as TLV.\n\n        var beginStatement = false;\n        if (tlvTrackStatements) {\n          // This starts a statement if the position is at the scope level\n          // and we're not within a statement leading comment.\n          beginStatement =\n            (stream.peek() != \" \") &&   // not a space\n            (style === undefined) &&    // not a region identifier\n            !state.tlvInBlockComment && // not in block comment\n            //!stream.match(tlvCommentMatch, false) && // not comment start\n          (stream.column() == state.tlvIndentationStyle.length * tlvIndentUnit);  // at scope level\n          if (beginStatement) {\n            if (state.statementComment) {\n              // statement already started by comment\n              beginStatement = false;\n            }\n            state.statementComment =\n              stream.match(tlvCommentMatch, false); // comment start\n          }\n        }\n\n        var match;\n        if (style !== undefined) {\n        } else if (state.tlvInBlockComment) {\n          // In a block comment.\n          if (stream.match(/^.*?\\*\\//)) {\n            // Exit block comment.\n            state.tlvInBlockComment = false;\n            if (tlvTrackStatements && !stream.eol()) {\n              // Anything after comment is assumed to be real statement content.\n              state.statementComment = false;\n            }\n          } else {\n            stream.skipToEnd();\n          }\n          style = \"comment\";\n        } else if ((match = stream.match(tlvCommentMatch)) && !state.tlvInBlockComment) {\n          // Start comment.\n          if (match[0] == \"//\") {\n            // Line comment.\n            stream.skipToEnd();\n          } else {\n            // Block comment.\n            state.tlvInBlockComment = true;\n          }\n          style = \"comment\";\n        } else if (match = stream.match(tlvIdentMatch)) {\n          // looks like an identifier (or identifier prefix)\n          var prefix = match[1];\n          var mnemonic = match[2];\n          if (// is identifier prefix\n            tlvIdentifierStyle.hasOwnProperty(prefix) &&\n              // has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)\n            (mnemonic.length > 0 || stream.eol())) {\n            style = tlvIdentifierStyle[prefix];\n          } else {\n            // Just swallow one character and try again.\n            // This enables subsequent identifier match with preceding symbol character, which\n            //   is legal within a statement.  (Eg, !$reset).  It also enables detection of\n            //   comment start with preceding symbols.\n            stream.backUp(stream.current().length - 1);\n          }\n        } else if (stream.match(/^\\t+/)) {\n          // Highlight tabs, which are illegal.\n          style = \"invalid\";\n        } else if (stream.match(/^[\\[\\]{}\\(\\);\\:]+/)) {\n          // [:], (), {}, ;.\n          style = \"meta\";\n        } else if (match = stream.match(/^[mM]4([\\+_])?[\\w\\d_]*/)) {\n          // m4 pre proc\n          style = (match[1] == \"+\") ? \"keyword.special\" : \"keyword\";\n        } else if (stream.match(/^ +/)){\n          // Skip over spaces.\n          if (stream.eol()) {\n            // Trailing spaces.\n            style = \"error\";\n          }\n        } else if (stream.match(/^[\\w\\d_]+/)) {\n          // alpha-numeric token.\n          style = \"number\";\n        } else {\n          // Eat the next char w/ no formatting.\n          stream.next();\n        }\n      } else {\n        if (stream.match(/^[mM]4([\\w\\d_]*)/)) {\n          // m4 pre proc\n          style = \"keyword\";\n        }\n      }\n      return style;\n    },\n\n    indent: function(state) {\n      return (state.tlvCodeActive == true) ? state.tlvNextIndent : -1;\n    },\n\n    startState: function(state) {\n      state.tlvIndentationStyle = [];  // Styles to use for each level of indentation.\n      state.tlvCodeActive = true;  // True when we're in a TLV region (and at beginning of file).\n      state.tlvNextIndent = -1;    // The number of spaces to autoindent the next line if tlvCodeActive.\n      state.tlvInBlockComment = false;  // True inside /**/ comment.\n      if (tlvTrackStatements) {\n        state.statementComment = false;  // True inside a statement's header comment.\n      }\n    }\n\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvdmVyaWxvZy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEIsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekMsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVSwrQkFBK0IsS0FBSztBQUM5Qyx3QkFBd0IsR0FBRztBQUMzQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHVDQUF1QztBQUN2QyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLHdDQUF3QztBQUN4QztBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvdmVyaWxvZy5qcz8zZDQwIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG1rVmVyaWxvZyhwYXJzZXJDb25maWcpIHtcblxuICB2YXIgc3RhdGVtZW50SW5kZW50VW5pdCA9IHBhcnNlckNvbmZpZy5zdGF0ZW1lbnRJbmRlbnRVbml0LFxuICAgICAgZG9udEFsaWduQ2FsbHMgPSBwYXJzZXJDb25maWcuZG9udEFsaWduQ2FsbHMsXG4gICAgICBub0luZGVudEtleXdvcmRzID0gcGFyc2VyQ29uZmlnLm5vSW5kZW50S2V5d29yZHMgfHwgW10sXG4gICAgICBtdWx0aUxpbmVTdHJpbmdzID0gcGFyc2VyQ29uZmlnLm11bHRpTGluZVN0cmluZ3MsXG4gICAgICBob29rcyA9IHBhcnNlckNvbmZpZy5ob29rcyB8fCB7fTtcblxuICBmdW5jdGlvbiB3b3JkcyhzdHIpIHtcbiAgICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSBvYmpbd29yZHNbaV1dID0gdHJ1ZTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgLyoqXG4gICAqIEtleXdvcmRzIGZyb20gSUVFRSAxODAwLTIwMTJcbiAgICovXG4gIHZhciBrZXl3b3JkcyA9IHdvcmRzKFxuICAgIFwiYWNjZXB0X29uIGFsaWFzIGFsd2F5cyBhbHdheXNfY29tYiBhbHdheXNfZmYgYWx3YXlzX2xhdGNoIGFuZCBhc3NlcnQgYXNzaWduIGFzc3VtZSBhdXRvbWF0aWMgYmVmb3JlIGJlZ2luIGJpbmQgXCIgK1xuICAgICAgXCJiaW5zIGJpbnNvZiBiaXQgYnJlYWsgYnVmIGJ1ZmlmMCBidWZpZjEgYnl0ZSBjYXNlIGNhc2V4IGNhc2V6IGNlbGwgY2hhbmRsZSBjaGVja2VyIGNsYXNzIGNsb2NraW5nIGNtb3MgY29uZmlnIFwiICtcbiAgICAgIFwiY29uc3QgY29uc3RyYWludCBjb250ZXh0IGNvbnRpbnVlIGNvdmVyIGNvdmVyZ3JvdXAgY292ZXJwb2ludCBjcm9zcyBkZWFzc2lnbiBkZWZhdWx0IGRlZnBhcmFtIGRlc2lnbiBkaXNhYmxlIFwiICtcbiAgICAgIFwiZGlzdCBkbyBlZGdlIGVsc2UgZW5kIGVuZGNhc2UgZW5kY2hlY2tlciBlbmRjbGFzcyBlbmRjbG9ja2luZyBlbmRjb25maWcgZW5kZnVuY3Rpb24gZW5kZ2VuZXJhdGUgZW5kZ3JvdXAgXCIgK1xuICAgICAgXCJlbmRpbnRlcmZhY2UgZW5kbW9kdWxlIGVuZHBhY2thZ2UgZW5kcHJpbWl0aXZlIGVuZHByb2dyYW0gZW5kcHJvcGVydHkgZW5kc3BlY2lmeSBlbmRzZXF1ZW5jZSBlbmR0YWJsZSBlbmR0YXNrIFwiICtcbiAgICAgIFwiZW51bSBldmVudCBldmVudHVhbGx5IGV4cGVjdCBleHBvcnQgZXh0ZW5kcyBleHRlcm4gZmluYWwgZmlyc3RfbWF0Y2ggZm9yIGZvcmNlIGZvcmVhY2ggZm9yZXZlciBmb3JrIGZvcmtqb2luIFwiICtcbiAgICAgIFwiZnVuY3Rpb24gZ2VuZXJhdGUgZ2VudmFyIGdsb2JhbCBoaWdoejAgaGlnaHoxIGlmIGlmZiBpZm5vbmUgaWdub3JlX2JpbnMgaWxsZWdhbF9iaW5zIGltcGxlbWVudHMgaW1wbGllcyBpbXBvcnQgXCIgK1xuICAgICAgXCJpbmNkaXIgaW5jbHVkZSBpbml0aWFsIGlub3V0IGlucHV0IGluc2lkZSBpbnN0YW5jZSBpbnQgaW50ZWdlciBpbnRlcmNvbm5lY3QgaW50ZXJmYWNlIGludGVyc2VjdCBqb2luIGpvaW5fYW55IFwiICtcbiAgICAgIFwiam9pbl9ub25lIGxhcmdlIGxldCBsaWJsaXN0IGxpYnJhcnkgbG9jYWwgbG9jYWxwYXJhbSBsb2dpYyBsb25naW50IG1hY3JvbW9kdWxlIG1hdGNoZXMgbWVkaXVtIG1vZHBvcnQgbW9kdWxlIFwiICtcbiAgICAgIFwibmFuZCBuZWdlZGdlIG5ldHR5cGUgbmV3IG5leHR0aW1lIG5tb3Mgbm9yIG5vc2hvd2NhbmNlbGxlZCBub3Qgbm90aWYwIG5vdGlmMSBudWxsIG9yIG91dHB1dCBwYWNrYWdlIHBhY2tlZCBcIiArXG4gICAgICBcInBhcmFtZXRlciBwbW9zIHBvc2VkZ2UgcHJpbWl0aXZlIHByaW9yaXR5IHByb2dyYW0gcHJvcGVydHkgcHJvdGVjdGVkIHB1bGwwIHB1bGwxIHB1bGxkb3duIHB1bGx1cCBcIiArXG4gICAgICBcInB1bHNlc3R5bGVfb25kZXRlY3QgcHVsc2VzdHlsZV9vbmV2ZW50IHB1cmUgcmFuZCByYW5kYyByYW5kY2FzZSByYW5kc2VxdWVuY2UgcmNtb3MgcmVhbCByZWFsdGltZSByZWYgcmVnIFwiICtcbiAgICAgIFwicmVqZWN0X29uIHJlbGVhc2UgcmVwZWF0IHJlc3RyaWN0IHJldHVybiBybm1vcyBycG1vcyBydHJhbiBydHJhbmlmMCBydHJhbmlmMSBzX2Fsd2F5cyBzX2V2ZW50dWFsbHkgc19uZXh0dGltZSBcIiArXG4gICAgICBcInNfdW50aWwgc191bnRpbF93aXRoIHNjYWxhcmVkIHNlcXVlbmNlIHNob3J0aW50IHNob3J0cmVhbCBzaG93Y2FuY2VsbGVkIHNpZ25lZCBzbWFsbCBzb2Z0IHNvbHZlIHNwZWNpZnkgXCIgK1xuICAgICAgXCJzcGVjcGFyYW0gc3RhdGljIHN0cmluZyBzdHJvbmcgc3Ryb25nMCBzdHJvbmcxIHN0cnVjdCBzdXBlciBzdXBwbHkwIHN1cHBseTEgc3luY19hY2NlcHRfb24gc3luY19yZWplY3Rfb24gXCIgK1xuICAgICAgXCJ0YWJsZSB0YWdnZWQgdGFzayB0aGlzIHRocm91Z2hvdXQgdGltZSB0aW1lcHJlY2lzaW9uIHRpbWV1bml0IHRyYW4gdHJhbmlmMCB0cmFuaWYxIHRyaSB0cmkwIHRyaTEgdHJpYW5kIHRyaW9yIFwiICtcbiAgICAgIFwidHJpcmVnIHR5cGUgdHlwZWRlZiB1bmlvbiB1bmlxdWUgdW5pcXVlMCB1bnNpZ25lZCB1bnRpbCB1bnRpbF93aXRoIHVudHlwZWQgdXNlIHV3aXJlIHZhciB2ZWN0b3JlZCB2aXJ0dWFsIHZvaWQgXCIgK1xuICAgICAgXCJ3YWl0IHdhaXRfb3JkZXIgd2FuZCB3ZWFrIHdlYWswIHdlYWsxIHdoaWxlIHdpbGRjYXJkIHdpcmUgd2l0aCB3aXRoaW4gd29yIHhub3IgeG9yXCIpO1xuXG4gIC8qKiBPcGVyYXRvcnMgZnJvbSBJRUVFIDE4MDAtMjAxMlxuICAgICAgdW5hcnlfb3BlcmF0b3IgOjo9XG4gICAgICArIHwgLSB8ICEgfCB+IHwgJiB8IH4mIHwgfCB8IH58IHwgXiB8IH5eIHwgXn5cbiAgICAgIGJpbmFyeV9vcGVyYXRvciA6Oj1cbiAgICAgICsgfCAtIHwgKiB8IC8gfCAlIHwgPT0gfCAhPSB8ID09PSB8ICE9PSB8ID09PyB8ICE9PyB8ICYmIHwgfHwgfCAqKlxuICAgICAgfCA8IHwgPD0gfCA+IHwgPj0gfCAmIHwgfCB8IF4gfCBefiB8IH5eIHwgPj4gfCA8PCB8ID4+PiB8IDw8PFxuICAgICAgfCAtPiB8IDwtPlxuICAgICAgaW5jX29yX2RlY19vcGVyYXRvciA6Oj0gKysgfCAtLVxuICAgICAgdW5hcnlfbW9kdWxlX3BhdGhfb3BlcmF0b3IgOjo9XG4gICAgICAhIHwgfiB8ICYgfCB+JiB8IHwgfCB+fCB8IF4gfCB+XiB8IF5+XG4gICAgICBiaW5hcnlfbW9kdWxlX3BhdGhfb3BlcmF0b3IgOjo9XG4gICAgICA9PSB8ICE9IHwgJiYgfCB8fCB8ICYgfCB8IHwgXiB8IF5+IHwgfl5cbiAgKi9cbiAgdmFyIGlzT3BlcmF0b3JDaGFyID0gL1tcXCtcXC1cXCpcXC8hfiZ8XiU9PzpdLztcbiAgdmFyIGlzQnJhY2tldENoYXIgPSAvW1xcW1xcXXt9KCldLztcblxuICB2YXIgdW5zaWduZWROdW1iZXIgPSAvXFxkWzAtOV9dKi87XG4gIHZhciBkZWNpbWFsTGl0ZXJhbCA9IC9cXGQqXFxzKidzP2RcXHMqXFxkWzAtOV9dKi9pO1xuICB2YXIgYmluYXJ5TGl0ZXJhbCA9IC9cXGQqXFxzKidzP2JcXHMqW3h6MDFdW3h6MDFfXSovaTtcbiAgdmFyIG9jdExpdGVyYWwgPSAvXFxkKlxccyoncz9vXFxzKlt4ejAtN11beHowLTdfXSovaTtcbiAgdmFyIGhleExpdGVyYWwgPSAvXFxkKlxccyoncz9oXFxzKlswLTlhLWZ4ej9dWzAtOWEtZnh6P19dKi9pO1xuICB2YXIgcmVhbExpdGVyYWwgPSAvKFxcZFtcXGRfXSooXFwuXFxkW1xcZF9dKik/RS0/W1xcZF9dKyl8KFxcZFtcXGRfXSpcXC5cXGRbXFxkX10qKS9pO1xuXG4gIHZhciBjbG9zaW5nQnJhY2tldE9yV29yZCA9IC9eKChcXHcrKXxbKX1cXF1dKS87XG4gIHZhciBjbG9zaW5nQnJhY2tldCA9IC9bKX1cXF1dLztcblxuICB2YXIgY3VyUHVuYztcbiAgdmFyIGN1cktleXdvcmQ7XG5cbiAgLy8gQmxvY2sgb3BlbmluZ3Mgd2hpY2ggYXJlIGNsb3NlZCBieSBhIG1hdGNoaW5nIGtleXdvcmQgaW4gdGhlIGZvcm0gb2YgKFwiZW5kXCIgKyBrZXl3b3JkKVxuICAvLyBFLmcuIFwidGFza1wiID0+IFwiZW5kdGFza1wiXG4gIHZhciBibG9ja0tleXdvcmRzID0gd29yZHMoXG4gICAgXCJjYXNlIGNoZWNrZXIgY2xhc3MgY2xvY2tpbmcgY29uZmlnIGZ1bmN0aW9uIGdlbmVyYXRlIGludGVyZmFjZSBtb2R1bGUgcGFja2FnZSBcIiArXG4gICAgICBcInByaW1pdGl2ZSBwcm9ncmFtIHByb3BlcnR5IHNwZWNpZnkgc2VxdWVuY2UgdGFibGUgdGFza1wiXG4gICk7XG5cbiAgLy8gT3BlbmluZy9jbG9zaW5nIHBhaXJzXG4gIHZhciBvcGVuQ2xvc2UgPSB7fTtcbiAgZm9yICh2YXIga2V5d29yZCBpbiBibG9ja0tleXdvcmRzKSB7XG4gICAgb3BlbkNsb3NlW2tleXdvcmRdID0gXCJlbmRcIiArIGtleXdvcmQ7XG4gIH1cbiAgb3BlbkNsb3NlW1wiYmVnaW5cIl0gPSBcImVuZFwiO1xuICBvcGVuQ2xvc2VbXCJjYXNleFwiXSA9IFwiZW5kY2FzZVwiO1xuICBvcGVuQ2xvc2VbXCJjYXNlelwiXSA9IFwiZW5kY2FzZVwiO1xuICBvcGVuQ2xvc2VbXCJkb1wiICAgXSA9IFwid2hpbGVcIjtcbiAgb3BlbkNsb3NlW1wiZm9ya1wiIF0gPSBcImpvaW47am9pbl9hbnk7am9pbl9ub25lXCI7XG4gIG9wZW5DbG9zZVtcImNvdmVyZ3JvdXBcIl0gPSBcImVuZGdyb3VwXCI7XG5cbiAgZm9yICh2YXIgaSBpbiBub0luZGVudEtleXdvcmRzKSB7XG4gICAgdmFyIGtleXdvcmQgPSBub0luZGVudEtleXdvcmRzW2ldO1xuICAgIGlmIChvcGVuQ2xvc2Vba2V5d29yZF0pIHtcbiAgICAgIG9wZW5DbG9zZVtrZXl3b3JkXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvLyBLZXl3b3JkcyB3aGljaCBvcGVuIHN0YXRlbWVudHMgdGhhdCBhcmUgZW5kZWQgd2l0aCBhIHNlbWktY29sb25cbiAgdmFyIHN0YXRlbWVudEtleXdvcmRzID0gd29yZHMoXCJhbHdheXMgYWx3YXlzX2NvbWIgYWx3YXlzX2ZmIGFsd2F5c19sYXRjaCBhc3NlcnQgYXNzaWduIGFzc3VtZSBlbHNlIGV4cG9ydCBmb3IgZm9yZWFjaCBmb3JldmVyIGlmIGltcG9ydCBpbml0aWFsIHJlcGVhdCB3aGlsZVwiKTtcblxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5wZWVrKCksIHN0eWxlO1xuICAgIGlmIChob29rc1tjaF0gJiYgKHN0eWxlID0gaG9va3NbY2hdKHN0cmVhbSwgc3RhdGUpKSAhPSBmYWxzZSkgcmV0dXJuIHN0eWxlO1xuICAgIGlmIChob29rcy50b2tlbkJhc2UgJiYgKHN0eWxlID0gaG9va3MudG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpKSAhPSBmYWxzZSlcbiAgICAgIHJldHVybiBzdHlsZTtcblxuICAgIGlmICgvWyw7OlxcLl0vLnRlc3QoY2gpKSB7XG4gICAgICBjdXJQdW5jID0gc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXNCcmFja2V0Q2hhci50ZXN0KGNoKSkge1xuICAgICAgY3VyUHVuYyA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gICAgfVxuICAgIC8vIE1hY3JvcyAodGljay1kZWZpbmVzKVxuICAgIGlmIChjaCA9PSAnYCcpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBpZiAoc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKSkge1xuICAgICAgICByZXR1cm4gXCJkZWZcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBTeXN0ZW0gY2FsbHNcbiAgICBpZiAoY2ggPT0gJyQnKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgaWYgKHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9dLykpIHtcbiAgICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFRpbWUgbGl0ZXJhbHNcbiAgICBpZiAoY2ggPT0gJyMnKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFxkXy5dLyk7XG4gICAgICByZXR1cm4gXCJkZWZcIjtcbiAgICB9XG4gICAgLy8gU3RyaW5nc1xuICAgIGlmIChjaCA9PSAnXCInKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZyhjaCk7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIC8vIENvbW1lbnRzXG4gICAgaWYgKGNoID09IFwiL1wiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5Db21tZW50O1xuICAgICAgICByZXR1cm4gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfVxuICAgICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICB9XG5cbiAgICAvLyBOdW1lcmljIGxpdGVyYWxzXG4gICAgaWYgKHN0cmVhbS5tYXRjaChyZWFsTGl0ZXJhbCkgfHxcbiAgICAgICAgc3RyZWFtLm1hdGNoKGRlY2ltYWxMaXRlcmFsKSB8fFxuICAgICAgICBzdHJlYW0ubWF0Y2goYmluYXJ5TGl0ZXJhbCkgfHxcbiAgICAgICAgc3RyZWFtLm1hdGNoKG9jdExpdGVyYWwpIHx8XG4gICAgICAgIHN0cmVhbS5tYXRjaChoZXhMaXRlcmFsKSB8fFxuICAgICAgICBzdHJlYW0ubWF0Y2godW5zaWduZWROdW1iZXIpIHx8XG4gICAgICAgIHN0cmVhbS5tYXRjaChyZWFsTGl0ZXJhbCkpIHtcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH1cblxuICAgIC8vIE9wZXJhdG9yc1xuICAgIGlmIChzdHJlYW0uZWF0V2hpbGUoaXNPcGVyYXRvckNoYXIpKSB7XG4gICAgICByZXR1cm4gXCJtZXRhXCI7XG4gICAgfVxuXG4gICAgLy8gS2V5d29yZHMgLyBwbGFpbiB2YXJpYWJsZXNcbiAgICBpZiAoc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKSkge1xuICAgICAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICBpZiAoa2V5d29yZHNbY3VyXSkge1xuICAgICAgICBpZiAob3BlbkNsb3NlW2N1cl0pIHtcbiAgICAgICAgICBjdXJQdW5jID0gXCJuZXdibG9ja1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZW1lbnRLZXl3b3Jkc1tjdXJdKSB7XG4gICAgICAgICAgY3VyUHVuYyA9IFwibmV3c3RhdGVtZW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgY3VyS2V5d29yZCA9IGN1cjtcbiAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgICB9XG5cbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dCwgZW5kID0gZmFsc2U7XG4gICAgICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0ID09IHF1b3RlICYmICFlc2NhcGVkKSB7ZW5kID0gdHJ1ZTsgYnJlYWs7fVxuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgfHwgIShlc2NhcGVkIHx8IG11bHRpTGluZVN0cmluZ3MpKVxuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCIvXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KGluZGVudGVkLCBjb2x1bW4sIHR5cGUsIGFsaWduLCBwcmV2KSB7XG4gICAgdGhpcy5pbmRlbnRlZCA9IGluZGVudGVkO1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hbGlnbiA9IGFsaWduO1xuICAgIHRoaXMucHJldiA9IHByZXY7XG4gIH1cbiAgZnVuY3Rpb24gcHVzaENvbnRleHQoc3RhdGUsIGNvbCwgdHlwZSkge1xuICAgIHZhciBpbmRlbnQgPSBzdGF0ZS5pbmRlbnRlZDtcbiAgICB2YXIgYyA9IG5ldyBDb250ZXh0KGluZGVudCwgY29sLCB0eXBlLCBudWxsLCBzdGF0ZS5jb250ZXh0KTtcbiAgICByZXR1cm4gc3RhdGUuY29udGV4dCA9IGM7XG4gIH1cbiAgZnVuY3Rpb24gcG9wQ29udGV4dChzdGF0ZSkge1xuICAgIHZhciB0ID0gc3RhdGUuY29udGV4dC50eXBlO1xuICAgIGlmICh0ID09IFwiKVwiIHx8IHQgPT0gXCJdXCIgfHwgdCA9PSBcIn1cIikge1xuICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdGF0ZS5jb250ZXh0LmluZGVudGVkO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuY29udGV4dCA9IHN0YXRlLmNvbnRleHQucHJldjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ2xvc2luZyh0ZXh0LCBjb250ZXh0Q2xvc2luZykge1xuICAgIGlmICh0ZXh0ID09IGNvbnRleHRDbG9zaW5nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29udGV4dENsb3NpbmcgbWF5IGJlIG11bHRpcGxlIGtleXdvcmRzIHNlcGFyYXRlZCBieSA7XG4gICAgICB2YXIgY2xvc2luZ0tleXdvcmRzID0gY29udGV4dENsb3Npbmcuc3BsaXQoXCI7XCIpO1xuICAgICAgZm9yICh2YXIgaSBpbiBjbG9zaW5nS2V5d29yZHMpIHtcbiAgICAgICAgaWYgKHRleHQgPT0gY2xvc2luZ0tleXdvcmRzW2ldKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZEVsZWN0cmljSW5wdXRSZWdFeCgpIHtcbiAgICAvLyBSZWluZGVudGF0aW9uIHNob3VsZCBvY2N1ciBvbiBhbnkgYnJhY2tldCBjaGFyOiB7fSgpW11cbiAgICAvLyBvciBvbiBhIG1hdGNoIG9mIGFueSBvZiB0aGUgYmxvY2sgY2xvc2luZyBrZXl3b3JkcywgYXRcbiAgICAvLyB0aGUgZW5kIG9mIGEgbGluZVxuICAgIHZhciBhbGxDbG9zaW5ncyA9IFtdO1xuICAgIGZvciAodmFyIGkgaW4gb3BlbkNsb3NlKSB7XG4gICAgICBpZiAob3BlbkNsb3NlW2ldKSB7XG4gICAgICAgIHZhciBjbG9zaW5ncyA9IG9wZW5DbG9zZVtpXS5zcGxpdChcIjtcIik7XG4gICAgICAgIGZvciAodmFyIGogaW4gY2xvc2luZ3MpIHtcbiAgICAgICAgICBhbGxDbG9zaW5ncy5wdXNoKGNsb3NpbmdzW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiW3t9KClcXFxcW1xcXFxdXXwoXCIgKyBhbGxDbG9zaW5ncy5qb2luKFwifFwiKSArIFwiKSRcIik7XG4gICAgcmV0dXJuIHJlO1xuICB9XG5cbiAgLy8gSW50ZXJmYWNlXG4gIHJldHVybiB7XG4gICAgbmFtZTogXCJ2ZXJpbG9nXCIsXG5cbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbihpbmRlbnRVbml0KSB7XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIHRva2VuaXplOiBudWxsLFxuICAgICAgICBjb250ZXh0OiBuZXcgQ29udGV4dCgtaW5kZW50VW5pdCwgMCwgXCJ0b3BcIiwgZmFsc2UpLFxuICAgICAgICBpbmRlbnRlZDogMCxcbiAgICAgICAgc3RhcnRPZkxpbmU6IHRydWVcbiAgICAgIH07XG4gICAgICBpZiAoaG9va3Muc3RhcnRTdGF0ZSkgaG9va3Muc3RhcnRTdGF0ZShzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcblxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgY3R4ID0gc3RhdGUuY29udGV4dDtcbiAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgaWYgKGN0eC5hbGlnbiA9PSBudWxsKSBjdHguYWxpZ24gPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICAgICAgc3RhdGUuc3RhcnRPZkxpbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGhvb2tzLnRva2VuKSB7XG4gICAgICAgIC8vIENhbGwgaG9vaywgd2l0aCBhbiBvcHRpb25hbCByZXR1cm4gdmFsdWUgb2YgYSBzdHlsZSB0byBvdmVycmlkZSB2ZXJpbG9nIHN0eWxpbmcuXG4gICAgICAgIHZhciBzdHlsZSA9IGhvb2tzLnRva2VuKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgIGN1clB1bmMgPSBudWxsO1xuICAgICAgY3VyS2V5d29yZCA9IG51bGw7XG4gICAgICB2YXIgc3R5bGUgPSAoc3RhdGUudG9rZW5pemUgfHwgdG9rZW5CYXNlKShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmIChzdHlsZSA9PSBcImNvbW1lbnRcIiB8fCBzdHlsZSA9PSBcIm1ldGFcIiB8fCBzdHlsZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBzdHlsZTtcbiAgICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkgY3R4LmFsaWduID0gdHJ1ZTtcblxuICAgICAgaWYgKGN1clB1bmMgPT0gY3R4LnR5cGUpIHtcbiAgICAgICAgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKChjdXJQdW5jID09IFwiO1wiICYmIGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIHx8XG4gICAgICAgICAgICAgICAgIChjdHgudHlwZSAmJiBpc0Nsb3NpbmcoY3VyS2V5d29yZCwgY3R4LnR5cGUpKSkge1xuICAgICAgICBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgd2hpbGUgKGN0eCAmJiBjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VyUHVuYyA9PSBcIntcIikge1xuICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcIn1cIik7XG4gICAgICB9IGVsc2UgaWYgKGN1clB1bmMgPT0gXCJbXCIpIHtcbiAgICAgICAgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJdXCIpO1xuICAgICAgfSBlbHNlIGlmIChjdXJQdW5jID09IFwiKFwiKSB7XG4gICAgICAgIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwiKVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoY3R4ICYmIGN0eC50eXBlID09IFwiZW5kY2FzZVwiICYmIGN1clB1bmMgPT0gXCI6XCIpIHtcbiAgICAgICAgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJzdGF0ZW1lbnRcIik7XG4gICAgICB9IGVsc2UgaWYgKGN1clB1bmMgPT0gXCJuZXdzdGF0ZW1lbnRcIikge1xuICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcInN0YXRlbWVudFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VyUHVuYyA9PSBcIm5ld2Jsb2NrXCIpIHtcbiAgICAgICAgaWYgKGN1cktleXdvcmQgPT0gXCJmdW5jdGlvblwiICYmIGN0eCAmJiAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIiB8fCBjdHgudHlwZSA9PSBcImVuZGdyb3VwXCIpKSB7XG4gICAgICAgICAgLy8gVGhlICdmdW5jdGlvbicga2V5d29yZCBjYW4gYXBwZWFyIGluIHNvbWUgb3RoZXIgY29udGV4dHMgd2hlcmUgaXQgYWN0dWFsbHkgZG9lcyBub3RcbiAgICAgICAgICAvLyBpbmRpY2F0ZSBhIGZ1bmN0aW9uIChpbXBvcnQvZXhwb3J0IERQSSBhbmQgY292ZXJncm91cCBkZWZpbml0aW9ucykuXG4gICAgICAgICAgLy8gRG8gbm90aGluZyBpbiB0aGlzIGNhc2VcbiAgICAgICAgfSBlbHNlIGlmIChjdXJLZXl3b3JkID09IFwidGFza1wiICYmIGN0eCAmJiBjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSB7XG4gICAgICAgICAgLy8gU2FtZSB0aGluZyBmb3IgdGFza1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjbG9zZSA9IG9wZW5DbG9zZVtjdXJLZXl3b3JkXTtcbiAgICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBjbG9zZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhdGUuc3RhcnRPZkxpbmUgPSBmYWxzZTtcbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBjeCkge1xuICAgICAgaWYgKHN0YXRlLnRva2VuaXplICE9IHRva2VuQmFzZSAmJiBzdGF0ZS50b2tlbml6ZSAhPSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChob29rcy5pbmRlbnQpIHtcbiAgICAgICAgdmFyIGZyb21Ib29rID0gaG9va3MuaW5kZW50KHN0YXRlKTtcbiAgICAgICAgaWYgKGZyb21Ib29rID49IDApIHJldHVybiBmcm9tSG9vaztcbiAgICAgIH1cbiAgICAgIHZhciBjdHggPSBzdGF0ZS5jb250ZXh0LCBmaXJzdENoYXIgPSB0ZXh0QWZ0ZXIgJiYgdGV4dEFmdGVyLmNoYXJBdCgwKTtcbiAgICAgIGlmIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiICYmIGZpcnN0Q2hhciA9PSBcIn1cIikgY3R4ID0gY3R4LnByZXY7XG4gICAgICB2YXIgY2xvc2luZyA9IGZhbHNlO1xuICAgICAgdmFyIHBvc3NpYmxlQ2xvc2luZyA9IHRleHRBZnRlci5tYXRjaChjbG9zaW5nQnJhY2tldE9yV29yZCk7XG4gICAgICBpZiAocG9zc2libGVDbG9zaW5nKVxuICAgICAgICBjbG9zaW5nID0gaXNDbG9zaW5nKHBvc3NpYmxlQ2xvc2luZ1swXSwgY3R4LnR5cGUpO1xuICAgICAgaWYgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIHJldHVybiBjdHguaW5kZW50ZWQgKyAoZmlyc3RDaGFyID09IFwie1wiID8gMCA6IHN0YXRlbWVudEluZGVudFVuaXQgfHwgY3gudW5pdCk7XG4gICAgICBlbHNlIGlmIChjbG9zaW5nQnJhY2tldC50ZXN0KGN0eC50eXBlKSAmJiBjdHguYWxpZ24gJiYgIWRvbnRBbGlnbkNhbGxzKSByZXR1cm4gY3R4LmNvbHVtbiArIChjbG9zaW5nID8gMCA6IDEpO1xuICAgICAgZWxzZSBpZiAoY3R4LnR5cGUgPT0gXCIpXCIgJiYgIWNsb3NpbmcpIHJldHVybiBjdHguaW5kZW50ZWQgKyAoc3RhdGVtZW50SW5kZW50VW5pdCB8fCBjeC51bml0KTtcbiAgICAgIGVsc2UgcmV0dXJuIGN0eC5pbmRlbnRlZCArIChjbG9zaW5nID8gMCA6IGN4LnVuaXQpO1xuICAgIH0sXG5cbiAgICBsYW5ndWFnZURhdGE6IHtcbiAgICAgIGluZGVudE9uSW5wdXQ6IGJ1aWxkRWxlY3RyaWNJbnB1dFJlZ0V4KCksXG4gICAgICBjb21tZW50VG9rZW5zOiB7bGluZTogXCIvL1wiLCBibG9jazoge29wZW46IFwiLypcIiwgY2xvc2U6IFwiKi9cIn19XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHZlcmlsb2cgPSBta1Zlcmlsb2coe30pXG5cbi8vIFRMLVZlcmlsb2cgbW9kZS5cbi8vIFNlZSB0bC14Lm9yZyBmb3IgbGFuZ3VhZ2Ugc3BlYy5cbi8vIFNlZSB0aGUgbW9kZSBpbiBhY3Rpb24gYXQgbWFrZXJjaGlwLmNvbS5cbi8vIENvbnRhY3Q6IHN0ZXZlLmhvb3ZlckByZWR3b29kZWRhLmNvbVxuXG4vLyBUTFYgSWRlbnRpZmllciBwcmVmaXhlcy5cbi8vIE5vdGUgdGhhdCBzaWduIGlzIG5vdCB0cmVhdGVkIHNlcGFyYXRlbHksIHNvIFwiKy8tXCIgdmVyc2lvbnMgb2YgbnVtZXJpYyBpZGVudGlmaWVyc1xuLy8gYXJlIGluY2x1ZGVkLlxudmFyIHRsdklkZW50aWZpZXJTdHlsZSA9IHtcbiAgXCJ8XCI6IFwibGlua1wiLFxuICBcIj5cIjogXCJwcm9wZXJ0eVwiLCAgLy8gU2hvdWxkIGNvbmRpdGlvbiB0aGlzIG9mZiBmb3IgPiBUTFYgMWMuXG4gIFwiJFwiOiBcInZhcmlhYmxlXCIsXG4gIFwiJCRcIjogXCJ2YXJpYWJsZVwiLFxuICBcIj8kXCI6IFwicXVhbGlmaWVyXCIsXG4gIFwiPypcIjogXCJxdWFsaWZpZXJcIixcbiAgXCItXCI6IFwiY29udGVudFNlcGFyYXRvclwiLFxuICBcIi9cIjogXCJwcm9wZXJ0eVwiLFxuICBcIi8tXCI6IFwicHJvcGVydHlcIixcbiAgXCJAXCI6IFwidmFyaWFibGVOYW1lLnNwZWNpYWxcIixcbiAgXCJALVwiOiBcInZhcmlhYmxlTmFtZS5zcGVjaWFsXCIsXG4gIFwiQCsrXCI6IFwidmFyaWFibGVOYW1lLnNwZWNpYWxcIixcbiAgXCJAKz1cIjogXCJ2YXJpYWJsZU5hbWUuc3BlY2lhbFwiLFxuICBcIkArPS1cIjogXCJ2YXJpYWJsZU5hbWUuc3BlY2lhbFwiLFxuICBcIkAtLVwiOiBcInZhcmlhYmxlTmFtZS5zcGVjaWFsXCIsXG4gIFwiQC09XCI6IFwidmFyaWFibGVOYW1lLnNwZWNpYWxcIixcbiAgXCIlK1wiOiBcInRhZ1wiLFxuICBcIiUtXCI6IFwidGFnXCIsXG4gIFwiJVwiOiBcInRhZ1wiLFxuICBcIj4+XCI6IFwidGFnXCIsXG4gIFwiPDxcIjogXCJ0YWdcIixcbiAgXCI8PlwiOiBcInRhZ1wiLFxuICBcIiNcIjogXCJ0YWdcIiwgIC8vIE5lZWQgdG8gY2hvb3NlIGEgc3R5bGUgZm9yIHRoaXMuXG4gIFwiXlwiOiBcImF0dHJpYnV0ZVwiLFxuICBcIl5eXCI6IFwiYXR0cmlidXRlXCIsXG4gIFwiXiFcIjogXCJhdHRyaWJ1dGVcIixcbiAgXCIqXCI6IFwidmFyaWFibGVcIixcbiAgXCIqKlwiOiBcInZhcmlhYmxlXCIsXG4gIFwiXFxcXFwiOiBcImtleXdvcmRcIixcbiAgXCJcXFwiXCI6IFwiY29tbWVudFwiXG59O1xuXG4vLyBMaW5lcyBzdGFydGluZyB3aXRoIHRoZXNlIGNoYXJhY3RlcnMgZGVmaW5lIHNjb3BlIChyZXN1bHQgaW4gaW5kZW50YXRpb24pLlxudmFyIHRsdlNjb3BlUHJlZml4Q2hhcnMgPSB7XG4gIFwiL1wiOiBcImJlaC1oaWVyXCIsXG4gIFwiPlwiOiBcImJlaC1oaWVyXCIsXG4gIFwiLVwiOiBcInBoeXMtaGllclwiLFxuICBcInxcIjogXCJwaXBlXCIsXG4gIFwiP1wiOiBcIndoZW5cIixcbiAgXCJAXCI6IFwic3RhZ2VcIixcbiAgXCJcXFxcXCI6IFwia2V5d29yZFwiXG59O1xudmFyIHRsdkluZGVudFVuaXQgPSAzO1xudmFyIHRsdlRyYWNrU3RhdGVtZW50cyA9IGZhbHNlO1xudmFyIHRsdklkZW50TWF0Y2ggPSAvXihbfiFAI1xcJCVcXF4mXFwqLVxcKz1cXD9cXC9cXFxcXFx8J1wiPD5dKykoW1xcZFxcd19dKikvOyAgLy8gTWF0Y2hlcyBhbiBpZGVudGlmaWVyLlxuLy8gTm90ZSB0aGF0ICc6JyBpcyBleGNsdWRlZCwgYmVjYXVzZSBvZiBpdCdzIHVzZSBpbiBbOl0uXG52YXIgdGx2TGluZUluZGVudGF0aW9uTWF0Y2ggPSAvXlshIF0gKi87XG52YXIgdGx2Q29tbWVudE1hdGNoID0gL15cXC9bXFwvXFwqXS87XG5cbmV4cG9ydCBjb25zdCB0bHYgPSBta1Zlcmlsb2coe1xuICBob29rczoge1xuICAgIGVsZWN0cmljSW5wdXQ6IGZhbHNlLFxuXG4gICAgLy8gUmV0dXJuIHVuZGVmaW5lZCBmb3IgdmVyaWxvZyB0b2tlbml6aW5nLCBvciBzdHlsZSBmb3IgVExWIHRva2VuIChudWxsIG5vdCB1c2VkKS5cbiAgICAvLyBTdGFuZGFyZCBDTSBzdHlsZXMgYXJlIHVzZWQgZm9yIG1vc3QgZm9ybWF0dGluZywgYnV0IHNvbWUgVEwtVmVyaWxvZy1zcGVjaWZpYyBoaWdobGlnaHRpbmdcbiAgICAvLyBjYW4gYmUgZW5hYmxlZCB3aXRoIHRoZSBkZWZpbml0aW9uIG9mIGNtLXRsdi0qIHN0eWxlcywgaW5jbHVkaW5nIGhpZ2hsaWdodGluZyBmb3I6XG4gICAgLy8gICAtIE00IHRva2Vuc1xuICAgIC8vICAgLSBUTFYgc2NvcGUgaW5kZW50YXRpb25cbiAgICAvLyAgIC0gU3RhdGVtZW50IGRlbGltaXRhdGlvbiAoZW5hYmxlZCBieSB0bHZUcmFja1N0YXRlbWVudHMpXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBzdHlsZSA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBtYXRjaDsgIC8vIFJldHVybiB2YWx1ZSBvZiBwYXR0ZXJuIG1hdGNoZXMuXG5cbiAgICAgIC8vIFNldCBoaWdobGlnaHRpbmcgbW9kZSBiYXNlZCBvbiBjb2RlIHJlZ2lvbiAoVExWIG9yIFNWKS5cbiAgICAgIGlmIChzdHJlYW0uc29sKCkgJiYgISBzdGF0ZS50bHZJbkJsb2NrQ29tbWVudCkge1xuICAgICAgICAvLyBQcm9jZXNzIHJlZ2lvbi5cbiAgICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgc3R5bGUgPSBcImRlZlwiO1xuICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICBpZiAoc3RyZWFtLnN0cmluZy5tYXRjaCgvXFxcXFNWLykpIHtcbiAgICAgICAgICAgIHN0YXRlLnRsdkNvZGVBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5zdHJpbmcubWF0Y2goL1xcXFxUTFYvKSl7XG4gICAgICAgICAgICBzdGF0ZS50bHZDb2RlQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29ycmVjdCBpbmRlbnRhdGlvbiBpbiB0aGUgZmFjZSBvZiBhIGxpbmUgcHJlZml4IGNoYXIuXG4gICAgICAgIGlmIChzdGF0ZS50bHZDb2RlQWN0aXZlICYmIHN0cmVhbS5wb3MgPT0gMCAmJlxuICAgICAgICAgICAgKHN0YXRlLmluZGVudGVkID09IDApICYmIChtYXRjaCA9IHN0cmVhbS5tYXRjaCh0bHZMaW5lSW5kZW50YXRpb25NYXRjaCwgZmFsc2UpKSkge1xuICAgICAgICAgIHN0YXRlLmluZGVudGVkID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBpbmRlbnRhdGlvbiBzdGF0ZTpcbiAgICAgICAgLy8gICBvIEF1dG8gaW5kZW50YXRpb24gb24gbmV4dCBsaW5lXG4gICAgICAgIC8vICAgbyBJbmRlbnRhdGlvbiBzY29wZSBzdHlsZXNcbiAgICAgICAgdmFyIGluZGVudGVkID0gc3RhdGUuaW5kZW50ZWQ7XG4gICAgICAgIHZhciBkZXB0aCA9IGluZGVudGVkIC8gdGx2SW5kZW50VW5pdDtcbiAgICAgICAgaWYgKGRlcHRoIDw9IHN0YXRlLnRsdkluZGVudGF0aW9uU3R5bGUubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gbm90IGRlZXBlciB0aGFuIGN1cnJlbnQgc2NvcGVcblxuICAgICAgICAgIHZhciBibGFua2xpbmUgPSBzdHJlYW0uc3RyaW5nLmxlbmd0aCA9PSBpbmRlbnRlZDtcbiAgICAgICAgICB2YXIgY2hQb3MgPSBkZXB0aCAqIHRsdkluZGVudFVuaXQ7XG4gICAgICAgICAgaWYgKGNoUG9zIDwgc3RyZWFtLnN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBib2R5U3RyaW5nID0gc3RyZWFtLnN0cmluZy5zbGljZShjaFBvcyk7XG4gICAgICAgICAgICB2YXIgY2ggPSBib2R5U3RyaW5nWzBdO1xuICAgICAgICAgICAgaWYgKHRsdlNjb3BlUHJlZml4Q2hhcnNbY2hdICYmICgobWF0Y2ggPSBib2R5U3RyaW5nLm1hdGNoKHRsdklkZW50TWF0Y2gpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bHZJZGVudGlmaWVyU3R5bGVbbWF0Y2hbMV1dKSkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGxpbmUgYmVnaW5zIHNjb3BlLlxuICAgICAgICAgICAgICAvLyBOZXh0IGxpbmUgZ2V0cyBpbmRlbnRlZCBvbmUgbGV2ZWwuXG4gICAgICAgICAgICAgIGluZGVudGVkICs9IHRsdkluZGVudFVuaXQ7XG4gICAgICAgICAgICAgIC8vIFN0eWxlIHRoZSBuZXh0IGxldmVsIG9mIGluZGVudGF0aW9uIChleGNlcHQgbm9uLXJlZ2lvbiBrZXl3b3JkIGlkZW50aWZpZXJzLFxuICAgICAgICAgICAgICAvLyAgIHdoaWNoIGFyZSBzdGF0ZW1lbnRzIHRoZW1zZWx2ZXMpXG4gICAgICAgICAgICAgIGlmICghKGNoID09IFwiXFxcXFwiICYmIGNoUG9zID4gMCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS50bHZJbmRlbnRhdGlvblN0eWxlW2RlcHRoXSA9IHRsdlNjb3BlUHJlZml4Q2hhcnNbY2hdO1xuICAgICAgICAgICAgICAgIGlmICh0bHZUcmFja1N0YXRlbWVudHMpIHtzdGF0ZS5zdGF0ZW1lbnRDb21tZW50ID0gZmFsc2U7fVxuICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ2xlYXIgb3V0IGRlZXBlciBpbmRlbnRhdGlvbiBsZXZlbHMgdW5sZXNzIGxpbmUgaXMgYmxhbmsuXG4gICAgICAgICAgaWYgKCFibGFua2xpbmUpIHtcbiAgICAgICAgICAgIHdoaWxlIChzdGF0ZS50bHZJbmRlbnRhdGlvblN0eWxlLmxlbmd0aCA+IGRlcHRoKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnRsdkluZGVudGF0aW9uU3R5bGUucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBuZXh0IGxldmVsIG9mIGluZGVudGF0aW9uLlxuICAgICAgICBzdGF0ZS50bHZOZXh0SW5kZW50ID0gaW5kZW50ZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS50bHZDb2RlQWN0aXZlKSB7XG4gICAgICAgIC8vIEhpZ2hsaWdodCBhcyBUTFYuXG5cbiAgICAgICAgdmFyIGJlZ2luU3RhdGVtZW50ID0gZmFsc2U7XG4gICAgICAgIGlmICh0bHZUcmFja1N0YXRlbWVudHMpIHtcbiAgICAgICAgICAvLyBUaGlzIHN0YXJ0cyBhIHN0YXRlbWVudCBpZiB0aGUgcG9zaXRpb24gaXMgYXQgdGhlIHNjb3BlIGxldmVsXG4gICAgICAgICAgLy8gYW5kIHdlJ3JlIG5vdCB3aXRoaW4gYSBzdGF0ZW1lbnQgbGVhZGluZyBjb21tZW50LlxuICAgICAgICAgIGJlZ2luU3RhdGVtZW50ID1cbiAgICAgICAgICAgIChzdHJlYW0ucGVlaygpICE9IFwiIFwiKSAmJiAgIC8vIG5vdCBhIHNwYWNlXG4gICAgICAgICAgICAoc3R5bGUgPT09IHVuZGVmaW5lZCkgJiYgICAgLy8gbm90IGEgcmVnaW9uIGlkZW50aWZpZXJcbiAgICAgICAgICAgICFzdGF0ZS50bHZJbkJsb2NrQ29tbWVudCAmJiAvLyBub3QgaW4gYmxvY2sgY29tbWVudFxuICAgICAgICAgICAgLy8hc3RyZWFtLm1hdGNoKHRsdkNvbW1lbnRNYXRjaCwgZmFsc2UpICYmIC8vIG5vdCBjb21tZW50IHN0YXJ0XG4gICAgICAgICAgKHN0cmVhbS5jb2x1bW4oKSA9PSBzdGF0ZS50bHZJbmRlbnRhdGlvblN0eWxlLmxlbmd0aCAqIHRsdkluZGVudFVuaXQpOyAgLy8gYXQgc2NvcGUgbGV2ZWxcbiAgICAgICAgICBpZiAoYmVnaW5TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zdGF0ZW1lbnRDb21tZW50KSB7XG4gICAgICAgICAgICAgIC8vIHN0YXRlbWVudCBhbHJlYWR5IHN0YXJ0ZWQgYnkgY29tbWVudFxuICAgICAgICAgICAgICBiZWdpblN0YXRlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUuc3RhdGVtZW50Q29tbWVudCA9XG4gICAgICAgICAgICAgIHN0cmVhbS5tYXRjaCh0bHZDb21tZW50TWF0Y2gsIGZhbHNlKTsgLy8gY29tbWVudCBzdGFydFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS50bHZJbkJsb2NrQ29tbWVudCkge1xuICAgICAgICAgIC8vIEluIGEgYmxvY2sgY29tbWVudC5cbiAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eLio/XFwqXFwvLykpIHtcbiAgICAgICAgICAgIC8vIEV4aXQgYmxvY2sgY29tbWVudC5cbiAgICAgICAgICAgIHN0YXRlLnRsdkluQmxvY2tDb21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGx2VHJhY2tTdGF0ZW1lbnRzICYmICFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICAgICAgLy8gQW55dGhpbmcgYWZ0ZXIgY29tbWVudCBpcyBhc3N1bWVkIHRvIGJlIHJlYWwgc3RhdGVtZW50IGNvbnRlbnQuXG4gICAgICAgICAgICAgIHN0YXRlLnN0YXRlbWVudENvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHlsZSA9IFwiY29tbWVudFwiO1xuICAgICAgICB9IGVsc2UgaWYgKChtYXRjaCA9IHN0cmVhbS5tYXRjaCh0bHZDb21tZW50TWF0Y2gpKSAmJiAhc3RhdGUudGx2SW5CbG9ja0NvbW1lbnQpIHtcbiAgICAgICAgICAvLyBTdGFydCBjb21tZW50LlxuICAgICAgICAgIGlmIChtYXRjaFswXSA9PSBcIi8vXCIpIHtcbiAgICAgICAgICAgIC8vIExpbmUgY29tbWVudC5cbiAgICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQmxvY2sgY29tbWVudC5cbiAgICAgICAgICAgIHN0YXRlLnRsdkluQmxvY2tDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3R5bGUgPSBcImNvbW1lbnRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IHN0cmVhbS5tYXRjaCh0bHZJZGVudE1hdGNoKSkge1xuICAgICAgICAgIC8vIGxvb2tzIGxpa2UgYW4gaWRlbnRpZmllciAob3IgaWRlbnRpZmllciBwcmVmaXgpXG4gICAgICAgICAgdmFyIHByZWZpeCA9IG1hdGNoWzFdO1xuICAgICAgICAgIHZhciBtbmVtb25pYyA9IG1hdGNoWzJdO1xuICAgICAgICAgIGlmICgvLyBpcyBpZGVudGlmaWVyIHByZWZpeFxuICAgICAgICAgICAgdGx2SWRlbnRpZmllclN0eWxlLmhhc093blByb3BlcnR5KHByZWZpeCkgJiZcbiAgICAgICAgICAgICAgLy8gaGFzIG1uZW1vbmljIG9yIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUgKG1heWJlIGl0IGhhc24ndCBiZWVuIHR5cGVkIHlldClcbiAgICAgICAgICAgIChtbmVtb25pYy5sZW5ndGggPiAwIHx8IHN0cmVhbS5lb2woKSkpIHtcbiAgICAgICAgICAgIHN0eWxlID0gdGx2SWRlbnRpZmllclN0eWxlW3ByZWZpeF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEp1c3Qgc3dhbGxvdyBvbmUgY2hhcmFjdGVyIGFuZCB0cnkgYWdhaW4uXG4gICAgICAgICAgICAvLyBUaGlzIGVuYWJsZXMgc3Vic2VxdWVudCBpZGVudGlmaWVyIG1hdGNoIHdpdGggcHJlY2VkaW5nIHN5bWJvbCBjaGFyYWN0ZXIsIHdoaWNoXG4gICAgICAgICAgICAvLyAgIGlzIGxlZ2FsIHdpdGhpbiBhIHN0YXRlbWVudC4gIChFZywgISRyZXNldCkuICBJdCBhbHNvIGVuYWJsZXMgZGV0ZWN0aW9uIG9mXG4gICAgICAgICAgICAvLyAgIGNvbW1lbnQgc3RhcnQgd2l0aCBwcmVjZWRpbmcgc3ltYm9scy5cbiAgICAgICAgICAgIHN0cmVhbS5iYWNrVXAoc3RyZWFtLmN1cnJlbnQoKS5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eXFx0Ky8pKSB7XG4gICAgICAgICAgLy8gSGlnaGxpZ2h0IHRhYnMsIHdoaWNoIGFyZSBpbGxlZ2FsLlxuICAgICAgICAgIHN0eWxlID0gXCJpbnZhbGlkXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eW1xcW1xcXXt9XFwoXFwpO1xcOl0rLykpIHtcbiAgICAgICAgICAvLyBbOl0sICgpLCB7fSwgOy5cbiAgICAgICAgICBzdHlsZSA9IFwibWV0YVwiO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKC9eW21NXTQoW1xcK19dKT9bXFx3XFxkX10qLykpIHtcbiAgICAgICAgICAvLyBtNCBwcmUgcHJvY1xuICAgICAgICAgIHN0eWxlID0gKG1hdGNoWzFdID09IFwiK1wiKSA/IFwia2V5d29yZC5zcGVjaWFsXCIgOiBcImtleXdvcmRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL14gKy8pKXtcbiAgICAgICAgICAvLyBTa2lwIG92ZXIgc3BhY2VzLlxuICAgICAgICAgIGlmIChzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICAgIC8vIFRyYWlsaW5nIHNwYWNlcy5cbiAgICAgICAgICAgIHN0eWxlID0gXCJlcnJvclwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL15bXFx3XFxkX10rLykpIHtcbiAgICAgICAgICAvLyBhbHBoYS1udW1lcmljIHRva2VuLlxuICAgICAgICAgIHN0eWxlID0gXCJudW1iZXJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBFYXQgdGhlIG5leHQgY2hhciB3LyBubyBmb3JtYXR0aW5nLlxuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15bbU1dNChbXFx3XFxkX10qKS8pKSB7XG4gICAgICAgICAgLy8gbTQgcHJlIHByb2NcbiAgICAgICAgICBzdHlsZSA9IFwia2V5d29yZFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcblxuICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHJldHVybiAoc3RhdGUudGx2Q29kZUFjdGl2ZSA9PSB0cnVlKSA/IHN0YXRlLnRsdk5leHRJbmRlbnQgOiAtMTtcbiAgICB9LFxuXG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHN0YXRlLnRsdkluZGVudGF0aW9uU3R5bGUgPSBbXTsgIC8vIFN0eWxlcyB0byB1c2UgZm9yIGVhY2ggbGV2ZWwgb2YgaW5kZW50YXRpb24uXG4gICAgICBzdGF0ZS50bHZDb2RlQWN0aXZlID0gdHJ1ZTsgIC8vIFRydWUgd2hlbiB3ZSdyZSBpbiBhIFRMViByZWdpb24gKGFuZCBhdCBiZWdpbm5pbmcgb2YgZmlsZSkuXG4gICAgICBzdGF0ZS50bHZOZXh0SW5kZW50ID0gLTE7ICAgIC8vIFRoZSBudW1iZXIgb2Ygc3BhY2VzIHRvIGF1dG9pbmRlbnQgdGhlIG5leHQgbGluZSBpZiB0bHZDb2RlQWN0aXZlLlxuICAgICAgc3RhdGUudGx2SW5CbG9ja0NvbW1lbnQgPSBmYWxzZTsgIC8vIFRydWUgaW5zaWRlIC8qKi8gY29tbWVudC5cbiAgICAgIGlmICh0bHZUcmFja1N0YXRlbWVudHMpIHtcbiAgICAgICAgc3RhdGUuc3RhdGVtZW50Q29tbWVudCA9IGZhbHNlOyAgLy8gVHJ1ZSBpbnNpZGUgYSBzdGF0ZW1lbnQncyBoZWFkZXIgY29tbWVudC5cbiAgICAgIH1cbiAgICB9XG5cbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/legacy-modes/mode/verilog.js\n"));

/***/ })

}]);